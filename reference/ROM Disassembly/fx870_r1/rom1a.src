; ROM of the FX-870P/VX-4 microcomputer, bank 0, part 1

; constants:
; $SX = $31 = &H00
; $SY = $30 = &H01
; $SZ = $0

0C00:	00 64 18 5A

; Kana mode keyboard table
0C04:	             03 25 50 24  01 4F 10 2E  29 1F 04 A4
0C10:	30 2F 15 1A  02 31 38 06  33 55 B6 B7  B8 B9 BA BB
0C20:	BC BD BE BF  C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB
0C30:	CC CD CE CF  D0 D1 D2 D3  D7 D8 D9 DA  DB D4 B2 D5
0C40:	B4 D6 DC B2  B3 A9 A6 AC  A8 AD AA AE

; CORDIC constant 10^j * atn (10^-j) for j>=7
0C4C:	00 00 00 00 00 00 10

; table of CORDIC constants 10^j * atn (10^-j)
0C53:	00 40 63 81 39 85 07	;atn 1 = 0.7853981634000
0C5A:	16 91 24 65 68 96 09	;atn 0.1 = 0.09966865249117
0C61:	65 66 68 66 96 99 09	;atn 0.01 = 0.009999666686666
0C68:	69 66 66 96 99 99 09	;atn 0.001 = 0.0009999996666669
0C6F:	67 66 96 99 99 99 09	;atn 0.0001 = 0.00009999999966667
0C76:	67 96 99 99 99 99 09	;atn 0.00001 = 0.000009999999999667
0C7D:	97 99 99 99 99 99 09	;atn 0.000001 = 0.0000009999999999997

0C84:	30 90 81 44 29 34 04	;log e = 0.434294481903

; table of CORDIC constants 10^j * log (1+10^-j)
0C8B:	40 66 95 99 02 01 03	;log 2 = 0.301029995664
0C92:	22 58 51 68 92 13 04	;log 1.1 = 0.0413926851582
0C99:	43 26 78 73 13 32 04	;log 1.01 = 0.004321373782643
0CA0:	86 31 79 74 07 34 04	;log 1.001 = 0.0004340774793186
0CA7:	67 62 68 27 27 34 04	;log 1.0001 = 0.00004342727686266
0CAE:	53 44 10 23 29 34 04	;log 1.00001 = 0.000004342923104482
0CB5:	62 75 64 42 29 34 04	;log 1.000001 = 0.0000004342942647204
0CBC:	85 18 60 44 29 34 04	;log 1.0000001 = 0.00000004342944604421
0CC3:	18 73 79 44 29 34 04	;log 1.00000001 = 0.000000004342944770924
0CCA:	61 68 81 44 29 34 04	;log 1.000000001
0CD1:	15 88 81 44 29 34 04	;log 1.0000000001
0CD8:	11 90 81 44 29 34 04	;log 1.00000000001
0CDF:	30 90 81 44 29 34 04	;log 1.000000000001

0CE6:	00 20 25 29 53 74 81 09		;0.017453292520 = PI/180
0CEE:	00 00 00 00 00 00 01 10		;1.0000000000
0CF6:	00 68 32 96 07 57 81 09		;0.015707963268 = PI/200

0CFE:	00 00 00 00 00 00 19 10		;90.000000000
0D06:	00 68 32 96 07 57 01 10		;1.5707963268 = PI/2
0D0E:	00 00 00 00 00 00 21 10		;100.00000000

0D16:	00 36 65 92 15 14 03 10		;PI
0D1E:	33 90 81 44 29 34 94 09		;0.4342944819033 = 1/LN(10) = LOG(e)
0D26:	00 00 00 30 01 17 17 10		;71.701300000

; LCD contrast data table
0D2E:	0A 10  48 10  80 11  40 20  06 20  02 22  01 0C  80 0C
0D3E:	01 0E  01 18  01 24  00 26  40 26  03 30  08 80  0B 80
0D4E:	08 60  01 84  00 8A  0F 90  80 10  00 12  00 14  20 0E
0D5E:	00 22  00 1A  00 30  00 34  00 3C  C0 3F  00 78  FF 7F

0D6E:	jp	&H1F50		;reset 
0D71:	jp	&H1F4C		;power switch on
0D74:	jp	&H1F84		;instruction TRP
0D77:	jp	&H0074		;ON interrupt
0D7A:	jp	&H0086		;one-minute timer interrupt
0D7D:	jp	&H1FAF		;external interrupt 2
0D80:	jp	&H1F85		;pulse/key interrupt
0D83:	jp	&H83B9		;external interrupt 1
0D86:	rtn
0D87:	db	&HFF, &HFF
0D89:	rtn
0D8A:	db	&HFF, &HFF
0D8C:	jp	&H11B2		;check the user stack space
0D8F:	jp	&H2AAD		;power-off
0D92:	jp	&H250D		;decode the pressed key
0D95:	jp	&H273D
0D98:	jp	&H29ED
0D9B:	jp	&H2BA4		;BS Error, subscript out of range
0D9E:	jp	&H2B70		;SN Error, syntax
0DA1:	jp	&H2B9C		;MA Error, mathematical error
0DA4:	jp	&H2B98		;OV Error, overflow
0DA7:	jp	&H2BBC		;DA error, no data for READ
0DAA:	jp	&H2A2C
0DAD:	jp	&H9249
0DB0:	jp	&H2930
0DB3:	jp	&H92DD		;$5,$6 <- address of the font table
0DB6:	jp	&H2ACB		;disable interrupts then issue the OFF command

; function addresses for the arithmetic operators
0DB9:	1014, 1011, 101D, 1025	;+ - * /
0DC1:	1045, 105F, 102D, 05B2	;integer division, MOD, ^, sign change
0DC9:	05B9, 05BE, 05BE, 05BE	;C3:NOT, C4:AND, C5:OR, C6:XOR

; table of the "prefix 5" function addresses, keyword codes &H4F-&HAC
0DD1:	1878, 186D, 1BF4, 1BF8	;4F:ERL, 50:ERR, 51:CNT, 52:SUMX
0DD9:	1BFC, 1C00, 1C04, 1C08	;53:SUMY, 54:SUMX2, 55:SUMY2, 56:SUMXY
0DE1:	1C65, 1C6A, 1C3F, 1C43	;57:MEANX, 58:MEANY, 59:SDX, 5A:SDY
0DE9:	1C59, 1C5F, 1C9B, 1CA6	;5B:SDXN, 5C:SDYN, 5D:LRA, 5E:LRB
0DF1:	1CAB, 09C5, 7EE9, 2BA8	;5F:COR, 60:PI, 61:DSKF, 62:none
0DF9:	19C2, 2BA8, 2BA8, 2BA8	;63:CUR, 64:none, 65:none, 66:none
0E01:	19E4, 2BA8, 1CC9, 1CE1	;67:FACT, 68:none, 69:EOX, 6A:EOY
0E09:	0872, 0874, 0878, 08DF	;6B:SIN, 6C:COS, 6D:TAN, 6E:ASN
0E11:	08E1, 08E3, 147F, 1483	;6F:ACS, 70:ATN, 71:HYPSIN, 72:HYPCOS
0E19:	1487, 148A, 148E, 1492	;73:HYPTAN, 74:HYPASN, 75:HYPACS, 76:HYPATN
0E21:	0805, 0807, 083C, 066D	;77:LN, 78:LOG, 79:EXP, 7A:SQR
0E29:	0A25, 1712, 0A15, 09D0	;7B:ABS, 7C:SGN, 7D:INT, 7E:FIX
0E31:	0A1F, 2BA8, 15C5, 1564	;7F:FRAC, 80:none, 81:DEGR, 82:DMS
0E39:	2BA8, 2BA8, 2BA8, 1849	;83:none, 84:none, 85:none, 86:PEEK
0E41:	2BA8, 2BA8, 2BA8, 188D	;87:none, 88:none, 89:none, 8A:EOF
0E49:	2BA8, 2BA8, 5253, 2BA8	;8B:none, 8C:none, 8D:FRE, 8E:none
0E51:	2BA8, 174A, 2BA8, 1B40	;8F:none, 90:ROUND, 91:none, 92:VALF
0E59:	1BB2, 1862, 1886, 17B8	;93:RAN#, 94:ASC, 95:LEN, 96:VAL
0E61:	2BA8, 2BA8, 2BA8, 2BA8	;97:none, 98:none, 99:none, 9A:none
0E69:	2BA8, 15EF, 2BA8, 2BA8	;9B:none, 9C:DEG, 9D:none, 9E:none
0E71:	2BA8, 2BA8, 2BA8, 2BA8	;9F:none, A0:none, A1:none, A2:none
0E79:	2BA8, 2BA8, 2BA8, 2BA8	;A3:none, A4:none, A5:none, A6:none
0E81:	1AED, 1AA9, 2BA8, 1A31	;A7:REC, A8:POL, A9:none, AA:NPR
0E89:	1A35, 2B70		;AB:NCR, AC:HYP

; table of the "prefix 6" function addresses, keyword codes &H97-&HAD
0E8D:	1638, 2BA8, 2BA8, 2BA8	;97:DMS$, 98:none, 99:none, 9A:none
0E95:	18B6, 17CC, 1817, 1814	;9B:INPUT$, 9C:MID$, 9D:RIGHT$, 9E:LEFT$
0E9D:	2BA8, 1854, 13A7, 2BA8	;9F:none, A0:CHR$, A1:STR$, A2:none
0EA5:	1722, 2BA8, 2BA8, 2BA8	;A3:HEX$, A4:none, A5:none, A6:none
0EAD:	2BA8, 191D, 2BA8, 2BA8	;A7:none, A8:INKEY$, A9:none, AA:none
0EB5:	2BA8, 2BA8, 146D	;AB:none, AC:none, AD:CALC$

; block transfer from the ROM to the RAM (source page 2, destination page 1)
0EBB:	gst	ua,$6
0EBD:	pst	ua,&H64
0EC0:	jp	&H014F

; *** Expression evaluate routines ***

; evaluate a numerical expression to an integer (byte) in $15,$16
0EC3:	cal	&H112F		;EXPRW, evaluate numerical expression
; BIN01:
; convert a floating point number in $10-$18 to an integer in $15,$16
; BS Error when result out of range 0<=x<=255
0EC6:	sbc	$18,$sy
0EC8:	jr	nc,&H0ED4
0ECA:	sbw	$15,$15
0ECD:	rtn

; BIN11:
; convert a floating point number in $10-$18 to an integer in $15,$16
; BS Error when result out of range 1<=x<=255
0ECE:	sbc	$16,$sx		;most significant byte of the mantissa
0ED0:	jr	z,&H0EDC	;BS Error if number=0
0ED2:	sbc	$18,$sy		;mantissa nad exponent must be positive ...
0ED4:	jr	nz,&H0EDC	;... otherwise BS Error
0ED6:	cal	&H0EF0		;BCD to binary conversion
0ED9:	sbc	$16,$sx		;test the upper byte of the result
0EDB:	rtn	z
0EDC:	jp	&H2BA4		;BS Error, subscript out of range

; evaluate a numerical expression to an integer in $15,$16
; negative values cause a BS Error
0EDF:	cal	&H112F		;EXPRW, evaluate numerical expression
; BIN02:
; convert a floating point number in $10-$18 to an integer in $15,$16
; BS Error when result out of range 0<=x<=65535
0EE2:	sbc	$18,$sy		;signs
0EE4:	jr	c,&H0ECA	;return zero when exponent negative
0EE6:	jr	&H0EEE

; BIN12:
; Converts a floating point number in the register block $10-$18 to an
; unsigned integer in $15,$16. The fraction part is truncated. Values out of
; range 1<=x<=65535 cause a BS Error.
0EE8:	sbc	$16,$sx
0EEA:	jr	z,&H0EDC	;BS Error if the input number is equal 0
0EEC:	sbc	$18,$sy
0EEE:	jr	nz,&H0EDC	;BS Error if mantissa or exponent negative
0EF0:	sbw	$10,$10		;clear the destination register pair
0EF3:	cal	&H0ADC		;BCD to binary conversion
0EF6:	ldw	$15,$10		;conversion result
0EF9:	rtn

0EFA:	cal	&H112F		;EXPRW, evaluate numerical expression
; BINM2:
; convert a floating point number in $10-$18 to an integer in $15,$16
; BS Error when result out of range -32768<=x<=65535
0EFD:	sbc	$18,&H05
0F00:	jr	c,&H0EE2	;positive
0F02:	jp	&H0AC5		;negative

; evaluate a string expression in parentheses
0F05:	cal	&H00E1		;test for '(', SN Error if not found
0F08:	cal	&H11D2		;evaluate a string expression
0F0B:	jr	&H0F13		;test for ')', SN Error if not found

; evaluate a numerical expression in parentheses
0F0D:	cal	&H00E1		;test for '(', SN Error if not found
0F10:	cal	&H112F		;EXPRW, evaluate numerical expression
0F13:	jp	&H00C7		;test for ')', SN Error if not found

; evaluate a binary operator
; returns the priority in $3 and the operation flag in $4
0F16:	cal	&H0049		;NEXTC, get next character other than space
0F19:	sbc	$0,&H07		;prefix?
0F1C:	jr	nz,&H0F43
0F1E:	ldi	$1,(iz+$sy)
0F20:	ldw	$3,&H0504
0F24:	sbc	$1,&HC7		;MOD
0F27:	rtn	z
0F28:	ldw	$3,&H090C
0F2C:	sbc	$1,&HC4		;AND
0F2F:	rtn	z
0F30:	ldw	$3,&H0A0D
0F34:	sb	$1,&HC5		;OR
0F37:	rtn	z
0F38:	ad	$4,$sy
0F3A:	sbc	$1,$sy		;XOR
0F3C:	rtn	z
0F3D:	ldd	$0,(iz-&H02)
0F40:	na	$3,$sx		;Not Zero, operator not found
0F42:	rtn
0F43:	pre	ix,&H0A80	;table of binary operators
0F47:	gst	ua,$1
0F49:	pst	ua,&HA4
0F4C:	ldim	$2,(ix+$sx),3
0F4F:	sbc	$2,$sz		;operator found?
0F51:	jr	z,&H0F5A	;branch if so
0F53:	adc	$2,$sy		;end of the table reached?
0F55:	jr	nc,&H0F4C	;next table entry if not
0F57:	pst	ua,$1,jr &H0F40	;operatot not found
0F5A:	pst	ua,$1
0F5C:	adc	$2,$sy
0F5E:	jr	c,&H0F40
0F60:	ldd	$1,(iz+$sy)
0F62:	sbc	$3,&H09		;relational operator?
0F65:	rtn	nz		;return if not
0F66:	cal	&H0049		;NEXTC, get next character other than space
0F69:	sb	$0,&H3C		;'<'
0F6C:	sbc	$0,&H03
0F6F:	rtn	nc		;return if not '<' or '=' or '>'
0F70:	ldd	$1,(iz+$sy)
0F72:	ad	$0,$4
0F75:	sbc	$0,&H04
0F78:	jr	z,&H0F83
0F7A:	anc	$0,$sy
0F7C:	jp	z,&H2B70	;SN Error, syntax
0F7F:	sb	$4,$sy
0F81:	jr	nz,&H0F86
0F83:	ad	$0,&H02
0F86:	ld	$4,$sz
0F88:	rtn

0F89:	pre	ix,&H1133	;"integer cheating" flag
0F8D:	sbc	(ix+$sx),$30	;cheating disabled if equals 1
0F8F:	rtn	z
; "integer cheating" of the floating point number $10-$18
; If the last three digits of the mantissa are in range 001-050 then they
; are replaced with 000. Similarly, if the last three mantissa digits are in
; range 950-999, then the number is rounded up until they are 000.
0F90:	ldw	$0,$10
0F93:	an	$1,&H0F
0F96:	jr	z,&H0FAB
0F98:	sbc	$1,&H09
0F9B:	rtn	nz
0F9C:	sbc	$0,&H50
0F9F:	rtn	c
; rounding up
0FA0:	ld	$10,$sx
0FA2:	an	$11,&HF0
0FA5:	adbm	$11,&H10,6
0FA8:	jp	&H061D		;normalise the floating point number $10-$18
; rounding down
0FAB:	sbc	$0,&H50
0FAE:	rtn	nc
0FAF:	ld	$10,$sx
0FB1:	rtn

0FB2:	sbc	$7,&H0D
0FB5:	rtn	nc
0FB6:	ld	$8,&H0C
0FB9:	sb	$8,$7
0FBC:	phs	$8
0FBE:	sb	$8,$sy
0FC0:	jr	c,&H0FC7
0FC2:	didm	$16,7
0FC5:	jr	&H0FBE
0FC7:	pps	$8
0FC9:	sbbm	$1,$1,6
0FCC:	adbm	$10,$sz,7
0FCF:	an	$10,&HF0
0FD2:	sb	$8,$sy
0FD4:	jr	c,&H0FA8
0FD6:	dium	$10,7
0FD9:	jr	&H0FD2
0FDB:	phs	$1
0FDD:	cal	&H5044		;FC Error if BASIC interpreter not in RUN mode
0FE0:	cal	&H05A1
0FE3:	adc	$18,$sy
0FE5:	jr	c,&H0FFE
0FE7:	cal	&H0A72
0FEA:	pps	$1
0FEC:	jr	c,&H100D
0FEE:	jr	nz,&H1009
0FF0:	anc	$1,$sy
0FF2:	jp	z,&H0636
0FF5:	ld	$18,&H06
0FF8:	sbbm	$10,$10,8
0FFB:	ld	$16,$sy
0FFD:	rtn
0FFE:	gst	ua,$10
1000:	pst	ua,&H54
1003:	cal	&H0A82		;MCP, string comparison
1006:	pst	ua,$10,jr &H0FEA
1009:	anc	$1,&H04,jr &H0FF2
100D:	anc	$1,&H02,jr &H0FF2

; operator -
1011:	cal	&H05B2		;sign change
; operator +
1014:	cal	&H05A1
1017:	cal	&H05DA		;floating point addition
101A:	jp	&H0F89		;"integer cheating" of the FP number $10-$18

; operator *
101D:	cal	&H05A1
1020:	cal	&H0607		;floating point multiplication
1023:	jr	&H101A

; operator /
1025:	cal	&H05A1
1028:	cal	&H0646		;FP division, $10-$18 <- $10-$18 / $0-$8
102B:	jr	&H101A

; operator ^
102D:	cal	&H05A1
1030:	cal	&H092E
1033:	jp	&H061D		;FP normalisation

1036:	cal	&H05D2		;subtract 1 from the FP number $10-$18
1039:	jr	&H101A
103B:	cal	&H05D8		;add 1 to the FP number $10-$18
103E:	jr	&H101A
1040:	cal	&H05D4		;FP subtraction, $10-$18 <- $10-$18 - $0-$8
1043:	jr	&H101A

; operator "Yen", signed integer division
1045:	cal	&H1069		;convert both operands to absolute integers
1048:	sbb	$29,$28
104B:	an	$29,&H0F
104E:	cal	&H16BD		;integer division: $10-$18 div $0-$8
1051:	cal	&H06B8		;swap two FP numbers -> quotient in $10-$18
1054:	adb	$18,$29
1057:	an	$18,&H0F
105A:	cal	&H061D		;FP normalisation
105D:	jr	&H101A		;"integer cheating" of the FP number $10-$18

; operator MOD
105F:	cal	&H1069		;convert both operands to absolute integers
1062:	byuw	$28
1064:	cal	&H16BD		;integer division: $10-$18 div $0-$8
1067:	jr	&H1054		;remainder in $10-$18

; convert a pair of FP numbers $0-$8 and $10-$18 to absolute integers
1069:	cal	&H05A1
106C:	cal	&H09D0		;function FIX
106F:	cal	&H0987		;absolute value of a FP number $10-$18
1072:	sbc	$17,&H11
1075:	jp	nc,&H2BA4	;BS Error, subscript out of range
1078:	phs	$29
107A:	cal	&H06B8		;swap two FP numbers $10-$18 <-> $0-$8
107D:	cal	&H09D0		;function FIX
1080:	cal	&H0987		;absolute value of a FP number $10-$18
1083:	pps	$28
1085:	jp	&H06B8		;swap two FP numbers $10-$18 <-> $0-$8

; SIKI:
; evaluate an expression pointed to by the IX register
; returns a floating point number in $10-$18 and Carry clr,
; or a string of length $17 at address $15,$16 and Carry set
1088:	pre	ix,&H1899
108C:	ldw	$2,(ix+$sx)
108E:	phsw	$3
1090:	ld	$3,&HF0
1093:	cal	&H11A7		;check the system stack pointer
1096:	phsw	$4
1098:	cal	&H05A7
109B:	jr	nz,&H10D3
109D:	cal	&H0772		;evaluate a chain of operators '+' and '-'
10A0:	sbc	$2,$sx		;$2 = &H00 if '+', or $2 = &H05 if '-'
10A2:	jr	nz,&H10BB	;branch if evaluated to '-'
10A4:	ld	$2,&HC3		;code of the operator NOT
10A7:	cal	&H00E9		;test for keyword prefix 7 and code $2
10AA:	jr	nz,&H10D3
10AC:	ppsw	$0
10AE:	sbc	$0,&H0A
10B1:	jr	z,&H1098
10B3:	phsw	$1
10B5:	ldw	$3,&H080A
10B9:	jr	&H1093
10BB:	pps	$0
10BD:	phs	$0
10BF:	sbc	$0,$sy
10C1:	jr	z,&H10C9
10C3:	ldw	$3,&H0702
10C7:	jr	&H1093
10C9:	ldd	$0,(iz+$sx)
10CB:	cal	&H1136
10CE:	cal	&H05B2		;sign change
10D1:	jr	&H10D6
10D3:	cal	&H1136
10D6:	cal	&H0F16		;evaluate a binary operator
10D9:	ppsw	$0
10DB:	sbc	$3,$sz
10DD:	jr	nc,&H10E6
10DF:	phsw	$1
10E1:	cal	&H0054		;push a FP number $10-$18 on the US
10E4:	jr	&H1093
10E6:	sbc	$0,&HF0
10E9:	jr	z,&H1124
10EB:	phsw	$4
10ED:	anc	$0,&H02
10F0:	jr	nz,&H1113
10F2:	ppu	$2
10F4:	phu	$2
10F6:	adc	$2,$sy
10F8:	jr	nc,&H1105
10FA:	adc	$18,$sy
10FC:	jr	nc,&H1133
10FE:	sbc	$0,&H09
1101:	jr	nz,&H1133
1103:	jr	&H110E
1105:	adc	$18,$sy
1107:	jr	c,&H1133
1109:	sbc	$0,&H09
110C:	jr	nz,&H1117
110E:	cal	&H0FDB
1111:	jr	&H1120
1113:	adc	$18,$sy
1115:	jr	c,&H1133
1117:	bydw	$1
1119:	ldw	$3,&H0DB9	;table of the arithmetic operator addresses
111D:	cal	&H1183		;indirect jump to address at ($3 + 2*$0)
1120:	ppsw	$3
1122:	jr	&H10D9
1124:	ppsw	$2
1126:	adc	$18,$sy
1128:	pre	ix,&H1899
112C:	stw	$2,(ix+$sx)
112E:	rtn

; EXPRW:
; evaluate numerical expression pointed to by the IX register
; returns a floating point number in $10-$18
112F:	cal	&H1088		;SIKI, evaluate an expression
1132:	rtn	nc		;return if expression evaluated to a number
1133:	jp	&H2BB0		;TM Error, mismatch of variable type

1136:	sbc	$0,&H41
1139:	jr	nc,&H1195
113B:	cal	&H07AC		;evaluate a decimal or hex numeral
113E:	rtn	c
113F:	ldd	$0,(iz+$sx)
1141:	sbc	$0,&H22
1144:	jr	z,&H11A1
1146:	sbc	$0,&H06
1149:	jr	z,&H11A1
114B:	sbc	$0,&H28
114E:	jp	z,&H0F0D	;evaluate a numerical expression in parentheses
1151:	sbc	$0,&H05
1154:	jp	nz,&H2B70	;SN Error, syntax
1157:	ldi	$0,(iz+$sy)
1159:	sbc	$0,&H63
115C:	jr	c,&H117C
115E:	sbc	$0,&H8E
1161:	jr	nc,&H117C
1163:	phs	$0
1165:	cal	&H11A7		;check the system stack pointer
1168:	cal	&H0772		;evaluate a chain of operators '+' and '-'
116B:	phs	$2		;$2 = &H00 if '+', or $2 = &H05 if '-'
116D:	cal	&H1136
1170:	pps	$2
1172:	cal	&H1295
1175:	adc	$18,$sy
1177:	jp	c,&H2BB0	;TM Error, mismatch of variable type
117A:	pps	$0
117C:	sb	$0,&H4F		;the prefix 5 function codes start from &H4F
117F:	ldw	$3,&H0DD1	;table of addresses
; indirect jump to address at ($3 + 2*$0)
1183:	biu	$0
1185:	ld	$1,$sx
1187:	adw	$3,$sz
1189:	gst	ua,$1
118B:	pst	ua,&H04
118E:	ldw	$3,($3)
1191:	pst	ua,$1
1193:	jp	$3
1195:	gre	iz,$1
1197:	cal	&H2F5D		;parse for a variable name and type
119A:	sbc	$13,$sx
119C:	jp	nlz,&H3045
119F:	pre	iz,$1
11A1:	cal	&H11D2		;evaluate a string expression
11A4:	na	$18,$sx
11A6:	rtn

; check the system stack pointer
11A7:	gre	ss,$0
11A9:	ldw	$5,&H1B37
11AD:	sbcw	$5,$sz
11AF:	jr	nc,&H11BF
11B1:	rtn

; check the user stack space - can the user stack hold the number of bytes
; specified in the $19,$20 register pair?
11B2:	ldw	$21,&H1BDE
11B6:	adw	$21,$19
11B9:	gre	us,$19
11BB:	sbcw	$21,$19
11BE:	rtn	c
11BF:	jp	&H2B78		;TC Error, formula too complex

; test if there's at least $0,$1 bytes of free memory
; returns in $2,$3 address of the free memory area
11C2:	pre	ix,&H1899
11C6:	ldm	$2,(ix+$sx),4
11C9:	sbw	$4,$2		;$4 <- free memory area size
11CC:	sbw	$4,$sz
11CE:	rtn	nc
11CF:	jp	&H2B6D		;OM Error, insufficient memory

; evaluate a string expression (only concatenation supported)
11D2:	cal	&H11F1		;evaluate a string variable or literal
11D5:	cal	&H0049		;NEXTC, get next character other than space
11D8:	sbc	$0,&H2B		;'+'
11DB:	rtn	nz
11DC:	ldd	$0,(iz+$sy)
11DE:	phsm	$17,3
11E1:	cal	&H11F1		;evaluate a string variable or literal
11E4:	ld	$0,$17
11E7:	ppsm	$15,3
11EA:	ad	$17,$sz
11EC:	jr	nc,&H11D5
11EE:	jp	&H2B74		;ST Error, string too long

; evaluate a string variable or literal
11F1:	cal	&H11A7		;check the system stack pointer
11F4:	cal	&H00BF		;test for a quotation mark
11F7:	jr	z,&H123A
11F9:	pre	ix,&H1899
11FD:	ldw	$1,(ix+$sx)
11FF:	phsw	$2
1201:	sbc	$0,&H41
1204:	jr	nc,&H1235
1206:	cal	&H07AC		;evaluate a decimal or hex numeral
1209:	jp	c,&H2BB0	;TM Error, mismatch of variable type
120C:	ldiw	$0,(iz+$sx)
120E:	sb	$0,&H05
1211:	jp	z,&H2BB0	;TM Error, mismatch of variable type
1214:	sbc	$0,$sy
1216:	jp	nz,&H2B70	;SN Error, syntax
1219:	phs	$1
121B:	anc	$1,&H08
121E:	cal	z,&H0F0D	;evaluate a numerical expression in parentheses
1221:	pps	$0
1223:	sb	$0,&H97		;the prefix 6 function codes start from &H97
1226:	ldw	$3,&H0E8D	;table of addresses
122A:	cal	&H1183		;indirect jump to address at ($3 + 2*$0)
122D:	ppsw	$2
122F:	cal	&H1128
1232:	ld	$19,$sx,jr &H123F
1235:	cal	&H303D
1238:	jr	&H122D
123A:	cal	&H0B05
123D:	ld	$19,$sy
123F:	ld	$18,$sx
1241:	ldw	$0,$17
1244:	cal	&H11C2		;test if there's enough free memory space
1247:	ldw	$0,$2
124A:	adw	$2,$17
124D:	cal	&H1128
1250:	ldm	$2,$15,4
1253:	ldw	$15,$sz
1255:	sbc	$19,$sy
1257:	jp	z,&H014C	;WTF???
125A:	jp	&H014C		;block transfer within the RAM

; append zero to the string on the character operation stack
125D:	ldw	$0,$sy		;required amount of memory = 1 byte
125F:	cal	&H11C2		;test if there's enough free memory space
1262:	adw	(ix+$sx),$30	;increment (SBOT)
1264:	st	$31,($2)	;store zero
1267:	rtn

1268:	cal	&H00BF		;test for a quotation mark
126B:	jp	z,&H0B05
126E:	gre	iz,$15
1270:	ld	$17,$sx
1272:	ldd	$0,(iz+$sx)
1274:	sbc	$0,$sx
1276:	rtn	z
1277:	sbc	$0,&H2C
127A:	rtn	z
127B:	sbc	$0,&H20
127E:	jp	c,&H2B70	;SN Error, syntax
1281:	ldd	$0,(iz+$sy)
1283:	ad	$17,$sy
1285:	jp	c,&H2B74	;ST Error, string too long
1288:	jr	&H1274
128A:	cal	&H0772
128D:	phs	$2
128F:	cal	&H07AC
1292:	pps	$2
1294:	rtn	nc
1295:	sbc	$2,$sx
1297:	cal	nz,&H05B2
129A:	sbc	$31,$sy
129C:	rtn
129D:	gst	ua,$0
129F:	phsw	$1
12A1:	sbc	$1,$sx
12A3:	jr	nz,&H12A8
12A5:	pst	ua,&H54
12A8:	pre	ix,&H167F
12AC:	sbc	(ix+$sx),$31
12AE:	jr	lz,&H12E0
12B0:	cal	&H0049
12B3:	sbc	$0,$sx
12B5:	jr	z,&H12DB
12B7:	sbc	$0,&H2C
12BA:	jr	z,&H12DB
12BC:	cal	&H128A
12BF:	jp	nc,&H2BB0
12C2:	cal	&H003C		;ENDSC, test for an end of a BASIC line
12C5:	jr	c,&H12CC
12C7:	cal	&H00DB
12CA:	ldd	$0,(iz-$sy)
12CC:	ppsw	$0
12CE:	pst	ua,$0
12D0:	sbc	$1,$sx
12D2:	jp	z,&H31AD
12D5:	cal	&H31B3
12D8:	jp	&H014C		;block transfer within the RAM
12DB:	cal	&H0636
12DE:	jr	&H12C2
12E0:	cal	&H1268
12E3:	jr	&H12C2
12E5:	an	$16,&H0F
12E8:	ad	$16,&H30
12EB:	sti	$16,(ix+$sx)
12ED:	dium	$10,7
12F0:	rtn
12F1:	ld	$21,&H45
12F4:	sti	$21,(ix+$sx)
12F6:	ld	$19,$18
12F9:	sbcw	$17,$sy
12FB:	jr	c,&H12FF
12FD:	sb	$19,$sy
12FF:	cal	&H0B19
1302:	sbc	$18,$sx
1304:	jr	nz,&H130E
1306:	ld	$19,$sx
1308:	sbb	$19,$17
130B:	ld	$17,$19
130E:	ld	$18,$17
1311:	did	$17
1313:	ad	$17,&H30
1316:	an	$18,&H0F
1319:	ad	$18,&H30
131C:	stiw	$17,(ix+$sx)
131E:	rtn

131F:	pre	ix,&H16C3
1323:	ldd	$0,(ix+$sx)
1325:	ld	$1,$sx
1327:	diuw	$0
1329:	did	$0
132B:	sbc	$1,$sy
132D:	jp	c,&H13A7
1330:	pre	ix,&H165E
1334:	ld	$19,$18
1337:	ld	$22,$sx
1339:	jr	z,&H135F
133B:	cal	&H0A25		;absolute value of a FP number $10-$18
133E:	sbc	$0,$sx
1340:	jr	nz,&H1345
1342:	ld	$0,&H0A
1345:	ld	$20,$sz
1347:	sbc	$0,&H0A
134A:	jr	nc,&H1354
134C:	didm	$16,6
134F:	adbw	$17,$sy
1351:	ad	$0,$sy,jr &H1347
1354:	cal	&H09C9		;rounding the mantissa to 12 digits
1357:	cal	&H0B12
135A:	phs	$17
135C:	jp	&H1441

135F:	cal	&H0A25		;absolute value of a FP number $10-$18
1362:	ldw	$2,&H0110
1366:	sbcw	$17,$2
1369:	jr	nc,&H13B3
136B:	phsw	$29
136D:	ldw	$28,&H0099
1371:	ld	$1,$sx
1373:	sbbw	$28,$sz
1375:	cal	&H091B
1378:	ppsw	$28
137A:	sbc	$18,$sx
137C:	jr	z,&H138E
137E:	ld	$20,$17
1381:	ad	$20,$sy
1383:	ad	$20,$sz
1385:	sbc	$20,&H0A
1388:	jr	c,&H13D5
138A:	ld	$20,&H0A,jr &H13D5
138E:	sbc	$16,$sx
1390:	ld	$20,$sx
1392:	jr	z,&H139C
1394:	sbb	$20,$17
1397:	sbb	$20,$sy
1399:	sb	$0,$20
139C:	ld	$20,$sz,jr &H13D5
139F:	pre	ix,&H165E
13A3:	ld	$22,&H80,jr &H13B0

; function STR$, prefix 6, code &HA1
13A7:	pre	ix,&H165E	;WORK1
13AB:	ld	$22,$sx
13AD:	ld	$19,$18
13B0:	cal	&H0A25		;absolute value of a FP number $10-$18
13B3:	cal	&H09C9		;rounding the mantissa to 12 digits
13B6:	sbc	$16,$sx
13B8:	jr	z,&H13CB
13BA:	ld	$20,&H0A
13BD:	ldm	$0,$11,6
13C0:	an	$0,&HF0
13C3:	jr	nz,&H13D5
13C5:	didm	$5,6
13C8:	sb	$20,$sy,jr &H13C0
13CB:	ld	$20,$sx
13CD:	sbc	$22,$sx
13CF:	jr	z,&H13D5
13D1:	ld	$23,$sx
13D3:	ld	$18,$sy
13D5:	cal	&H0B12
13D8:	sbc	$22,$sx
13DA:	jr	z,&H13FA
13DC:	sbbw	$17,$23
13DF:	phs	$17
13E1:	ld	$17,$23
13E4:	anc	$23,&HF0
13E7:	jr	z,&H1408
13E9:	sbb	$22,$17
13EC:	sb	$22,$sy
13EE:	an	$17,&H0F
13F1:	sbc	$17,$20
13F4:	jr	nc,&H1466
13F6:	ld	$20,$17,jr &H1466
13FA:	phs	$17
13FC:	adc	$18,$sx
13FE:	jr	z,&H144A
1400:	cal	&H0AFA		;NISIN, BCD to binary conversion
1403:	sbc	$17,&H0A
1406:	jr	nc,&H1441
1408:	cal	&H12E5
140B:	sb	$20,$sy
140D:	sb	$17,$sy
140F:	jr	nc,&H1408
1411:	anc	$20,&H80
1414:	jr	nz,&H1431
1416:	sbc	$20,$sx
1418:	jr	z,&H1431
141A:	ld	$21,&H2E
141D:	sti	$21,(ix+$sx)
141F:	anc	$22,&H7F
1422:	jr	z,&H142A
1424:	ld	$21,&H30
1427:	sb	$22,$sy,jr &H141D
142A:	cal	&H12E5
142D:	sb	$20,$sy
142F:	jr	nz,&H142A
1431:	pps	$17
1433:	biu	$22
1435:	cal	c,&H12F1
1438:	cal	&H1745
143B:	gre	ix,$17
143D:	sbw	$17,$15
1440:	rtn
1441:	sb	$20,$sy
1443:	cal	&H12E5
1446:	ld	$22,&H80,jr &H1416
144A:	ld	$19,$sx
144C:	sbb	$19,$17
144F:	ld	$17,$19
1452:	cal	&H0AFA		;NISIN, BCD to binary conversion
1455:	sbc	$17,$sx
1457:	jr	z,&H1466
1459:	sb	$17,$sy
145B:	ld	$22,$17
145E:	ad	$17,$20
1461:	sbc	$17,&H0B
1464:	jr	nc,&H1441
1466:	ld	$21,&H30
1469:	sti	$21,(ix+$sx)
146B:	jr	&H1416

; function CALC$, prefix 6, code &HAD
146D:	pre	ix,&H18D3
1471:	ldi	$0,(ix+$sx)
1473:	sbc	$0,$sx
1475:	jr	nz,&H1471
1477:	ldd	$0,(ix-$sy)
1479:	ldw	$15,&H18D3
147D:	jr	&H143B

; function HYPSIN, prefix 5, code &H71
147F:	ld	$9,&H05,jr &H1494
; function HYPCOS, prefix 5, code &H72
1483:	ld	$9,&H03,jr &H1494
; function HYPTAN, prefix 5, code &H73
1487:	ld	$9,$sy,jr &H1494
; function HYPASN, prefix 5, code &H74
148A:	ld	$9,&H04,jr &H1494
; function HYPACS, prefix 5, code &H75
148E:	ld	$9,&H02,jr &H1494
; function HYPATN, prefix 5, code &H76
1492:	ld	$9,$sx
1494:	cal	&H0054
1497:	cal	&H0987
149A:	phs	$29
149C:	anc	$9,&H02
149F:	jr	nz,&H14D8
14A1:	cal	&H09AA
14A4:	ld	$7,&H97
14A7:	cal	&H06A6
14AA:	jr	nc,&H14D8
14AC:	ld	$28,$9
14AF:	cal	&H0603
14B2:	cal	&H0669
14B5:	anc	$28,&H04
14B8:	jr	nz,&H14BE
14BA:	ld	$6,&H03,jr &H14C3
14BE:	ld	$6,&H06
14C1:	ad	$28,$sy
14C3:	anc	$28,$sy
14C5:	jr	z,&H14CA
14C7:	ld	$8,&H06
14CA:	cal	&H0646
14CD:	cal	&H05D8
14D0:	cal	&H006C
14D3:	pps	$9
14D5:	jp	&H0607
14D8:	anc	$9,$sy
14DA:	jr	z,&H150E
14DC:	ld	$28,$9
14DF:	phs	$9
14E1:	cal	&H083D
14E4:	cal	&H0642
14E7:	pps	$9
14E9:	sbc	$9,&H03
14EC:	jr	c,&H1503
14EE:	jr	nz,&H14F9
14F0:	cal	&H05DA
14F3:	pps	$9
14F5:	phs	$31
14F7:	jr	&H14FC
14F9:	cal	&H05CE
14FC:	cal	&H0669
14FF:	ld	$6,&H02,jr &H1506
1503:	cal	&H0964
1506:	cal	&H0646
1509:	cal	&H006C
150C:	jr	&H1546
150E:	cal	&H0669
1511:	sbc	$9,&H02
1514:	jr	c,&H1537
1516:	jr	z,&H1526
1518:	cal	&H0990
151B:	cal	&H006C
151E:	cal	&H06B8
1521:	cal	&H0987
1524:	jr	&H1532
1526:	cal	&H06A6
1529:	jp	c,&H2B9C	;MA Error, mathematical error
152C:	cal	&H097D
152F:	cal	&H006C
1532:	cal	&H05DA
1535:	jr	&H1543
1537:	cal	&H0964
153A:	cal	&H0644
153D:	cal	&H066D
1540:	cal	&H006C
1543:	cal	&H0805
1546:	jp	&H095C
1549:	ldw	$0,&H0002
154D:	sbbw	$17,$sz
154F:	cal	c,&H0636
1552:	cal	&H061D		;FP normalisation
1555:	jp	&H006C
1558:	phsm	$22,4
155B:	cal	&H0054
155E:	ppsm	$19,4
1561:	jp	&H0A21

; function DMS, prefix 5, code &H82
1564:	cal	&H0987
1567:	cal	&H09D0
156A:	cal	&H1558
156D:	cal	&H1625
1570:	cal	&H0607
1573:	cal	&H09D0
1576:	cal	&H1558
1579:	cal	&H1625
157C:	cal	&H0607
157F:	cal	&H1549
1582:	cal	&H05DA
1585:	cal	&H1549
1588:	cal	&H05DA
158B:	cal	&H09C9		;rounding the mantissa to 12 digits
158E:	cal	&H0054
1591:	cal	&H09D0
1594:	cal	&H0A21
1597:	sbbm	$0,$sz,8
159A:	ld	$8,$sx
159C:	sbcw	$17,$sy
159E:	jr	c,&H15BD
15A0:	didm	$16,7
15A3:	adb	$17,$sy
15A5:	jr	nc,&H15A0
15A7:	sbc	$14,&H60
15AA:	jr	c,&H15B2
15AC:	adb	$15,$sy
15AE:	ldw	$6,&H9704
15B2:	sbc	$15,&H60
15B5:	jr	c,&H15BD
15B7:	bydw	$6
15B9:	ldw	$6,&H9904
15BD:	cal	&H005C
15C0:	cal	&H05DA
15C3:	jr	&H15E9

; function DEGR, prefix 5, code &H81
15C5:	cal	&H0987
15C8:	cal	&H09D0
15CB:	cal	&H1558
15CE:	sbc	$16,$sx
15D0:	jr	z,&H15D6
15D2:	adbw	$17,$sy
15D4:	adbw	$17,$sy
15D6:	cal	&H09D0
15D9:	cal	&H1558
15DC:	adbw	$17,$sy
15DE:	adbw	$17,$sy
15E0:	cal	&H061D		;FP normalisation
15E3:	ld	$28,&H70
15E6:	cal	&H160F
15E9:	adb	$18,$29
15EC:	jp	&H061D		;FP normalisation

; function DEG, prefix 5, code &H9C
15EF:	cal	&H00E1
15F2:	ld	$28,$sx
15F4:	phs	$28
15F6:	cal	&H112F
15F9:	pps	$28
15FB:	cal	&H00C7
15FE:	jr	z,&H161B
1600:	ad	$28,&H70
1603:	jr	c,&H1621
1605:	cal	&H00C3
1608:	jr	nz,&H1621
160A:	cal	&H0054
160D:	jr	&H15F4
160F:	cal	&H1625
1612:	cal	&H0646
1615:	cal	&H006C
1618:	cal	&H05DA
161B:	sb	$28,&H70
161E:	jr	nc,&H160F
1620:	rtn
1621:	sb	$28,&H70,jr &H161B
1625:	cal	&H0669
1628:	ldw	$6,&H0106
162C:	rtn
162D:	cal	&H0669
1630:	ldw	$6,&H0303
1634:	ld	$5,&H60
1637:	rtn

; function DMS$, prefix 6, code &H97
1638:	ld	$2,&H2D		;sign '-'
163B:	ldw	$0,&H0605
163F:	sbc	$18,&H05	;test the sign of the arguments
1642:	jr	nc,&H1648	;skip if negative
1644:	ldw	$1,&H2001
1648:	sbcw	$17,$sz
164A:	jp	nc,&H13A7	;function STR$ if number >= 1E6
164D:	pre	ix,&H165E	;WORK1, work buffer
1651:	cal	&H0987		;absolute value of a FP number $10-$18
1654:	sti	$2,(ix+$sx)	;write the sign to the buffer, '-' or space
1656:	cal	&H162D		;$0-$8 <- floating point 3600
1659:	cal	&H0607		;floating point multiplication
165C:	ldw	$28,&H0097	;rounding to 2 places after the decimal point
1660:	cal	&H091B		;floating point rounding
1663:	cal	&H162D		;$0-$8 <- floating point 3600
1666:	cal	&H16C4		;number of degrees
1669:	ld	$27,&HDF	;degree sign
166C:	cal	&H9238		;English or Japanese version?
166F:	jr	nz,&H1674	;skip if Japanese
1671:	ld	$27,&HF8	;degree sign
1674:	sti	$27,(ix+$sx)	;write the sign to the buffer
; minutes
1676:	cal	&H1625		;$0-$8 <- floating point 60
1679:	cal	&H16C4		;number of minutes
; seconds
167C:	gre	ix,$6
167E:	cal	&H13AB		;function STR$
1681:	cal	&H1438		;$17 <- length of the string in the WORK1 buffer
1684:	ld	$0,&H27		;apostrophe, minutes sign
1687:	st	$0,($6)		;write the minutes sign to the buffer
168A:	rtn

; integer division of two FP numbers: $10-$18 div $0-$8,
; integer quotient discarded, FP remainder in $10-$18
168B:	sbw	$19,$19		;$19=number of digits, $20=quotient digit
168E:	cal	&H06A6		;compare the absolute values of two FP numbers
1691:	jr	c,&H16B6	;branch if |$10-$18| < |$0-$8|
; calculate the number of quotient digits in $19
1693:	ld	$19,$17		;dividend exponent
1696:	sbb	$19,$7		;divisor exponent
1699:	sbbcm	$10,$sz,7
169C:	jr	nc,&H16A4	;skip if dividend >= divisor
169E:	dium	$10,7		;shift the dividend one digit left
16A1:	sbbw	$17,$sy,jr &H16B6	;decrement the dividend exponent
; main division loop
16A4:	ld	$20,$sx		;clear the quotient digit
; repeated subtraction of divisor $0-$6 from dividend $10-$16,
; the digit of quotient $20 is incremented at every subtraction
16A6:	sbbm	$10,$sz,7	;subtract the divisor from the dividend
16A9:	jr	c,&H16AE
16AB:	adb	$20,$sy,jr &H16A6 ;increment the quotient and back to the loop
; take back the subtraction
16AE:	adbm	$10,$sz,7	;add the divisor to the dividend
16B1:	dium	$10,7		;shift the dividend one digit left
16B4:	sbbw	$17,$sy		;decrement the dividend exponent
16B6:	sbb	$19,$sy		;decrement the counter of digits
16B8:	jr	nc,&H16A4	;next digit
16BA:	jp	&H061D		;normalise the floating point number $10-$18

16BD:	pre	ix,&H165E	;WORK1
; integer division of two FP numbers: $10-$18 div $0-$8,
; FP quotient in $10-$18, FP remainder in $0-$8,
; integer quotient converted to ASCII stored at the location pointed to by IX
16C1:	cal	&H0665		;MA Error if $6 = 0
16C4:	sbbm	$19,$19,7	;clear the quotient
16C7:	ld	$26,&H11
16CA:	ld	$28,$sy
16CC:	cal	&H06A6		;compare the absolute values of two FP numbers
16CF:	jr	c,&H16F5	;branch if |$10-$18| < |$0-$8|
; calculate the number of quotient digits in $27
16D1:	ld	$27,$17		;dividend exponent
16D4:	sbb	$27,$7		;divisor exponent
16D7:	sbbcm	$10,$sz,7
16DA:	jr	nc,&H16E2	;skip if dividend >= divisor
16DC:	dium	$10,7		;shift the dividend one digit left
16DF:	sbbw	$17,$sy,jr &H16FC	;decrement the dividend exponent
; main division loop
16E2:	dium	$19,7		;shift the quotient one digit left
; repeated subtraction of divisor $0-$6 from dividend $10-$16,
; the digit of quotient $19 is incremented at every subtraction
16E5:	sbbm	$10,$sz,7	;subtract the divisor from the dividend
16E8:	jr	c,&H16ED
16EA:	adb	$19,$sy,jr &H16E5 ;increment the quotient and back to the loop
; take back the subtraction
16ED:	adbm	$10,$sz,7	;add the divisor to the dividend
16F0:	dium	$10,7		;shift the dividend one digit left
16F3:	sbbw	$17,$sy		;decrement the dividend exponent
16F5:	or	$19,&H30	;convert the quotient digit to ASCII...
16F8:	sti	$19,(ix+$sx)	;...and store it
16FA:	diu	$19		;quotient digit
16FC:	sbb	$27,$sy		;decrement the counter of digits
16FE:	jr	nc,&H16E2	;next digit
; division completed
1700:	cal	&H06B8		;save remainder $10-$18 to $0-$8
1703:	ldm	$10,$19,8
1706:	ld	$18,$28
1709:	cal	&H061D		;normalisation of the quotient
170C:	cal	&H06B8		;swap two FP numbers $10-$18 <-> $0-$8
170F:	jp	&H061D		;normalisation of the remainder

; function SGN, prefix 5, code &H7C
1712:	sbc	$16,$sx
1714:	rtn	z
1715:	cal	&H0FF8
1718:	sbc	$18,&H05
171B:	ld	$18,$sy
171D:	rtn	c
171E:	ld	$18,&H06
1721:	rtn

; function HEX$, prefix 6, code &HA3
1722:	cal	&H0EFD
1725:	ld	$18,&H04
1728:	pre	ix,&H165E
172C:	ld	$17,$sx
172E:	dium	$15,3
1731:	ad	$17,&H30
1734:	sbc	$17,&H3A
1737:	jr	c,&H173C
1739:	ad	$17,&H07
173C:	sti	$17,(ix+$sx)
173E:	sb	$18,$sy
1740:	jr	nz,&H172C
1742:	ld	$17,&H04
1745:	ldw	$15,&H165E
1749:	rtn

; function ROUND, prefix 5, code &H90
174A:	cal	&H00E1
174D:	cal	&H112F
1750:	cal	&H0054
1753:	cal	&H00DB
1756:	cal	&H0EFA		;evaluate num. expression to integer (word)
1759:	cal	&H00C7
175C:	phs	$15
175E:	sbc	$16,$sx
1760:	jr	z,&H1769
1762:	ad	$16,$sy
1764:	jp	nz,&H2BA4	;BS Error, subscript out of range
1767:	cmp	$15
1769:	sbc	$15,&H64
176C:	jp	nc,&H2BA4	;BS Error, subscript out of range
176F:	cal	&H005C
1772:	pps	$7
1774:	phsw	$18
1776:	cal	&H0AFA		;NISIN, BCD to binary conversion
1779:	sbc	$18,$sy
177B:	jr	z,&H17A9
177D:	sbc	$18,&H06
1780:	jr	z,&H17A9
1782:	ld	$19,$17
1785:	ld	$17,&H64
1788:	sb	$17,$19
178B:	cmp	$17
178D:	sb	$17,$7
1790:	biu	$7
1792:	jr	nc,&H17A4
1794:	anc	$17,&H80
1797:	jr	nz,&H17A4
1799:	ld	$7,$17
179C:	ppsw	$17
179E:	ld	$0,&H05
17A1:	jp	&H0FB2
17A4:	ppsw	$17
17A6:	jp	&H0636
17A9:	sb	$17,$7
17AC:	biu	$7
17AE:	jr	nc,&H1794
17B0:	anc	$17,&H80
17B3:	jr	z,&H1794
17B5:	ppsw	$17
17B7:	rtn

; function VAL, prefix 5, code &H96
17B8:	cal	&H0F05
17BB:	cal	&H125D		;append zero
17BE:	gre	iz,$0
17C0:	phsw	$1
17C2:	pre	iz,$15
17C4:	cal	&H128A
17C7:	ppsw	$0
17C9:	pre	iz,$0
17CB:	rtn

; function MID$, prefix 6, code &H9C
17CC:	cal	&H00E1
17CF:	cal	&H11D2		;evaluate a string expression
17D2:	phsw	$16
17D4:	phs	$17
17D6:	cal	&H00DB
17D9:	cal	&H112F
17DC:	cal	&H0ECE
17DF:	cal	&H00C3
17E2:	jr	nz,&H1809
17E4:	phs	$15
17E6:	cal	&H0EC3		;evaluate num. expression to integer (byte)
17E9:	byuw	$15
17EB:	pps	$15
17ED:	cal	&H00C7
17F0:	pps	$17
17F2:	sb	$17,$15
17F5:	jr	c,&H180F
17F7:	ad	$17,$sy
17F9:	sbc	$17,$16
17FC:	jr	c,&H1800
17FE:	byuw	$16
1800:	sb	$15,$sy
1802:	ld	$16,$sx
1804:	ppsw	$0
1806:	adw	$15,$sz
1808:	rtn
1809:	pps	$16
180B:	phs	$16
180D:	jr	&H17ED
180F:	ld	$17,$sx
1811:	ppsw	$15
1813:	rtn

; function LEFT$, prefix 6, code &H9E
1814:	ld	$0,$sy,jr &H1819
; function RIGHT$, prefix 6, code &H9D
1817:	ld	$0,$sx
1819:	phs	$0
181B:	cal	&H00E1
181E:	cal	&H11D2		;evaluate a string expression
1821:	phsm	$17,3
1824:	cal	&H00DB
1827:	cal	&H0EC3		;evaluate num. expression to integer (byte)
182A:	cal	&H00C7
182D:	ld	$13,$15
1830:	ppsm	$15,3
1833:	pps	$0
1835:	sbc	$17,$13
1838:	rtn	c
1839:	sbc	$0,$sy
183B:	jr	z,&H1845
183D:	sb	$17,$13
1840:	ld	$18,$sx
1842:	adw	$15,$17
1845:	ld	$17,$13
1848:	rtn

; function PEEK, prefix 5, code &H86
1849:	cal	&H0EFD
184C:	cal	&H19A0		;UA,IX <- effective address
184F:	ldd	$15,(ix+$sx)
1851:	pst	ua,$2,jr &H1873

; function CHR$, prefix 6, code &HA0
1854:	cal	&H0EC6
1857:	pre	ix,&H165E
185B:	std	$15,(ix+$sx)
185D:	ld	$17,$sy
185F:	jp	&H1745

; function ASC, prefix 5, code &H94
1862:	cal	&H0F05
1865:	sbc	$17,$sx
1867:	jp	z,&H0636
186A:	pre	ix,$15,jr &H1871

; function ERR, prefix 5, code &H50
186D:	pre	ix,&H16E7
1871:	ldd	$15,(ix+$sx)
1873:	ld	$16,$sx
1875:	jp	&H0A97		;CNVR, integer to floating point conversion

; function ERL, prefix 5, code &H4F
1878:	pre	ix,&H16E3
187C:	ldw	$3,(ix+$sx)
187E:	ld	$2,$sx
1880:	sbbm	$10,$10,7
1883:	jp	&H0AA1

; function LEN, prefix 5, code &H95
1886:	cal	&H0F05
1889:	ld	$15,$17,jr &H1873

; function EOF, prefix 5, code &H8A
188D:	cal	&H0ECE
1890:	cal	&H4FD3
1893:	cal	&H4E36
1896:	sbcw	(ix+$sx),$30
1898:	jp	c,&H2BD7	;OP Error, OPEN
189B:	ld	$0,(ix+&H04)
189E:	sbc	$0,&H02
18A1:	jr	nz,&H18AD
18A3:	pre	ix,&H1559
18A7:	adc	(ix+$sx),$31
18A9:	jr	nz,&H18AD
18AB:	sb	$4,$sy
18AD:	ld	$15,$4
18B0:	ld	$16,$4
18B3:	jp	&H0A97		;CNVR, integer to floating point conversion

; function INPUT$, prefix 6, code &H9B
; returns the string address in $15,$16 and the string length in $17
18B6:	cal	&H00D9		;test for '$', SN Error if not found
18B9:	cal	&H00E1		;test for '(', SN Error if not found
18BC:	cal	&H0EC3		;evaluate num. expression to integer (byte)
18BF:	phuw	$16		;specified number of characters
18C1:	cal	&H00C3		;test for a comma
18C4:	ld	$21,$sx		;$21 <- 0 if there was only a single argument
18C6:	jr	nz,&H18D0	;skip if there was only a single argument
18C8:	cal	&H00CD		;test for '#'
18CB:	cal	&H3EB1
18CE:	na	$21,$sx		;$21 <- &HFF if there was a second argument
18D0:	cal	&H00C7		;test for ')', SN Error if not found
18D3:	gre	iz,$1
18D5:	phsw	$2		;store IZ on the system stack
18D7:	cal	&H031B		;cursor display enable
18DA:	ppuw	$0		;specified number of characters
18DC:	cal	&H11C2		;test if there's enough free memory space
18DF:	phs	$0		;specified number of characters
18E1:	phsw	$3		;$2,$3 = address of the free memory area
18E3:	ldw	$22,$2		;$22,$23 <- pointer to the string
18E6:	ld	$20,$sz		;$20 <- character counter
; character loop
18E8:	sb	$20,$sy		;decrement the character counter
18EA:	jr	c,&H1915	;end of typing
18EC:	sbc	$21,$sx		;keyboard or file?
18EE:	jr	z,&H1901	;branch if keyboard
; input characters from a file
18F0:	phsm	$23,4
18F3:	cal	&H4C0E		;read a byte from the I/O data buffer
18F6:	ppsm	$20,4
18F9:	st	$0,($22)	;store the read character
18FC:	adw	$22,$sy,jr &H18E8 ;increment the pointer and back to the loop
18FF:	jr	c,&H18F9
; input characters from the keyboard
1901:	cal	&H023D
1904:	cal	&H03A4
1907:	phs	$0
1909:	cal	&H0241
190C:	pps	$0
190E:	cal	&H198F
1911:	jr	c,&H1901
1913:	jr	&H18F9
; end of typing
1915:	ppsm	$15,3		;$15,$16 <- string address, $17 <- length
1918:	ppsw	$1
191A:	pre	iz,$1		;restore IZ from the system stack
191C:	rtn

; function INKEY$, prefix 6, code &HA8
; returns the string length in $17 (1 or 0 when key pressed/not_pressed)
; returns the string address in $15,$16
191D:	ldw	$15,&H165E	;WORK1, work buffer
1921:	ld	$0,&H4B		;initial KO column
1924:	ldw	$17,&H1000	;$18=16 (debounce counter), $17=0 (length)
1928:	cal	&H038C		;ensure that KI=0 when no KO column selected
192B:	cal	&H0381		;select KO column $0, read KI to $1,$2
192E:	orc	$1,$2
1931:	jr	z,&H198A	;branch if no pressed key detected
; a pressed key was detected, repeat the test 16 times
1933:	sb	$18,$sy		;decrement the debounce counter
1935:	jr	nz,&H1928	;check again
; stable KI state was validated
1937:	phs	$0
1939:	pre	ix,&H1115
193D:	stm	$0,(ix+$sy),3
1940:	cal	&H0458
1943:	pps	$0
1945:	sbc	$0,&H41
1948:	jp	z,&H29E3	;branch if the BRK key was pressed
194B:	byum	$0,4		;$0=0, $1=KO, $2,$3=KI
194E:	ad	$0,$sy
1950:	biu	$3
1952:	rou	$2
1954:	jr	nc,&H194E
; $0 contains the bit number of the KI port for the pressed key
1956:	sbcw	$2,$sy
1958:	rtn	nc
1959:	an	$1,&H0F
195C:	ldw	$2,&H0206
1960:	sbcw	$2,$sz
1962:	rtn	z
1963:	sbc	$0,$sy
1965:	jr	nz,&H196B
1967:	sbc	$1,&H08
196A:	rtn	z
196B:	ldw	$3,&H1113
196F:	ld	$2,($3)
1972:	gst	ua,$14
1974:	gre	iz,$12
1976:	pst	ua,&HA4
1979:	cal	&H25B2
197C:	pre	iz,$12
197E:	pst	ua,$14
1980:	cal	&H198F
1983:	rtn	c
1984:	ld	$17,$sy		;string length = 1
1986:	st	$0,($15)	;store the character code to the WORK1 buffer
1989:	rtn
;
; no pressed key was detected for the selected KO column $0, check next one
198A:	sb	$0,$sy
198C:	jr	nlz,&H1924
198E:	rtn

198F:	adc	$0,&H80
1992:	rtn	nc
1993:	sbc	$0,&HA0
1996:	jr	nz,&H199C
1998:	ld	$0,&H45
199B:	rtn
199C:	sbc	$0,&HA6
199F:	rtn

; for the segment in the variable &H16C0 and the offset in registers $15,$16
; calculate the effective address in UA,IX
; only bank 0 and the upper half of bank 3 can be accessed
19A0:	pre	ix,&H16C0	;DEFSEG value
19A4:	ldw	$0,(ix+$sx)
19A6:	gst	ua,$2
19A8:	sbc	$1,&H10
19AB:	jr	c,&H19B3
19AD:	pst	ua,&HF4
19B0:	or	$1,&H08
19B3:	diuw	$0
19B5:	adw	$15,$sz
19B7:	jr	nc,&H19BF
19B9:	pst	ua,&HF4
19BC:	or	$15,&H80
19BF:	pre	ix,$15
19C1:	rtn

; function CUR, prefix 5, code &H63
19C2:	cal	&H0054
19C5:	cal	&H0669
19C8:	ld	$6,&H03
19CB:	cal	&H06B8
19CE:	cal	&H0642
19D1:	cal	&H006C
19D4:	ld	$29,$sx
19D6:	sbc	$8,&H05
19D9:	jr	c,&H19E1
19DB:	ld	$29,&H05
19DE:	sbb	$8,&H05
19E1:	jp	&H0940

; function FACT, prefix 5, code &H67
19E4:	sbbm	$0,$sz,8
19E7:	ld	$8,$sx
19E9:	cal	&H0064		;push a FP number $0-$8 on the user stack
19EC:	adc	$18,&HFB
19EF:	jr	c,&H19F4	;BS Error, subscript out of range
19F1:	cal	&H0A2A
19F4:	jp	nz,&H2BA4	;BS Error, subscript out of range
19F7:	sbc	$17,&H10
19FA:	jp	nc,&H2BA4	;BS Error, subscript out of range
19FD:	cal	&H0669		;square root of a FP number $10-$18
1A00:	ppu	$27
1A02:	ppum	$19,8
1A05:	xrcm	$10,$19,8
1A08:	jr	nz,&H1A10
1A0A:	sbc	$18,$27
1A0D:	jp	z,&H06B8	;swap two FP numbers $10-$18 <-> $0-$8
1A10:	phum	$26,8
1A13:	phu	$27
1A15:	cal	&H0054		;push a FP number $10-$18 on the US
1A18:	cal	&H0607		;FP multiplication, $10-$18 <- $10-$18 * $0-$8
1A1B:	cal	&H006C		;pop a FP number from the US to $0-$8
1A1E:	cal	&H0054		;push a FP number $10-$18 on the US
1A21:	cal	&H06B8		;swap two FP numbers $10-$18 <-> $0-$8
1A24:	cal	&H05D2		;subtract 1 from the FP number $10-$18
1A27:	adc	$18,&HFB
1A2A:	jr	c,&H19F4	;BS Error, subscript out of range
1A2C:	cal	&H006C		;pop a FP number from the US to $0-$8
1A2F:	jr	&H1A00

; function NPR, prefix 5, code &HAA
1A31:	phs	$30
1A33:	jr	&H1A37
; function NCR, prefix 5, code &HAB
1A35:	phs	$31
1A37:	cal	&H1A87
1A3A:	cal	&H0054
1A3D:	cal	&H0064
#if ROM_VERSION=2
1A40:	nop
1A41:	cal	&H915B		;patch for argument range checking
#else
1A40:	sbc	$8,$sx
1A42:	jr	z,&H1A47
#endif
1A44:	sbc	$8,&H05
1A47:	jp	z,&H2BA4	;BS Error, subscript out of range
1A4A:	cal	&H05D4
1A4D:	cal	&H006C
1A50:	pps	$19
1A52:	sbc	$19,$sx
1A54:	jr	z,&H1A5C
1A56:	sbbm	$0,$sz,8
1A59:	ld	$8,$sx,jr &H1A62
1A5C:	cal	&H06A6
1A5F:	cal	c,&H06B8
1A62:	phsm	$17,8
1A65:	phs	$18
1A67:	cal	&H005C
1A6A:	cal	&H0064
1A6D:	pps	$8
1A6F:	ppsm	$0,8
1A72:	cal	&H19E9
1A75:	cal	&H06B8
1A78:	cal	&H005C
1A7B:	cal	&H0064
1A7E:	cal	&H19E4
1A81:	cal	&H006C
1A84:	jp	&H0644
1A87:	cal	&H00E1
1A8A:	cal	&H112F
1A8D:	cal	&H0054
1A90:	cal	&H00DB
1A93:	cal	&H112F
1A96:	cal	&H06B8
1A99:	cal	&H005C
1A9C:	phsw	$1
1A9E:	cal	&H00C7
1AA1:	ppsw	$0
1AA3:	rtn
1AA4:	phs	$30
1AA6:	jp	&H08EF

; function POL, prefix 5, code &HA8
1AA9:	cal	&H1A87
1AAC:	cal	&H0054
1AAF:	cal	&H0064
1AB2:	cal	&H06B8
1AB5:	cal	&H0987
1AB8:	phs	$29
1ABA:	cal	&H1AA4
1ABD:	pps	$0
1ABF:	adb	$18,$sz
1AC1:	an	$18,&H0F
1AC4:	cal	&H061D		;FP normalisation
1AC7:	cal	&H0F89
1ACA:	cal	&H1B21
1ACD:	cal	&H006C
1AD0:	cal	&H005C
1AD3:	cal	&H06A6
1AD6:	cal	nc,&H06B8
1AD9:	cal	&H0064
1ADC:	cal	&H0997
1ADF:	cal	&H006C
1AE2:	cal	&H0607
1AE5:	cal	&H0A25		;absolute value of a FP number $10-$18
1AE8:	cal	&H0F89
1AEB:	jr	&H1B1D

; function REC, prefix 5, code &HA7
1AED:	cal	&H1A87
1AF0:	cal	&H0663
1AF3:	cal	&H0064
1AF6:	cal	&H0054
1AF9:	cal	&H06B8
1AFC:	cal	&H0872
1AFF:	cal	&H006C
1B02:	cal	&H0064
1B05:	cal	&H0607
1B08:	cal	&H1B21
1B0B:	cal	&H006C
1B0E:	cal	&H005C
1B11:	cal	&H0064
1B14:	cal	&H0874
1B17:	cal	&H006C
1B1A:	cal	&H0607
1B1D:	ld	$0,&H58,jr &H1B24
1B21:	ld	$0,&H59
1B24:	cal	&H0054
1B27:	pre	ix,&H165E
1B2B:	std	$0,(ix+$sx)
1B2D:	gre	ix,$2
1B2F:	ldw	$0,&H0108
1B33:	pre	ix,&H167E
1B37:	stm	$31,(ix+$sx),5
1B3A:	cal	&H31AD
1B3D:	jp	&H005C

; function VALF, prefix 5, code &H92
1B40:	pre	ix,&H16C4
1B44:	ldm	$0,(ix+$sx),3
1B47:	anc	$0,&H08
1B4A:	jr	nz,&H1B4F
1B4C:	anc	$2,&H04
1B4F:	jp	nz,&H2B78
1B52:	cal	&H00E1
1B55:	cal	&H2930
1B58:	ldd	$0,(ix+$sy)
1B5A:	or	$0,&H04
1B5D:	std	$0,(ix+$sx)
1B5F:	cal	&H11D2		;evaluate a string expression
1B62:	cal	&H125D		;append zero
1B65:	ldw	$0,&H19D5
1B69:	cal	&H9757
1B6C:	gre	iz,$0
1B6E:	phsw	$1
1B70:	pre	iz,$15
1B72:	pre	ix,&H1000
1B76:	ldd	$0,(ix+$sx)
1B78:	phs	$0
1B7A:	std	$31,(ix+$sx)
1B7C:	pre	ix,&H19D5
1B80:	cal	&H1CF9
1B83:	pps	$0
1B85:	pre	ix,&H1000
1B89:	std	$0,(ix+$sx)
1B8B:	cal	&H2930
1B8E:	ldd	$0,(ix+$sy)
1B90:	or	$0,&H04
1B93:	std	$0,(ix+$sx)
1B95:	pre	iz,&H19D5
1B99:	cal	&H112F
1B9C:	ld	$1,$sx
1B9E:	cal	&H00E5
1BA1:	ppsw	$0
1BA3:	pre	iz,$0
1BA5:	cal	&H2930
1BA8:	ldd	$0,(ix+$sy)
1BAA:	an	$0,&H03
1BAD:	std	$0,(ix+$sx)
1BAF:	jp	&H00C7

; function RAN#, prefix 5, code &H93
1BB2:	cal	&H00C5
1BB5:	ld	$0,&HFF
1BB8:	jr	nz,&H1BC3
1BBA:	cal	&H112F
1BBD:	cal	&H00C7
1BC0:	ldw	$0,$17
1BC3:	pre	ix,&H1740
1BC7:	ldim	$10,(ix+$sx),8
1BCA:	ldd	$18,(ix+$sx)
1BCC:	sbcw	$0,$sy
1BCE:	rtn	c
1BCF:	sbc	$1,&H05
1BD2:	jr	c,&H1BDC
1BD4:	gst	tm,$0
1BD6:	adb	$0,$sx
1BD8:	adb	$15,$sz
1BDA:	sbb	$13,$sz
1BDC:	cal	&H09AC
1BDF:	cal	&H0607
1BE2:	cal	&H0A1F
1BE5:	pre	ix,&H1740
1BE9:	stim	$10,(ix+$sx),8
1BEC:	rtn
1BED:	ld	$28,$sy,jr &H1C0B
1BF0:	ld	$28,&H0A,jr &H1C0B
; function CNT, prefix 5, code &H51
1BF4:	ld	$28,&H13,jr &H1C0B
; function SUMX, prefix 5, code &H52
1BF8:	ld	$28,&H1C,jr &H1C0B
; function SUMY, prefix 5, code &H53
1BFC:	ld	$28,&H25,jr &H1C0B
1C00:	ld	$28,&H2E,jr &H1C0B
1C04:	ld	$28,&H37,jr &H1C0B
1C08:	ld	$28,&H40
1C0B:	pre	ix,&H16F0
1C0F:	ldim	$0,(ix+$28),8
1C12:	ldd	$8,(ix+$sx)
1C14:	jp	&H06B8
1C17:	sbc	$0,$sx
1C19:	jr	nz,&H1C29
1C1B:	cal	&H1C65
1C1E:	cal	&H1BF8
1C21:	cal	&H0607
1C24:	cal	&H1C00
1C27:	jr	&H1C35
1C29:	cal	&H1C6A
1C2C:	cal	&H1BFC
1C2F:	cal	&H0607
1C32:	cal	&H1C04
1C35:	cal	&H05D4
1C38:	sbc	$18,&H05
1C3B:	rtn	c
1C3C:	jp	&H0636

; function SDX, prefix 5, code &H59
1C3F:	phs	$31
1C41:	jr	&H1C45
; function SDY, prefix 5, code &H5A
1C43:	phs	$30
1C45:	cal	&H1BF4
1C48:	cal	&H05D2
1C4B:	pps	$0
1C4D:	cal	&H0054
1C50:	cal	&H1C17
1C53:	cal	&H1CC3
1C56:	jp	&H066D

; function SDXN, prefix 5, code &H5B
1C59:	cal	&H1BF4
1C5C:	ld	$0,$sx,jr &H1C4D

; function SDYN, prefix 5, code &H5C
1C5F:	cal	&H1BF4
1C62:	ld	$0,$sy,jr &H1C4D

; function MEANX, prefix 5, code &H57
1C65:	cal	&H1BF8
1C68:	jr	&H1C6D

; function MEANY, prefix 5, code &H58
1C6A:	cal	&H1BFC
1C6D:	cal	&H1BF4
1C70:	jr	&H1CDE
1C72:	cal	&H1C6A
1C75:	cal	&H1BF8
1C78:	cal	&H0607
1C7B:	cal	&H1C08
1C7E:	jr	&H1C98
1C80:	cal	&H1C65
1C83:	cal	&H1C08
1C86:	cal	&H0607
1C89:	cal	&H0054
1C8C:	cal	&H1C6A
1C8F:	cal	&H1C00
1C92:	cal	&H0607
1C95:	cal	&H006C
1C98:	jp	&H05D4

; function LRA, prefix 5, code &H5D
1C9B:	cal	&H1C80
1C9E:	cal	&H0054
1CA1:	cal	&H1C1B
1CA4:	jr	&H1CDB

; function LRB, prefix 5, code &H5E
1CA6:	cal	&H1C1B
1CA9:	jr	&H1CBD

; function COR, prefix 5, code &H5F
1CAB:	cal	&H1C1B
1CAE:	cal	&H0054
1CB1:	cal	&H1C29
1CB4:	cal	&H006C
1CB7:	cal	&H0607
1CBA:	cal	&H066D
1CBD:	cal	&H0054
1CC0:	cal	&H1C72
1CC3:	cal	&H006C
1CC6:	jp	&H0646

; function EOX, prefix 5, code &H69
1CC9:	cal	&H0054
1CCC:	cal	&H1C9B
1CCF:	cal	&H006C
1CD2:	cal	&H05CE
1CD5:	cal	&H0054
1CD8:	cal	&H1CA6
1CDB:	cal	&H006C
1CDE:	jp	&H0644

; function EOY, prefix 5, code &H6A
1CE1:	cal	&H0054
1CE4:	cal	&H1CA6
1CE7:	cal	&H006C
1CEA:	cal	&H0607
1CED:	cal	&H0054
1CF0:	cal	&H1C9B
1CF3:	cal	&H006C
1CF6:	jp	&H05DA
1CF9:	sbw	$14,$14
1CFC:	ld	$23,$sx,jr &H1D49


; *** BASIC parser routines ***

1CFF:	sbc	$1,$sx
1D01:	jp	z,&H1D7B
1D04:	jp	&H2B7C		;BV Error, buffer overflow

; copy to the INTOP buffer the tokenised contents of a line pointed to by the
; IZ register (usually a place in the EDTOP buffer at the cursor position)
; register $14 counts the stored bytes
; register $15 contains the parser state:
; bit 0 - ampersand flag
; bit 1 - hex numeral flag, set after sequence "&H"
; bit 6 - remark flag, all bytes up to the end of the line will be copied
;   literally
; bit 7 - quotes flag, all bytes up to the next quotation mark will be copied
;   literally
1D07:	ld	$23,$sx
1D09:	sbw	$14,$14
1D0C:	cal	&H2972		;returns Not Zero if BASIC mode
1D0F:	pre	ix,&H1000	;INTOP buffer
1D13:	jr	z,&H1D49
1D15:	cal	&H0029		;NEXTC + OKNM1, is $0 a digit?
1D18:	jr	nc,&H1D49
1D1A:	ld	$0,$sx
1D1C:	pre	ix,&H1105
1D20:	sbc	(ix+$sx),$31
1D22:	jr	nz,&H1D32
1D24:	adc	(ix-$sy),$30
1D26:	jr	nc,&H1D32
1D28:	pre	ix,&H1239
1D2C:	ldw	$0,(ix+$sx)
1D2E:	sbc	$1,$sx
1D30:	jr	nz,&H1D04
1D32:	phs	$0
1D34:	pre	ix,&H1000	;INTOP buffer
1D38:	cal	&H1E9F		;parse the input buffer for an integer numeral
1D3B:	sbcw	$17,$sy
1D3D:	jp	c,&H2BAC	;UL Error, BASIC line number
1D40:	pps	$1
1D42:	ld	$0,&H20
1D45:	sbc	(iz+$sx),$0
1D47:	jr	nz,&H1CFF
1D49:	ldi	$0,(iz+$sx)
1D4B:	sbc	$0,&H20
1D4E:	jr	nc,&H1D62
1D50:	pre	ix,&H1000	;INTOP buffer
1D54:	ldd	$0,(ix+$sx)
1D56:	ld	$15,$sx
1D58:	sbc	$0,&H03
1D5B:	rtn	nz
1D5C:	std	$14,(ix+$sx)
1D5E:	ld	$15,$14
1D61:	rtn
;
1D62:	sbc	$15,&H40
1D65:	jr	z,&H1D6F
1D67:	sbc	$0,&H22		;quotation mark?
1D6A:	jr	nz,&H1D80
1D6C:	xr	$15,&H80	;flip the quotes flag
;
1D6F:	sbc	$0,&H3D		;'='
1D72:	jr	nz,&H1D7B
1D74:	anc	$15,&HC0
1D77:	jr	nz,&H1D7B
1D79:	or	$23,$sy
1D7B:	cal	&H1ECD		;store byte $0 in the output buffer
1D7E:	jr	&H1D49
;
1D80:	anc	$15,&H80
1D83:	jr	nz,&H1D6F
1D85:	sbc	$0,&H3A		;':'
1D88:	jr	nz,&H1D8F
1D8A:	ld	$0,$sy		;code of colon separating multiple statements
1D8C:	ld	$15,$sx,jr &H1D6F
1D8F:	sbc	$0,&H27		;apostrophe, starts a comment
1D92:	jr	nz,&H1D9B
1D94:	ld	$0,&H02		;code of the apostrophe used as remark
1D97:	ld	$15,&H40,jr &H1D6F
1D9B:	sbc	$0,&H26		;'&', starts a hex numeral
1D9E:	jr	nz,&H1DA3
1DA0:	ld	$15,$sy,jr &H1D6F
1DA3:	cal	&H00B6		;TCAPS, lower to upper case conversion
1DA6:	sbc	$15,$sy
1DA8:	jr	nz,&H1DB1
1DAA:	diu	$15
1DAC:	sbc	$0,&H48		;'H'
1DAF:	jr	z,&H1D6F
1DB1:	cal	&H00AB		;OKAM1, is $0 a letter?
1DB4:	jr	nc,&H1DCE	;branch if not
1DB6:	sbc	$15,&H20
1DB9:	jr	z,&H1DD3
1DBB:	sbc	$15,&H10
1DBE:	jr	nz,&H1DC5
1DC0:	sbc	$0,&H47		;'F'+1
1DC3:	jr	c,&H1D6F
1DC5:	ldd	$1,(iz-$sy)
1DC7:	cal	&H1E51		;parse for a keyword
1DCA:	jr	nc,&H1DD3	;branch when not any keyword found
1DCC:	jr	&H1DE0
1DCE:	cal	&H0098
1DD1:	jr	nc,&H1DD9
1DD3:	ld	$0,(iz-$sy)
1DD5:	ld	$15,&H20,jr &H1D6F
1DD9:	cal	&H002B		;OKNM1, is $0 a digit?
1DDC:	jr	nc,&H1D8C
1DDE:	jr	&H1D6F
;
1DE0:	ld	$15,$sx
1DE2:	sbc	$17,&H48	;code of the keyword ELSE
1DE5:	jr	nz,&H1E00
1DE7:	ld	$0,$sy		;colon before the ELSE statement
1DE9:	cal	&H1ECD		;store byte $0 in the output buffer
1DEC:	cal	&H1ED4		;store word $16,$17 in the output buffer
1DEF:	sbc	$17,&HA9	;code of the keyword REM
1DF2:	jr	z,&H1DFC
1DF4:	ldw	$0,&H8004	;keyword DATA
1DF8:	sbcw	$16,$sz
1DFA:	jr	nz,&H1E32
1DFC:	ld	$15,&H40,jr &H1E2F	;remark flag
;
1E00:	ldw	$0,&HAC05	;keyword HYP
1E04:	sbcw	$16,$sz
1E06:	jr	nz,&H1DEC
1E08:	cal	&H1ED4		;store word $16,$17 in the output buffer
1E0B:	cal	&H0049		;NEXTC, get next character other than space
1E0E:	cal	&H00AB		;OKAM1, is $0 a letter?
1E11:	jr	nc,&H1E2F
1E13:	cal	&H00B6		;TCAPS, lower to upper case conversion
1E16:	cal	&H1E51		;parse for a keyword
1E19:	jr	nc,&H1DD3	;branch when not any keyword found
1E1B:	sbc	$16,&H05	;keyword prefix
1E1E:	jr	nz,&H1DE0
1E20:	sbc	$17,&H6B	;keyword code
1E23:	jr	c,&H1DE0
1E25:	sbc	$17,&H71
1E28:	jr	nc,&H1DE0
; keyword prefix = &H05 and codes = &H6B to &H70 (trigonometric functions)
1E2A:	ad	$17,&H06
1E2D:	st	$17,(ix-$sy)
1E2F:	jp	&H1D49
;
1E32:	sbc	$17,&H4E
1E35:	jr	nc,&H1E2F
1E37:	cal	&H1EC0		;copy spaces
1E3A:	cal	&H002B		;OKNM1, is $0 a digit?
1E3D:	jr	nc,&H1E45
1E3F:	cal	&H1E9F		;parse the input buffer for an integer numeral
1E42:	cal	&H1EC0		;copy spaces
1E45:	sbc	$0,&H2C
1E48:	jr	nz,&H1E2F
1E4A:	cal	&H1ECD		;store byte $0 in the output buffer
1E4D:	ldd	$0,(iz+$sy)
1E4F:	jr	&H1E37

; parse the BASIC line pointed to by IZ for a keyword
; also expects the first character of the parsed string in the $0 register
; return with Carry set when a keyword found
; $16 = prefix of the identified keyword
; $17 = code of the identified keyword
1E51:	gre	ix,$2
1E53:	sb	$0,&H41		;'A'
1E56:	biu	$0
1E58:	gst	ua,$1
1E5A:	phs	$1
1E5C:	an	$1,&HCF
1E5F:	or	$1,&H20
1E62:	pst	ua,$1
1E64:	pre	ix,&H0B74	;table of keyword addresses
1E68:	ldw	$0,(ix+$sz)
1E6A:	pre	ix,$0		;pointer to the table of keywords
1E6C:	ld	$16,&H04	;initial keyword prefix value
1E6F:	cal	&H0586
1E72:	jr	c,&H1E84
1E74:	ad	$16,$sy
1E76:	sbc	$16,&H08
1E79:	jr	nz,&H1E6F
1E7B:	ldi	$0,(iz+$sx)	;updated next parsed character
1E7D:	pre	ix,$2
1E7F:	pps	$1
1E81:	pst	ua,$1
1E83:	rtn

1E84:	sbc	$16,&H05
1E87:	jr	nz,&H1E9B
1E89:	sbc	$17,&H82
1E8C:	jr	nz,&H1E9B
1E8E:	ldd	$0,(iz+$sx)
1E90:	sbc	$0,&H24
1E93:	jr	nz,&H1E9B
1E95:	ldw	$16,&H9706
1E99:	ldi	$0,(iz+$sx)
1E9B:	sbc	$31,$sy
1E9D:	jr	&H1E7D
1E9F:	cal	&H1EDF
1EA2:	sbcw	$17,$sy
1EA4:	jr	c,&H1EB8
1EA6:	ad	$14,&H03
1EA9:	jr	c,&H1ED9
1EAB:	stim	$16,(ix+$sx),3
1EAE:	ldd	$0,(iz-$sy)
1EB0:	sbc	$0,&H20
1EB3:	jr	z,&H1EAE
1EB5:	ldd	$0,(iz+$sy)
1EB7:	rtn
1EB8:	ld	$0,&H30
1EBB:	cal	&H1ECD
1EBE:	jr	&H1EAE
1EC0:	ldd	$0,(iz+$sx)
1EC2:	sbc	$0,&H20
1EC5:	rtn	nz
1EC6:	cal	&H1ECD
1EC9:	ldd	$0,(iz+$sy)
1ECB:	jr	&H1EC2
1ECD:	ad	$14,$sy
1ECF:	jr	c,&H1ED9
1ED1:	sti	$0,(ix+$sx)
1ED3:	rtn
1ED4:	ad	$14,&H02
1ED7:	jr	nc,&H1EDC
1ED9:	jp	&H2B7C
1EDC:	stiw	$16,(ix+$sx)
1EDE:	rtn
1EDF:	cal	&H1EE6
1EE2:	jp	c,&H2B98	;OV Error, overflow
1EE5:	rtn

; DTBIN:
; Converts a string pointed to by IZ to an unsigned integer number in $17,18.
; Additionally $16 contains the prefix of a binary line number.
; Returns IZ pointing to the first character which is not a decimal digit.
; Returns Carry set if the result exceeds 65535
1EE6:	ld	$16,&H03	;prefix of a binary line number
1EE9:	sbw	$17,$17		;initial result <- 0
1EEC:	ldw	$2,&H199A	;6554 decimal
1EF0:	cal	&H0029		;NEXTC + OKNM1, is $0 a digit?
1EF3:	rtn	nc
1EF4:	sbcw	$17,$2
1EF7:	jr	nc,&H1F0E	;result out of the limit
1EF9:	an	$0,&H0F
1EFC:	ld	$1,$sx
; $17,$18 <- $17,$18 * 10
1EFE:	biuw	$17		;*2
1F00:	adw	$0,$17
1F03:	biuw	$17		;*4
1F05:	biuw	$17		;*8
1F07:	adw	$17,$sz		;*(8+2)
1F09:	ldd	$0,(iz+$sy)
1F0B:	jr	nc,&H1EF0
1F0D:	rtn
1F0E:	sbc	$31,$sy		;set Carry
1F10:	rtn

; Converts a string pointed to by IZ to an unsigned integer number in $17,18.
; Conversion result exceeding 65535 causes an OV or UL Error
1F11:	cal	&H1EDF		;DTBIN, $17,$18 <- value of ASCII dec. number
1F14:	sbcw	$17,$sy		;0 not allowed
1F16:	rtn	nc
1F17:	jp	&H2BAC		;UL Error, BASIC line number

; parse the input buffer for line number range
; returns the starting line in $4,$5 and the ending line in $6,$7
1F1A:	sbbm	$4,$4,4		;default starting line $4,$5 = 0
1F1D:	invw	$6		;default ending line $6,$7 = &HFFFF
1F1F:	phsw	$18
1F21:	cal	&H00C9		;test for '-'
1F24:	jr	z,&H1F3B
1F26:	cal	&H002B		;OKNM1, is $0 a digit?
1F29:	jr	nc,&H1F47
1F2B:	cal	&H1F11		;$17,$18 <- value of an ASCII decimal number
1F2E:	ldw	$4,$17
1F31:	cal	&H00C9		;test for '-'
1F34:	jr	nz,&H1F3E
1F36:	cal	&H003C		;ENDSC, test for an end of a BASIC line
1F39:	jr	c,&H1F47
1F3B:	cal	&H1F11		;$17,$18 <- value of an ASCII decimal number
1F3E:	ldw	$6,$17
1F41:	sbcw	$6,$4
1F44:	jp	c,&H2BA4	;BS Error if starting_line > ending_line
1F47:	ppsw	$17
1F49:	jp	&H0093		;SN Error if not an end of a BASIC line

; power switch on
1F4C:	ld	$16,&H01,jr &H1F53
; reset
1F50:	ld	$16,&H00
1F53:	psr	sx,31
1F55:	psr	sy,30
1F57:	psr	sz,0
1F59:	ldw	$30,&H0001
1F5D:	pst	ua,&HD4
1F60:	pre	ss,&H1BD7
1F64:	pre	us,&H1CD0
1F68:	cal	&H0403
1F6B:	sbc	$16,$sx
1F6D:	jr	nz,&H1F7B
1F6F:	pre	ix,&H110F	;system variable APOCN, APO counter
1F73:	ld	$0,&H07
1F76:	st	$0,(ix+$sy)
1F78:	cal	&H92EA		;set the initial contrast data pointer ELVAD
1F7B:	cal	&H27A7
1F7E:	pst	ua,&H54
1F81:	jp	&H1FC3

; instruction TRP
1F84:	rtn

; pulse/key interrupt service routine
1F85:	phsm	$3,4
1F88:	gfl	$0
1F8A:	gre	ix,$1
1F8C:	gst	ua,$3
1F8E:	pst	ua,&H54
1F91:	pre	ix,&H16ED
1F95:	sbc	(ix+$sx),$31
1F97:	jr	z,&H1FA5
1F99:	sbw	(ix+$sy),$30
1F9B:	jr	nz,&H1FA5
1F9D:	stw	$30,(ix+$sy)
1F9F:	pre	ix,&H110F	;system variable APOCN, APO counter
1FA3:	std	$31,(ix+$sx)
1FA5:	pst	ua,$3
1FA7:	pre	ix,$1
1FA9:	pfl	$0
1FAB:	ppsm	$0,4
1FAE:	rtni

; external interrupt 2 service routine
1FAF:	rtni

1FB0:	cal	&H2991		;select the LCD as the output device
1FB3:	cal	&H29B4		;clear the ANSFG variable
1FB6:	cal	&H2AE8		;OUTCR, display CR-LF
1FB9:	pre	ss,&H1BD7
1FBD:	cal	&H2891
1FC0:	cal	&H2888
1FC3:	cal	&H2972		;returns Not Zero if BASIC mode
1FC6:	cal	nz,&H2D64	;display the string 'Ready'
1FC9:	cal	&H9272
1FCC:	cal	&H001C		;$1 <- (LCDST)
1FCF:	an	$1,&H20
1FD2:	or	$1,&H06
1FD5:	std	$1,(ix+$sx)
1FD7:	pst	ua,&H54
1FDA:	ldw	$2,&H1FB0	;jump address
1FDE:	cal	&H297A		;BRSTR, set ACJMP
1FE1:	cal	&H29BB
1FE4:	cal	&H2002
1FE7:	cal	&H29A1		;test the ANSFG variable
1FEA:	jr	nz,&H1FF1
1FEC:	cal	&H2610
1FEF:	jr	&H1FD7
1FF1:	std	$31,(ix+$sx)
1FF3:	cal	&H2AE8		;OUTCR, display CR-LF
1FF6:	jr	&H1FD7

1FF8:	pre	ss,&H1BD7
1FFC:	pre	us,&H1CD0
2000:	jr	&H1FE4

2002:	cal	&H23C8
2005:	cal	&H294F
2008:	anc	$1,&H04
200B:	jp	nz,&H5A5A
200E:	sbc	$0,&H9A
2011:	jp	z,&H21F0
2014:	sbc	$0,&H9B
2017:	jp	z,&H21F8
201A:	sbc	$0,&H80
201D:	jr	c,&H2024
201F:	sbc	$0,&HA6
2022:	jr	c,&H2033
2024:	sbc	$0,&H0D
2027:	rtn	z
2028:	sbc	$0,&HE0
202B:	jp	nc,&H2075
202E:	cal	&H2038		;display character $0 optionally preceded
				;by the ANS value in a new line
2031:	jr	&H2002
2033:	cal	&H2143
2036:	jr	&H2002

; Display character $0 typed on the keyboard. If it is any of these:
; *+-/^ or Yen, typed immediately after displaying the result of the previous
; calculation then first display that result again in a new line.
2038:	ld	$16,$sz		;key code
203A:	cal	&H29A1		;test the ANSFG variable
203D:	jr	z,&H206F
203F:	sbc	$16,&H20	;control character?
2042:	jr	c,&H206F	;skip if so
2044:	phs	$16
2046:	cal	&H2AE8		;OUTCR, display CR-LF
2049:	pps	$16
204B:	sbc	$16,&H5C	;Yen
204E:	jr	z,&H2065
2050:	sbc	$16,&H2A	;'*'
2053:	jr	z,&H2065
2055:	jr	c,&H206F
2057:	sbc	$16,&H5E	;'^'
205A:	jr	z,&H2065
205C:	sbc	$16,&H30
205F:	jr	nc,&H206F
2061:	anc	$16,$sy		;'+' or '-' or '/' ?
2063:	jr	z,&H206F	;skip if not
2065:	phs	$16
2067:	cal	&H2ADB
206A:	cal	&H21AA		;display the ANS data
206D:	pps	$16
206F:	cal	&H29B1
2072:	jp	&H2AE3		;display character $16

2075:	ld	$16,$sz
2077:	pre	ix,&H207E
207B:	jp	&H0166		;execute a procedure from the table

207E:	E0, 2365
2081:	E1, 2365
2084:	E2, 220C
2087:	E3, 2214
208A:	E4, 224C
208D:	E5, 225F
2090:	E6, 22BB
2093:	E7, 22E6
2096:	E8, 2DB8
2099:	E9, 2203
209C:	EE, 614B
209F:	EF, 614B
20A2:	00, 24A7

; display the list of data files
20A5:	ld	$14,&H0A	;index to the table of file addresses
20A8:	ld	$16,&H46,jr &H20B1	;'F'
; display the list of BASIC programs
20AC:	ld	$14,$sx	;index to the table of file addresses
20AE:	ld	$16,&H50	;'P'
20B1:	cal	&H2AF1		;display character $16
20B4:	cal	&H2AD7		;display a space
20B7:	ld	$17,&H0A	;number of areas
20BA:	cal	&H3428
20BD:	cal	&H33FA		;$2,$3 <- file size
20C0:	ld	$16,&H2A	;asterisk when the area is occuppied
20C3:	jr	nz,&H20D3	;skip if the area is free
20C5:	ld	$16,$14		;index to the table of file addresses
20C8:	sbc	$16,&H0A
20CB:	jr	c,&H20D0
20CD:	sb	$16,&H0A
20D0:	or	$16,&H30	;'0'
20D3:	cal	&H2AF1		;display character $16
20D6:	cal	&H2AD7		;display a space
20D9:	ad	$14,$sy		;increment the index
20DB:	sb	$17,$sy		;decrement the counter of displayed areas
20DD:	jr	nz,&H20BA	;next area
20DF:	jp	&H7B50

20E2:	ldw	$0,&H18D1
20E6:	ldw	$3,($sz)
20E8:	ldw	$0,&H18CF
20EC:	ldw	$0,($sz)
20EE:	sbw	$3,$sz
20F0:	cal	&H20FC		;display a decimal number $3,$4
20F3:	ld	$16,&H42
20F6:	cal	&H2AF1		;display character $16
20F9:	jp	&H95D3

; display a decimal number $3,$4 (right aligned)
20FC:	cal	&H187E
20FF:	ld	$13,&H04
2102:	sbc	$17,$13
2105:	jr	nc,&H2113
2107:	phsm	$16,4
210A:	cal	&H2AD7		;display a space
210D:	ppsm	$13,4
2110:	sb	$13,$sy,jr &H2102
2113:	phs	$16
2115:	an	$16,&H0F
2118:	or	$16,&H30
211B:	cal	&H2AF1		;display character $16
211E:	pps	$16
2120:	dium	$14,3
2123:	sb	$17,$sy
2125:	jr	nc,&H2113
2127:	rtn

2128:	phs	$0
212A:	cal	&H29A1
212D:	pps	$0
212F:	jr	z,&H2148
2131:	phs	$0
2133:	cal	&H2AE8		;OUTCR, display CR-LF
2136:	cal	&H2ADB
2139:	cal	&H21AA
213C:	cal	&H29B1
213F:	pps	$0
2141:	jr	&H214F
2143:	sbc	$0,&HA1
2146:	jr	nc,&H2128
2148:	phs	$0
214A:	cal	&H29AA
214D:	pps	$0
214F:	cal	&H217F
2152:	phsm	$12,3
2155:	ldi	$16,(iz+$sx)
2157:	anc	$16,&H80
215A:	jr	nz,&H2161
215C:	cal	&H2AE3		;display character $16
215F:	jr	&H2155
2161:	an	$16,&H7F
2164:	cal	&H2AE3		;display character $16
2167:	ld	$16,&H28
216A:	biu	$14
216C:	cal	c,&H2AE3	;display character $16
216F:	ld	$16,&H20
2172:	biu	$14
2174:	cal	c,&H2AE3	;display character $16
2177:	ppsm	$0,3
217A:	pre	iz,$1
217C:	pst	ua,$0
217E:	rtn

217F:	sb	$0,&H80
2182:	biu	$0
2184:	gst	ua,$10
2186:	gre	iz,$11
2188:	pst	ua,&H94
218B:	pre	iz,&H13B1
218F:	ldw	$0,(iz+$sz)
2191:	ld	$14,$1
2194:	an	$1,&H1F
2197:	pre	iz,$0
2199:	rtn
219A:	cal	&H22A4
219D:	cal	&H131F
21A0:	pre	ix,&H1131
21A4:	std	$30,(ix+$sx)
21A6:	rtn

21A7:	ld	$0,$sx,jr &H21AC
21AA:	ld	$0,$sy
21AC:	phs	$27
21AE:	phsm	$22,6
21B1:	cal	&H21CC
21B4:	cal	&H13A7
21B7:	pre	ix,$15
21B9:	ldi	$16,(ix+$sx)
21BB:	gre	ix,$14
21BD:	cal	&H2AE3		;display character $16
21C0:	pre	ix,$14
21C2:	sb	$17,$sy
21C4:	jr	nz,&H21B9
21C6:	ppsm	$17,6
21C9:	pps	$27
21CB:	rtn

21CC:	sbc	$0,$sy
21CE:	jr	z,&H21D6
21D0:	pre	ix,&H1753
21D4:	jr	&H21DA
21D6:	pre	ix,&H1749
21DA:	ldim	$10,(ix+$sx),8
21DD:	ldi	$18,(ix+$sx)
21DF:	rtn
21E0:	cal	&H29A1
21E3:	jr	nz,&H21EA
21E5:	ppsw	$2
21E7:	jp	&H2033
21EA:	cal	&H29AA
21ED:	jp	&H21D6

21F0:	cal	&H21E0
21F3:	cal	&H15C5
21F6:	jr	&H21FE

21F8:	cal	&H21E0
21FB:	cal	&H1564
21FE:	cal	&H22A4
2201:	jr	&H222E
2203:	cal	&H29AA
2206:	cal	&H21AA
2209:	jp	&H2002
220C:	cal	&H29AA
220F:	cal	&H21A7
2212:	jr	&H2209
2214:	cal	&H2276
2217:	jr	nc,&H2209
2219:	cal	&H21D6
221C:	cal	&H0054
221F:	cal	&H09C9		;rounding the mantissa to 12 digits
2222:	cal	&H005C
2225:	pre	ix,&H1753
2229:	stim	$10,(ix+$sx),8
222C:	std	$18,(ix+$sx)
222E:	cal	&H21D6
2231:	cal	&H22A4
2234:	cal	&H131F
2237:	pre	ix,&H1131
223B:	std	$30,(ix+$sx)
223D:	phs	$16
223F:	cal	&H2ADB
2242:	pps	$16
2244:	cal	&H97D5
2247:	cal	&H29BB
224A:	jr	&H2209
224C:	cal	&H2276
224F:	jr	nc,&H2209
2251:	cal	&H21D6
2254:	cal	&H06B8
2257:	cal	&H21D0
225A:	cal	&H05DA
225D:	jr	&H221C
225F:	cal	&H2276
2262:	jr	nc,&H2209
2264:	cal	&H21D6
2267:	cal	&H06B8
226A:	cal	&H21D0
226D:	cal	&H05D4
2270:	jr	&H221C
2272:	ppsw	$0
2274:	jr	&H2209
2276:	pre	ix,&H16C4
227A:	sbcw	(ix+$sx),$30
227C:	jr	nc,&H2272
227E:	cal	&H29A1
2281:	jr	z,&H2288
2283:	cal	&H29AA
2286:	jr	&H22B8
2288:	cal	&H975E
228B:	cal	&H1D07
228E:	pre	iz,&H1000
2292:	sbc	(iz+$sx),$31
2294:	jr	z,&H2272
2296:	cal	&H28AF
2299:	cal	&H95D3
229C:	cal	&H112F
229F:	sbc	(iz+$sx),$31
22A1:	jp	nz,&H2B70	;SN Error, syntax
22A4:	cal	&H0054
22A7:	cal	&H09C9		;rounding the mantissa to 12 digits
22AA:	cal	&H005C
22AD:	pre	ix,&H1749
22B1:	stim	$10,(ix+$sx),8
22B4:	na	$19,$sx
22B6:	stw	$18,(ix+$sx)
22B8:	sbc	$31,$sy
22BA:	rtn
22BB:	cal	&H22EF
22BE:	cal	&H2930
22C1:	sbc	$1,$sx
22C3:	jr	nz,&H22E0
22C5:	cal	&H95D3
22C8:	cal	&H29B1
22CB:	cal	&H2A0C
22CE:	ldd	$0,(ix+&H02)
22D1:	ld	$1,$sz
22D3:	an	$0,&H02
22D6:	std	$0,(ix+$sx)
22D8:	anc	$1,$sy
22DA:	jp	nz,&H1FB9
22DD:	jp	&H1FF8
22E0:	cal	&H2ADB
22E3:	jp	&H2002
22E6:	cal	&H29AA
22E9:	cal	&H2354
22EC:	jp	&H2002
22EF:	cal	&H029C
22F2:	cal	&H02FE
22F5:	cal	&H973A
22F8:	pre	ix,&H1104
22FC:	ldw	$2,(ix+$sx)
22FE:	ld	$0,$2
2301:	sb	$0,$3
2304:	pre	ix,&H113B
2308:	ld	$4,&H21
230B:	adc	$0,$sy
230D:	jr	nc,&H233A
230F:	sbc	(ix+$sz),$4
2311:	jr	c,&H233A
2313:	cal	&H2937
2316:	jr	z,&H231E
2318:	cal	&H0323
231B:	cal	&H95D3
231E:	cal	&H293F
2321:	jp	z,&H2B7C
2324:	sbc	(ix-$sy),$31
2326:	jp	nz,&H2B7C
2329:	cal	&H2ADB
232C:	ldw	$17,&H263C
2330:	cal	&H6520		;display a string from bank 2
2333:	cal	&H2AE8		;OUTCR, display CR-LF
2336:	ppsw	$0
2338:	jr	&H22E3
233A:	ldw	$0,&H18D3
233E:	ld	$4,(ix+$3)
2341:	sbc	$3,$2
2344:	jr	z,&H234D
2346:	st	$4,($sz)
2348:	adw	$0,$sy
234A:	ad	$3,$sy,jr &H233E
234D:	st	$4,($sz)
234F:	adw	$0,$sy
2351:	st	$31,($sz)
2353:	rtn
2354:	pre	ix,&H18D3
2358:	ldi	$16,(ix+$sx)
235A:	sbc	$16,$sx
235C:	rtn	z
235D:	gre	ix,$14
235F:	cal	&H2AE3		;display character $16
2362:	pre	ix,$14,jr &H2358
2365:	cal	&H29A1
2368:	jp	z,&H2002
236B:	ld	$0,$16
236E:	cal	&H21D6
2371:	ld	$19,$18
2374:	cal	&H0A25		;absolute value of a FP number $10-$18
2377:	ldd	$23,(ix+$sx)
2379:	adc	$23,$sy
237B:	jr	nc,&H2394
237D:	ldw	$23,$17
2380:	diuw	$23
2382:	did	$23
2384:	adb	$23,$24
2387:	sbb	$23,$sy
2389:	jr	z,&H23A8
238B:	sbb	$23,&H03
238E:	jr	nc,&H2389
2390:	anc	$0,$sy
2392:	jr	nz,&H23A8
2394:	adb	$23,&H03
2397:	anc	$0,$sy
2399:	jr	z,&H239E
239B:	sbb	$23,&H06
239E:	sbc	$23,$sx
23A0:	jr	uz,&H23A8
23A2:	adc	$23,&H6F
23A5:	jp	nc,&H2002
23A8:	ld	$24,$sx
23AA:	sbc	$23,&H50
23AD:	jr	c,&H23B1
23AF:	sbb	$24,$sy
23B1:	ldw	$0,$17
23B4:	sbbw	$0,$23
23B7:	anc	$1,&HFE
23BA:	jp	nz,&H2002
23BD:	std	$23,(ix+$sx)
23BF:	cal	&H139F
23C2:	cal	&H264E
23C5:	jp	&H2002

; CRTKY:
23C8:	cal	&H023D
23CB:	cal	&H03A4
23CE:	phs	$0
23D0:	cal	&H0241
23D3:	cal	&H294F
23D6:	anc	$1,&H46
23D9:	pps	$0
23DB:	jr	nz,&H23E5
23DD:	sbc	$0,&HFD
23E0:	jr	nz,&H23E5
23E2:	ld	$0,&H0D
23E5:	pre	ix,&H1113
23E9:	ldd	$2,(ix+$sx)
23EB:	sbc	$0,&HFB
23EE:	jr	z,&H2410
23F0:	ld	$3,$2
23F3:	an	$2,&HEF
23F6:	std	$2,(ix+$sx)
23F8:	anc	$3,&H10
23FB:	jr	z,&H2403
23FD:	cal	&H002B		;OKNM1, is $0 a digit?
2400:	jp	c,&H2417	;branch if so
2403:	sbc	$0,&HEA
2406:	rtn	c
2407:	ld	$16,$sz
2409:	pre	ix,&H2484
240D:	jp	&H0166		;execute a procedure from the table

2410:	or	$2,&H10
2413:	std	$2,(ix+$sx)
2415:	jr	&H23C8

; digit $0 following the [MODE] key
2417:	sbc	$0,&H39		;'9'
241A:	jp	z,&H5ACE	;mode MEMO-IN
241D:	sbc	$0,&H31		;'1'
2420:	jr	c,&H2446	;mode CAL
2422:	jr	z,&H2431	;mode BASIC
2424:	sbc	$0,&H34		;'4'
2427:	jr	c,&H2403
2429:	an	$0,&H0F
242C:	cal	&H52BA		;execute MODE4 to MODE8
242F:	jr	&H2415

; BASIC
2431:	cal	&H2457
2434:	cal	&H298D
2437:	cal	&H20AC		;display the list of BASIC programs
243A:	cal	&H2AD7		;display a space
243D:	cal	&H20E2
2440:	cal	&H6543
2443:	ld	$1,$sy,jr &H244B

; CAL
2446:	cal	&H2457
2449:	ld	$1,$sx
244B:	sbw	$2,$2
244E:	cal	&H2471
2451:	cal	&H29B4		;clear the ANSFG variable
2454:	jp	&H1FB9

2457:	cal	&H2991		;select the LCD as the output device
245A:	cal	&H29B4		;clear the ANSFG variable
245D:	cal	&H0323
2460:	cal	&H032A
2463:	jr	&H2468
2465:	cal	&H277E
2468:	cal	&H9774
246B:	jp	&H2ADF
246E:	sbbm	$1,$1,3
2471:	phsm	$3,3
2474:	cal	&H994F
2477:	ppsm	$1,3
247A:	pre	ix,&H16C4
247E:	stm	$1,(ix+$sx),3
2481:	jp	&H9272

2484:	EA, 6F46
2487:	EB, 7013	;CASL
248A:	EC, 6A4F
248D:	ED, 626B
2490:	FA, 267E
2493:	FE, 8A31	;self-test main menu
2496:	00, 2499

2499:	ld	$0,$16
249C:	rtn
249D:	phs	$16
249F:	cal	&H2465
24A2:	cal	&H246E
24A5:	pps	$16
24A7:	cal	&H294F
24AA:	st	$31,(ix+&H02)
24AD:	anc	$1,$sy
24AF:	jr	nz,&H24BE
24B1:	sbc	(ix+$sy),$31
24B3:	jr	z,&H24BE
24B5:	an	$16,&H3F
24B8:	ld	$0,$16
24BB:	jp	&H202E
24BE:	cal	&H2A0C
24C1:	ld	$14,$16
24C4:	an	$14,&H0F
24C7:	cal	&H3404
24CA:	cal	&H2972
24CD:	jp	nz,&H2431
24D0:	cal	&H29AA
24D3:	cal	&H24DC
24D6:	sbbw	$17,$17
24D9:	jp	&H3538
24DC:	pre	ix,&H1103
24E0:	ldw	$0,(ix+$sx)
24E2:	pre	ix,&H113B
24E6:	sb	$1,$sz
24E8:	ld	$16,&H02
24EB:	ldd	$0,(ix+$sz)
24ED:	sb	$1,$sy
24EF:	jp	c,&H2AF1	;display character $16
24F2:	ldi	$0,(ix+$sx)
24F4:	sbc	$0,&H21
24F7:	jr	c,&H24ED
24F9:	jp	&H2AE8		;OUTCR, display CR-LF

; initialise the keyboard buffer
24FC:	pre	ix,&H111E
2500:	ld	$0,&H10		;buffer size
2503:	ldw	$1,&H1121	;address of the buffer
2507:	stm	$0,(ix+$sx),3
250A:	jp	&H0379		;clear the keyboard buffer

: expects coordinates of a pressed key in $0 and $1
; $0 contains the bit number of the KI port (1=KI12, 2=KI11, ...)
; $1 contains the KO state (1=KO1, 2=KO2, ...)
250D:	ld	$4,(ix-$sy)	;KANA1
250F:	anc	$4,&H02
2512:	ld	$2,(ix-&H02)	;KEYMD
2515:	gre	ix,$14
2517:	phsw	$15
2519:	pre	ix,&H165C	;ACJMP, jump address for BREAK
251D:	ldw	$14,&H8BDB
2521:	sbcw	(ix+$sx),$14
2523:	ppsw	$14
2525:	pre	ix,$14
2527:	jr	z,&H2553
2529:	ldw	$14,&H0206
252D:	sbcw	$0,$14
2530:	jr	z,&H2572
2532:	ldw	$14,&H0801
2536:	sbcw	$0,$14
2539:	jr	nz,&H2553
253B:	anc	$2,&H80
253E:	jr	nz,&H2545
2540:	cal	&H2594
2543:	jr	&H2575
2545:	phsw	$6
2547:	cal	&H9238		;English or Japanese version?
254A:	ppsw	$5
254C:	jr	z,&H2540	;branch if English
254E:	cal	&H259B
2551:	jr	&H2575
2553:	ldw	$14,&H0201
2557:	sbcw	$0,$14
255A:	jr	z,&H256B
255C:	sbc	$1,$sy
255E:	jr	nz,&H258E
2560:	cal	&H0379		;clear the keyboard buffer
2563:	ld	$0,&H03
2566:	ld	$7,$sx
2568:	jp	&H0555
256B:	cal	&H0379		;clear the keyboard buffer
256E:	ld	$0,&H13,jr &H2566
2572:	cal	&H25A2
2575:	ldw	$3,&H1111
2579:	ldw	$5,($3)
257C:	stw	$30,($3)
257F:	sbc	$5,&H1F
2582:	jr	z,&H2588
2584:	sbc	$6,&H1F
2587:	rtn	nz
2588:	ld	$0,&HDD
258B:	jp	&H0355		;put character $0 to the keyboard buffer

258E:	cal	&H25B2
2591:	jp	&H0471
2594:	an	$2,&H60
2597:	xr	$2,&H40,jr &H25A5
259B:	an	$2,&H60
259E:	xr	$2,&H20,jr &H25A5
25A2:	xr	$2,&H80
25A5:	st	$2,(ix-&H02)
25A8:	phsm	$5,4
25AB:	cal	&H92AC
25AE:	ppsm	$2,4
25B1:	rtn

25B2:	sbc	$0,&H0B
25B5:	jr	z,&H25F3
25B7:	sb	$0,&H01
25BA:	sb	$1,&H02
25BD:	biu	$1
25BF:	ad	$0,$1
25C2:	biu	$1
25C4:	biu	$1
25C6:	ad	$0,$1
25C9:	ldw	$3,&H0F51
25CD:	anc	$2,&H80
25D0:	jr	nz,&H25DF
25D2:	biu	$0
25D4:	anc	$2,&H40
25D7:	jr	z,&H25DB
25D9:	ad	$0,$sy
25DB:	ldw	$3,&H0EB1
25DF:	ld	$1,$sx
25E1:	phs	$5
25E3:	gst	ua,$5
25E5:	pst	ua,&HA4
25E8:	cal	&H0582
25EB:	pst	ua,$5
25ED:	pps	$5
25EF:	cal	&H25F7
25F2:	rtn

25F3:	ld	$0,&HFE
25F6:	rtn
25F7:	phsw	$6
25F9:	cal	&H9238		;English or Japanese version?
25FC:	ppsw	$5
25FE:	rtn	nz		;return if Japanese
25FF:	sbc	$0,&HEB
2602:	jr	nz,&H2608
2604:	ld	$0,&HEA
2607:	rtn
2608:	sbc	$0,&HEA
260B:	rtn	nz
260C:	ld	$0,&HED
260F:	rtn
2610:	cal	&H975E
2613:	cal	&H1D07
2616:	cal	&H2972
2619:	jr	z,&H2620
261B:	sbc	$15,$sx
261D:	jp	nz,&H3438
2620:	pre	iz,&H1000
2624:	sbc	(iz+$sx),$31
2626:	rtn	z
2627:	cal	&H28AF
262A:	cal	&H95D3
262D:	cal	&H0049
2630:	sbc	$0,&H04
2633:	jr	z,&H265E
2635:	sbc	$23,$sy
2637:	jr	z,&H2670
2639:	cal	&H2972
263C:	jr	nz,&H266D
263E:	cal	&H1088
2641:	gfl	$0
2643:	sbc	(iz+$sx),$31
2645:	jr	nz,&H266D
2647:	pfl	$0
2649:	jr	c,&H2658
264B:	cal	&H219A
264E:	phs	$16
2650:	cal	&H2ADB
2653:	pps	$16
2655:	jp	&H97D5
2658:	cal	&H264E
265B:	jp	&H2AE8		;OUTCR, display CR-LF
265E:	ldi	$0,(iz+$sy)
2660:	sb	$0,&H49
2663:	ldw	$3,&H57DE
2667:	cal	&H1183
266A:	sbc	(iz+$sx),$31
266C:	rtn	z
266D:	jp	&H2B70		;SN Error, syntax
2670:	ld	$2,&HAD
2673:	cal	&H00EB
2676:	jp	z,&H2BA8	;FC Error, unrecognized command
2679:	cal	&H2EA2
267C:	jr	&H266A
267E:	pst	ua,&HD4
2681:	cal	&H92EA
2684:	cal	&H939A
2687:	pre	ix,&H110F	;system variable APOCN, APO counter
268B:	ld	$0,&H07
268E:	st	$0,(ix+$sy)
2690:	cal	&H28D4
2693:	cal	&H27B6
2696:	ldw	$0,&H0A40
269A:	pre	ix,&H1113
269E:	stw	$0,(ix+$sx)
26A0:	pre	ix,&H173D
26A4:	ld	$0,$sy
26A6:	ldw	$1,&H02B0
26AA:	stm	$0,(ix+$sx),3
26AD:	pre	ix,&H16B7
26B1:	ldw	$0,&H0050
26B5:	stm	$31,(ix+$sx),3
26B8:	pre	ix,&H1132
26BC:	sbbm	$0,$sz,8
26BF:	stw	$31,(ix+$sx)
26C1:	pre	ix,&H1749
26C5:	stim	$0,(ix+$sx),8
26C8:	stim	$0,(ix+$sx),3
26CB:	stm	$0,(ix+$sx),8
26CE:	ldw	$0,&H168B
26D2:	stw	&H0201,($sz)
26D6:	pst	ua,&H54
26D9:	pre	ix,&H18D3
26DD:	std	$31,(ix+$sx)
26DF:	cal	&H432F
26E2:	cal	&H5294		;IX <- password buffer
26E5:	ld	$0,&HFF
26E8:	std	$0,(ix+$sx)
26EA:	cal	&H9272
26ED:	cal	&H6549
26F0:	ldw	$17,&H2386
26F4:	cal	&H8314		;is the size of the internal RAM 8kB or 32kB?
26F7:	jr	c,&H26FD	;skip if 8kB
26F9:	ldw	$17,&H23D5
26FD:	cal	&H6520		;display a string from bank 2
2700:	ldw	$17,&H2424
2704:	pre	ix,&H18D1
2708:	ldw	$0,(ix+$sx)
270A:	anc	$1,&H10
270D:	jr	z,&H2712
270F:	sb	$1,&H50
2712:	sbc	$1,&H4F
2715:	jr	c,&H2721
2717:	ldw	$17,&H244A
271B:	jr	z,&H2721
271D:	ldw	$17,&H2470
2721:	cal	&H6540
2724:	ldw	$2,&H2734
2728:	cal	&H297A		;BRSTR, set ACJMP
272B:	pre	ix,&H16F0
272F:	std	$31,(ix+$sx)
2731:	cal	&H03A4
2734:	cal	&H2ADF
2737:	cal	&H01D8		;LCD on
273A:	jp	&H1FC3

273D:	ldw	$0,&H2734
2741:	pre	ix,&H165C	;ACJMP, jump address for BREAK
2745:	sbcw	(ix+$sx),$0
2747:	jr	z,&H2752
2749:	ldw	$0,&H2AA4
274D:	sbcw	(ix+$sx),$0
274F:	jp	nz,&H0257
2752:	xr	$10,&H10
2755:	pre	ix,&H1100
2759:	std	$10,(ix+$sx)
275B:	pre	ix,&H16F0
275F:	ldd	$0,(ix+$sx)
2761:	ad	$0,$sy
2763:	std	$0,(ix+$sx)
2765:	anc	$0,$sy
2767:	rtn	nz
2768:	anc	$0,&H02
276B:	jp	nz,&H01D8	;LCD on
276E:	jp	&H01D4		;LCD off
2771:	ldw	$0,&H1100
2775:	st	&H06,($sz)
2778:	cal	&H9774
277B:	jp	&H2ADF

277E:	cal	&H2991		;select the LCD as the output device
2781:	cal	&H340F
2784:	cal	&H360A
2787:	cal	&H29B4		;clear the ANSFG variable
278A:	cal	&H0323
278D:	cal	&H032A
2790:	cal	&H294F
2793:	sbc	$1,&H08
2796:	jr	nz,&H279F
2798:	ldw	$2,&H175C
279C:	ld	$1,($2)
279F:	std	$1,(ix+$sx)
27A1:	st	$31,(ix+&H02)
27A4:	jp	&H46B3

27A7:	ldw	$0,&H4107
27AB:	ldw	$2,&H0080
27AF:	pre	ix,&H1115
27B3:	stm	$0,(ix+$sx),4
27B6:	cal	&H2991		;select the LCD as the output device
27B9:	pre	ix,&H1770
27BD:	ld	$0,$sx
27BF:	stw	$31,(ix+$sx)
27C1:	ppo	&HC0
27C4:	pst	ia,&H40
27C7:	pst	pd,&HCC
27CA:	pst	pe,&HCE
27CD:	pre	ix,&H1895
27D1:	ldiw	$0,(ix+$sx)
27D3:	stiw	$0,(ix+$sx)
27D5:	stw	$0,(ix+$sx)
27D7:	ldw	$0,&H1100
27DB:	st	&H06,($sz)
27DE:	cal	&H9774
27E1:	pre	ix,&H1113
27E5:	ldw	$0,(ix+$sx)
27E7:	an	$0,&H60
27EA:	an	$1,&H02
27ED:	stw	$0,(ix+$sx)
27EF:	cal	&H24FC
27F2:	cal	&H29B4		;clear the ANSFG variable
27F5:	pre	ix,&H16BF
27F9:	sbbm	$0,$sz,8
27FC:	stm	$0,(ix+$sx),8
27FF:	pre	ix,&H173A	;IOSTS
2803:	stm	$0,(ix+$sx),3
2806:	pre	ix,&H16D9
280A:	stim	$0,(ix+$sx),8
280D:	stim	$0,(ix+$sx),8
2810:	stw	$0,(ix+$sx)
2812:	pre	ix,&H110D	;CSRCN, cursor flash counter
2816:	ld	$0,&H5F
2819:	st	$0,(ix+$sy)
281B:	cal	&H3402
281E:	cal	&H046D
2821:	pre	ix,&H1133	;"integer cheating" flag
2825:	std	$31,(ix+$sx)	;enable cheating
2827:	cal	&H360A
282A:	gst	pd,$2
282C:	an	$2,&HFB
282F:	pst	pd,$2
2831:	pst	ua,&H34
2834:	ldw	$0,&HFFF8
2838:	st	$1,($sz)
283A:	ld	$0,&HFC
283D:	st	&H80,($sz)
2840:	ldw	$5,&H0078
2844:	sbw	$5,$sy
2846:	jr	nz,&H2844
2848:	st	&HC0,($sz)
284B:	ld	$4,$sy
284D:	pst	ua,&H54
2850:	pre	ix,&H16BE
2854:	std	$4,(ix+$sx)
2856:	or	$2,&H04
2859:	pst	pd,$2
285B:	gpo	$0
285D:	gpo	$1
285F:	sbc	$1,$sz
2861:	jr	nz,&H285B
2863:	anc	$1,$sy
2865:	pre	ix,&H16ED
2869:	jr	z,&H287B	;branch if low battery level
286B:	ldw	$0,&H0E10
286F:	stm	$31,(ix+$sx),3
2872:	cal	&H01A8
2875:	cal	&H95F7
2878:	jp	&H01DA
287B:	ldw	$2,(ix+$sy)
287D:	ldw	$0,&H0168
2881:	sbcw	$2,$sz
2883:	jp	c,&H2AAD
2886:	jr	&H2872
2888:	pre	ix,&H16C7
288C:	ldiw	$0,(ix+$sx)
288E:	stw	$0,(ix+$sx)
2890:	rtn

2891:	cal	&H28A0		;clear the GOSUB stack
2894:	cal	&H28A6		;clear the FOR stack
2897:	cal	&H28AF
289A:	cal	&H28BC		;BASIC interpreter in the interactive mode
289D:	jp	&H46B3		;close all opened files

; clear the GOSUB stack
28A0:	pre	ix,&H189F
28A4:	jr	&H28AA
; clear the FOR stack
28A6:	pre	ix,&H189D
28AA:	ldw	$0,(ix+$sx)
28AC:	stdw	$1,(ix-$sy)
28AE:	rtn

28AF:	pre	us,&H1CD0
; clear the string operation stack
28B3:	pre	ix,&H1897
28B7:	ldiw	$0,(ix+$sx)
28B9:	stw	$0,(ix+$sx)
28BB:	rtn

28BC:	pre	ix,&H16C6
28C0:	std	$31,(ix+$sx)
28C2:	rtn

28C3:	ad	$1,&H1F
28C6:	sbc	$2,$4
28C9:	jr	nz,&H2901
28CB:	ad	$1,&H60
28CE:	ldw	$2,&H0B1A
28D2:	jr	&H290E
;
28D4:	ldw	$0,&H3000	;starting address of the RAM expansion card
28D8:	cal	&H8314		;is the size of the internal RAM 8kB or 32kB?
28DB:	jr	c,&H28E1	;skip if 8kB
28DD:	ldw	$0,&H8000
; test the RAM location $0,$1
28E1:	slw
28E2:	ld	$2,($sz)
28E4:	ld	$4,$2
28E7:	inv	$2
28E9:	st	$2,($sz)
28EB:	ld	$3,($sz)
28ED:	or	$1,&H40
28F0:	st	$4,($sz)
28F2:	an	$1,&HBF
28F5:	ld	$4,($sz)
28F7:	fst
28F8:	sb	$0,$sy
28FA:	sbc	$2,$3
28FD:	jr	z,&H28C3	;branch if the test passed
; no RAM expansion card detected
28FF:	sb	$1,$sy
2901:	ldw	$2,&H0ADE
2905:	anc	$1,&H10
2908:	jr	z,&H290E
290A:	ldw	$2,&H0B1A
290E:	pre	ix,&H18D1
2912:	stw	$0,(ix+$sx)
2914:	ldw	$0,&H1895	;destination address
2918:	ldw	$4,&H003C	;number of transferred bytes
291C:	cal	&H0EBB		;block transfer from bank 2 to bank 1
291F:	pre	ix,&H18A7
2923:	ldw	$0,(ix+$sx)	;destination address
2925:	ldw	$2,&H0B56	;source address
2929:	ldw	$4,&H0014	;number of transferred bytes
292D:	jp	&H0EBB		;block transfer from bank 2 to bank 1

2930:	pre	ix,&H16C5
2934:	ldd	$1,(ix+$sx)
2936:	rtn

2937:	ld	$0,&H10,jr &H2949
293B:	ld	$0,&H08,jr &H2949
293F:	ld	$0,&H04,jr &H2949
2943:	ld	$0,&H02,jr &H2949
2947:	ld	$0,$sy
2949:	cal	&H2930
294C:	anc	$1,$sz
294E:	rtn
294F:	pre	ix,&H16C4
2953:	ldd	$1,(ix+$sx)
2955:	rtn
2956:	ld	$0,&H80,jr &H2974
295A:	ld	$0,&H40,jr &H2974
295E:	ld	$0,&H20,jr &H2974
2962:	ld	$0,&H10,jr &H2974
2966:	ld	$0,&H08,jr &H2974
296A:	ld	$0,&H04,jr &H2974
296E:	ld	$0,&H02,jr &H2974
2972:	ld	$0,$sy
2974:	cal	&H294F
2977:	anc	$1,$sz
2979:	rtn

; BRSTR:
; set ACJMP, jump address for BREAK
297A:	pre	ix,&H165C	;ACJMP, jump address for BREAK
297E:	stw	$2,(ix+$sx)
2980:	rtn

; select the ??? as the output device
2981:	ld	$0,&H08,jr &H2993
; select the file as the output device
2985:	ld	$0,&H04,jr &H2993
; select the printer as the output device
2989:	ld	$0,&H02,jr &H2993
; select the ??? as the output device
298D:	ld	$0,&H01,jr &H2993
; select the LCD as the output device
2991:	ld	$0,$sx
2993:	pre	ix,&H1739		;OUTDV, output device
2997:	std	$0,(ix+$sx)
2999:	rtn

299A:	pre	ix,&H1739
299E:	ldd	$1,(ix+$sx)
29A0:	rtn

29A1:	pre	ix,&H1131
29A5:	ldd	$1,(ix+$sx)
29A7:	sbc	$1,$sx
29A9:	rtn
29AA:	cal	&H29A1
29AD:	rtn	z
29AE:	cal	&H2AE8		;OUTCR, display CR-LF
29B1:	cal	&H031B		;cursor display enable
29B4:	ldw	$0,&H1131
29B8:	st	$31,($sz)
29BA:	rtn

29BB:	cal	&H032E		;cursor display disable
29BE:	cal	&H29A1
29C1:	rtn	nz
29C2:	jp	&H031B		;cursor display enable

29C5:	ldw	$0,&H16EE	;auto power-off counter
29C9:	ldw	$0,($sz)
29CB:	sbcw	$0,$sy
29CD:	jp	z,&H2AAD	;power off
; test the power switch and BRK key
29D0:	cal	&H03F7		;test the power switch
29D3:	ld	$3,&H03		;counter
29D6:	ld	$0,&H41		;data for the IA register
29D9:	cal	&H0381		;select KO column $0, read KI to $1,$2
29DC:	sbc	$1,$sx		;BRK key?
29DE:	rtn	z		;return if not
29DF:	sb	$3,$sy		;decrement the counter
29E1:	jr	nz,&H29D6	;ensure three times the BRK key is pressed
29E3:	pre	ix,&H1115
29E7:	stm	$0,(ix+$sy),3
29EA:	cal	&H0458
29ED:	cal	&H0241
; BRK key and error handler procedure
29F0:	pst	ua,&H54
29F3:	cal	&H2A0C
29F6:	cal	&H46EE
29F9:	pre	ix,&H1114
29FD:	ldd	$0,(ix+$sx)
29FF:	an	$0,&H42
2A02:	std	$0,(ix+$sx)
2A04:	pre	ix,&H165C	;ACJMP, jump address for BREAK
2A08:	ldw	$0,(ix+$sx)
2A0A:	jp	$0

2A0C:	cal	&H294F
2A0F:	ldd	$2,(ix+$sx)
2A11:	ld	$3,(ix+&H02)
2A14:	an	$3,&H03
2A17:	st	$3,(ix+&H02)
2A1A:	sbc	$2,&H08
2A1D:	jr	nz,&H2A26
2A1F:	ldw	$2,&H175C
2A23:	ld	$2,($2)
2A26:	an	$2,&HC7
2A29:	std	$2,(ix+$sx)
2A2B:	rtn

2A2C:	ldw	$0,&H16C2
2A30:	ld	$0,($sz)
2A32:	sbc	$0,$sx
2A34:	jp	nz,&H03FE
2A37:	ld	$1,&H0A
2A3A:	gpo	$0
2A3C:	anc	$0,$sy
2A3E:	jr	nz,&H2A34	;branch if good battery level
2A40:	sb	$1,$sy
2A42:	jr	nz,&H2A3A
2A44:	pre	ix,&H16C2
2A48:	std	$30,(ix+$sx)
2A4A:	pre	ix,&H16ED
2A4E:	std	$30,(ix+$sx)
2A50:	pre	ss,&H1BD7
2A54:	cal	&H017C		;one-minute timer and ON interrupt disable
2A57:	pst	ua,&H54
2A5A:	cal	&H2991		;select the LCD as the output device
2A5D:	cal	&H340F
2A60:	cal	&H360A
2A63:	cal	&H29B4		;clear the ANSFG variable
2A66:	cal	&H0323
2A69:	cal	&H032A
2A6C:	cal	&H2468
2A6F:	ldw	$17,&H2538
2A73:	cal	&H9238		;English or Japanese version?
2A76:	jr	nz,&H2A7C	;skip if Japanese
2A78:	ldw	$17,&H25BA
2A7C:	cal	&H653D
2A7F:	sbw	$0,$sz
2A81:	pre	ix,&H16C4
2A85:	stm	$31,(ix+$sx),3
2A88:	ldw	$2,&H2AA4
2A8C:	cal	&H297A		;BRSTR, set ACJMP
2A8F:	cal	&H031B		;cursor display enable
2A92:	pre	ix,&H16F0
2A96:	std	$31,(ix+$sx)
2A98:	gst	ie,$4
2A9A:	or	$4,&H40
2A9D:	pst	ie,$4
2A9F:	cal	&H03A4
2AA2:	jr	&H2A9F
2AA4:	cal	&H2ADF
2AA7:	cal	&H01D8		;LCD on
2AAA:	jp	&H1FB9

; power-off
2AAD:	cal	&H994F
2AB0:	pre	ss,&H1BD7
2AB4:	cal	&H017C		;one-minute timer and ON interrupt disable
2AB7:	cal	&H46EE
2ABA:	cal	&H277E
2ABD:	ldw	$3,&H0D2E	;pointer to the minimal contrast data
2AC1:	cal	&H0183		;transfer contrast data to the LCD controller
2AC4:	cal	&H01D4		;LCD off
2AC7:	ldw	$0,&HFFFC
2ACB:	ppo	$31
2ACD:	pst	ie,$31
2ACF:	off
2AD0:	off

; display a decimal number $19,$20 followed by space
2AD1:	ldw	$3,$19
2AD4:	cal	&H20FC		;display a decimal number $3,$4
; display a space
2AD7:	ld	$16,&H20,jr &H2AF1
2ADB:	ld	$16,&H05,jr &H2AF1
; command CLS, prefix 4, code &H71
2ADF:	ld	$16,&H0C,jr &H2AF1

2AE3:	cal	&H031D
2AE6:	jr	&H2AF4

; OUTCR:
2AE8:	ld	$16,&H0D
2AEB:	cal	&H2AF1
2AEE:	ld	$16,&H0A
; display a character $16 on the OUTDV device
2AF1:	cal	&H0330
2AF4:	pre	ix,&H1739	;OUTDV, output device
2AF8:	ldd	$0,(ix+$sx)
2AFA:	sbc	$0,&H02
2AFD:	jp	c,&H93E2	;OUTDV=&H00 or &H01, LCD
2B00:	gre	iz,$12
2B02:	phsm	$15,4
2B05:	jr	z,&H2B24	;OUTDV=&H02, printer
2B07:	sbc	$0,&H08
2B0A:	jr	z,&H2B2D	;OUTDV=&H08, ???
; OUTDV=&H04, file
2B0C:	cal	&H482E		;write a byte $16 to the I/O data buffer
2B0F:	cal	&H2B44
2B12:	sbc	$16,&H0D
2B15:	jr	z,&H2B29
2B17:	sbc	$16,&H20
2B1A:	jr	c,&H2B1E	;skip control codes (less than &H20)
2B1C:	ad	(ix+$sx),$30
2B1E:	ppsm	$12,4
2B21:	pre	iz,$12
2B23:	rtn
; OUTDV=&H02, printer
2B24:	cal	&H89A9		;PROUT, print a character $16 on the printer
2B27:	jr	&H2B0F

2B29:	std	$31,(ix+$sx)
2B2B:	jr	&H2B1E

; OUTDV=&H08, ???
2B2D:	cal	&H2B3D
2B30:	cal	z,&H89A9
2B33:	cal	&H93E2
2B36:	cal	&H2B3D
2B39:	jr	z,&H2B0F
2B3B:	jr	&H2B1E
2B3D:	pre	ix,&H173B
2B41:	sbc	(ix+$sx),$30
2B43:	rtn
2B44:	pre	ix,&H1739
2B48:	ldd	$0,(ix+$sx)
2B4A:	anc	$0,&H0A
2B4D:	jr	nz,&H2B57
2B4F:	pre	ix,&H1770
2B53:	ldd	$0,(ix+&H1B)
2B56:	rtn
2B57:	pre	ix,&H173C
2B5B:	ldd	$0,(ix+$sx)
2B5D:	rtn

2B5E:	pre	ix,&H16BF	;OPTCD, option code
2B62:	std	$30,(ix+$sx)
2B64:	cal	&H808D		;reset the FDD
2B67:	ld	$15,&H0B	;LB Error, low batteries in the FDD
2B6A:	jp	&H2BEA

2B6D:	ld	$15,$sy,jr &H2BEA	;OM Error, insufficient memory
2B70:	ld	$15,&H02,jr &H2BEA	;SN Error, syntax
2B74:	ld	$15,&H03,jr &H2BEA	;ST Error, string too long
2B78:	ld	$15,&H04,jr &H2BEA	;TC Error, formula too complex
2B7C:	ld	$15,&H05,jr &H2BEA	;BV Error, buffer overflow
2B80:	ld	$15,&H06,jr &H2BEA	;NR Error, I/O device not ready
2B84:	ld	$15,&H07,jr &H2BEA	;RW Error, I/O device operation error
2B88:	ld	$15,&H08,jr &H2BEA	;BF Error, improper filename
2B8C:	ld	$15,&H09,jr &H2BEA	;BN Error, improper file handle
2B90:	ld	$15,&H0A,jr &H2BEA	;NF Error, file not found
2B94:	ld	$15,&H0C,jr &H2BEA	;FL Error, disk write error
2B98:	ld	$15,&H0D,jr &H2BEA	;OV Error, overflow
2B9C:	ld	$15,&H0E,jr &H2BEA	;MA Error, mathematical error
2BA0:	ld	$15,&H0F,jr &H2BEA	;DD Error, double array declaration
2BA4:	ld	$15,&H10,jr &H2BEA	;BS Error, subscript out of range
; unsupported commands and ERROR, prefix 4, code &H86
2BA8:	ld	$15,&H11,jr &H2BEA	;FC Error, unrecognized command
2BAC:	ld	$15,&H12,jr &H2BEA	;UL Error, BASIC line number
2BB0:	ld	$15,&H13,jr &H2BEA	;TM Error, mismatch of variable type
2BB4:	ld	$15,&H14,jr &H2BEA	;RE Error, misplaced RESUME
2BB8:	ld	$15,&H15,jr &H2BEA	;PR Error, password
2BBC:	ld	$15,&H16,jr &H2BEA	;DA error, no data for READ
2BC0:	ld	$15,&H17,jr &H2BEA	;FO error, NEXT without FOR
2BC4:	ld	$15,&H18,jr &H2BEA	;NX error, FOR without NEXT
2BC8:	ld	$15,&H19,jr &H2BEA	;GS Error, mismatched GOSUB/RETURN
2BCC:	cal	&H808D			;reset the FDD
2BCF:	ld	$15,&H1A,jr &H2BEA	;FM Error, bad disk
2BD3:	ld	$15,&H1B,jr &H2BEA	;FD Error, FIELD too long
2BD7:	ld	$15,&H1C,jr &H2BEA	;OP Error, OPEN
2BDB:	ld	$15,&H1D,jr &H2BEA	;AM Error, file access
2BDF:	ld	$15,&H1E,jr &H2BEA	;FR Error, framing error
2BE3:	ld	$15,&H1F,jr &H2BEA	;PO Error, parity or overrun error
2BE7:	ld	$15,&H20		;DF Error, abnormality in the FDD
2BEA:	pst	ua,&H54
2BED:	cal	&H295E
2BF0:	cal	nz,&H46EE
2BF3:	cal	&H2947
2BF6:	cal	z,&H2991	;select the LCD as the output device
2BF9:	pre	ix,&H16BA
2BFD:	ldw	$0,&H6641
2C01:	sbcw	(ix+$sx),$0
2C03:	cal	nz,&H2991	;select the LCD as the output device
2C06:	pre	ix,&H1134	;ERRN
2C0A:	std	$15,(ix+$sx)
2C0C:	cal	&H294F
2C0F:	an	$1,&HCF
2C12:	std	$1,(ix+$sx)
2C14:	ldiw	$2,(ix+$sy)
2C16:	an	$3,&H03
2C19:	std	$3,(ix-$sy)
2C1B:	pre	ix,&H1557
2C1F:	std	$31,(ix+$sx)
2C21:	ld	$18,$15
2C24:	sbc	$1,&H40
2C27:	jp	z,&HFFDC
2C2A:	sbc	$1,$sx
2C2C:	jr	nz,&H2C37
2C2E:	anc	$2,$sy
2C30:	jr	nz,&H2C89
2C32:	sbc	$2,&H02
2C35:	jr	z,&H2C92
2C37:	anc	$1,&H02
2C3A:	jr	nz,&H2C92
2C3C:	pre	ix,&H16C9
2C40:	ldm	$12,(ix+$sx),6
2C43:	cal	&H504A
2C46:	jr	z,&H2C6D
2C48:	pre	ix,&H16E3
2C4C:	stm	$14,(ix+$sx),5
2C4F:	pre	ix,&H16DF
2C53:	ldim	$4,(ix+$sx),8
2C56:	sbc	(ix+$sy),$30
2C58:	jr	nc,&H2C6D
2C5A:	sbcw	$6,$sy
2C5C:	jr	c,&H2C6D
2C5E:	sbcw	$4,$12
2C61:	jr	nz,&H2C6D
2C63:	st	$30,(ix+$sy)
2C65:	cal	&H2A0C
2C68:	pre	iz,$6
2C6A:	jp	&H3559
2C6D:	pst	ua,&H54
2C70:	cal	&H2D0A
2C73:	cal	&H3B23
2C76:	cal	&H2966
2C79:	jp	nz,&H2F89
2C7C:	an	$1,$sy
2C7E:	std	$1,(ix+$sx)
2C80:	cal	&H28BC
2C83:	cal	&H46EE
2C86:	jp	&H1FB9
2C89:	pre	ix,&H16BA
2C8D:	ldm	$0,(ix+$sx),8
2C90:	jp	$0
2C92:	pre	ss,&H1BD7
2C96:	cal	&H5D57
2C99:	cal	&H2CEF
2C9C:	pst	ua,&H04
2C9F:	pre	ix,&H2D47
2CA3:	ldm	$10,(ix+$sx),6
2CA6:	pst	ua,&H54
2CA9:	pre	ix,&H151C
2CAD:	stm	$8,(ix+$sx),8
2CB0:	cal	&H5D1E
2CB3:	cal	&H032E		;cursor display disable
2CB6:	pre	us,&H1CC3
2CBA:	ppum	$17,5
2CBD:	ppum	$22,8
2CC0:	ldw	$2,&H9F5C
2CC4:	cal	&H9937
2CC7:	cal	nz,&H297A	;BRSTR, set ACJMP
2CCA:	cal	&H0379		;clear the keyboard buffer
2CCD:	cal	&H03A4
2CD0:	ld	$2,$sz
2CD2:	cal	&H9937
2CD5:	jp	nz,&H97E4
2CD8:	cal	&H294F
2CDB:	ld	$0,&H02
2CDE:	sbcw	(ix+$sx),$31
2CE0:	jp	z,&H6A4F
2CE3:	ld	$0,$2
2CE6:	cal	&H23E5
2CE9:	cal	&H031B		;cursor display enable
2CEC:	jp	&H5B71
2CEF:	ld	$15,$18
2CF2:	sbc	$15,&H21
2CF5:	jr	c,&H2CF9
2CF7:	ld	$15,$sx
2CF9:	gst	ua,$0
2CFB:	pst	ua,&HA4
2CFE:	pre	ix,&H0A9C
2D02:	biu	$15
2D04:	ldw	$8,(ix+$15)
2D07:	pst	ua,$0
2D09:	rtn
2D0A:	cal	&H3C65
2D0D:	cal	&H2CEF
2D10:	ldw	$16,$8
2D13:	cal	&H2AF1		;display character $16
2D16:	bydw	$17
2D18:	cal	&H2AF1		;display character $16
2D1B:	cal	&H2D2C
2D1E:	cal	&H504A
2D21:	jr	z,&H2D29
2D23:	cal	&H2D71
2D26:	cal	&H2D8E
2D29:	jp	&H2AE8		;OUTCR, display CR-LF
2D2C:	ldw	$15,&H2D46
2D30:	jr	&H2D61

2D32:	db	&H06, "Ready "
2D39:	db	&H06, "Break "
2D40:	db	&H05, "STOP "
2D46:	db	&H07, " error "

2D4E:	ldw	$17,&H2D40	;string 'error'
2D52:	jr	&H2D5A
2D54:	ldw	$17,&H2D39	;string 'Break'
2D58:	jr	&H2D5A
2D5A:	phsw	$18
2D5C:	cal	&H3C65
2D5F:	ppsw	$15
2D61:	jp	&H97B4

2D64:	ldw	$17,&H2D32	;string 'Ready'
2D68:	cal	&H2D5A
2D6B:	cal	&H2D71
2D6E:	jp	&H2AE8		;OUTCR, display CR-LF

2D71:	ld	$16,&H50	;'P'
2D74:	cal	&H2AF1		;display character $16
2D77:	pre	ix,&H16C9
2D7B:	ldw	$2,(ix+$sx)
2D7D:	ldw	$0,&H18A7	;table of file addresses
2D81:	sbw	$2,$sz
2D83:	ld	$16,$2
2D86:	bid	$16
2D88:	or	$16,&H30
2D8B:	jp	&H2AF1		;display character $16
2D8E:	ld	$16,&H2D	;'-'
2D91:	cal	&H2AF1		;display character $16
2D94:	pre	ix,&H16CB
2D98:	ldw	$3,(ix+$sx)
2D9A:	pre	ix,&H165E
2D9E:	ld	$13,$sx
2DA0:	cal	&H50B4
2DA3:	cal	&H1438
2DA6:	jp	&H97D5

2DA9:	cal	&H2991		;select the LCD as the output device
2DAC:	cal	&H46EE
2DAF:	cal	&H2D54
2DB2:	cal	&H2D1E
2DB5:	jp	&H1FB9
2DB8:	cal	&H2972
2DBB:	jr	nz,&H2DC4
2DBD:	cal	&H6114
2DC0:	jr	nz,&H2DC4
2DC2:	sbc	(ix+$sy),$31
2DC4:	jp	nz,&H2002
2DC7:	pre	ss,&H1BD7
2DCB:	pst	ua,&H54
2DCE:	cal	&H28BC
2DD1:	cal	&H277E
2DD4:	cal	&H2771
2DD7:	pre	ix,&H18A1
2DDB:	ldm	$0,(ix+$sx),4
2DDE:	pre	ix,$0
2DE0:	sbcw	$2,$sz
2DE2:	jr	z,&H2DF1
2DE4:	ldw	$0,(ix+$sx)
2DE6:	an	$0,&H9F
2DE9:	stiw	$0,(ix+$sx)
2DEB:	ldiw	$0,(ix+$1)
2DEE:	gre	ix,$0,jr &H2DE0
2DF1:	ldw	$2,&H1FB0
2DF5:	cal	&H297A		;BRSTR, set ACJMP
2DF8:	cal	&H246E
2DFB:	cal	&H9774
2DFE:	pre	ix,&H18D3
2E02:	pre	iz,&H1793	;data buffer
2E06:	ldi	$0,(ix+$sx)
2E08:	sbc	$0,$sy
2E0A:	jp	c,&H1FB9
2E0D:	cal	&H2E8E
2E10:	jp	z,&H2B70	;SN Error, syntax
2E13:	sti	$0,(iz+$sx)
2E15:	ldi	$0,(ix+$sx)
2E17:	cal	&H2E8B
2E1A:	jr	nz,&H2E13
2E1C:	ldd	$0,(ix-$sy)
2E1E:	std	$31,(iz+$sx)
2E20:	gre	ix,$0
2E22:	phsw	$1
2E24:	cal	&H9753		;INCLR, clear the INTOP input buffer
2E27:	pre	iz,&H1793	;data buffer
2E2B:	cal	&H1D07
2E2E:	ldw	$0,&H1793	;data buffer
2E32:	pre	iz,$0		;destination address
2E34:	ldw	$2,&H1000	;source address
2E38:	ldw	$4,&H0100	;number of bytes
2E3C:	cal	&H014C		;block transfer within the RAM
2E3F:	ld	$0,&H10
2E42:	cal	&H2F70
2E45:	cal	&H0049
2E48:	sbc	$0,&H04
2E4B:	jr	z,&H2E10
2E4D:	cal	&H28AF
2E50:	cal	&H2635
2E53:	pre	ix,&H16C4
2E57:	std	$31,(ix+$sx)
2E59:	cal	&H29C5		;test the power switch and BRK key
2E5C:	cal	&H29A1
2E5F:	jr	z,&H2E72
2E61:	cal	&H29BB
2E64:	cal	&H2002
2E67:	cal	&H0310
2E6A:	jr	nz,&H2E80
2E6C:	cal	&H9774
2E6F:	cal	&H29AA
2E72:	ppsw	$0
2E74:	pre	ix,$0
2E76:	ldi	$0,(ix+$sx)
2E78:	sbc	$0,&H3A
2E7B:	jp	nz,&H2DD7
2E7E:	jr	&H2E02
2E80:	cal	&H2610
2E83:	cal	&H29A1
2E86:	jr	nz,&H2E61
2E88:	jp	&H1FB9
2E8B:	sbc	$0,$sx
2E8D:	rtn	z
2E8E:	sbc	$0,&H3A
2E91:	rtn	z
2E92:	sbc	$0,&H3B
2E95:	rtn
2E96:	sb	$20,$sy
2E98:	rtn	c
2E99:	ld	$16,($21)
2E9C:	cal	&H2AF1		;display character $16
2E9F:	adw	$21,$sy,jr &H2E96

; command LET, prefix 4, code &H8F
2EA2:	cal	&H2F01
2EA5:	cal	&H00E3
2EA8:	pre	ix,&H167E
2EAC:	ldm	$0,(ix+$sx),5
2EAF:	phsm	$4,5
2EB2:	sbc	$1,$sx
2EB4:	jr	lz,&H2EFC
2EB6:	cal	&H112F
2EB9:	ppsm	$3,5
2EBC:	pre	ix,&H167E
2EC0:	stm	$3,(ix+$sx),5
2EC3:	cal	&H2962
2EC6:	jp	z,&H31AD
2EC9:	ldm	$19,$4,4
2ECC:	sbc	$19,&H08
2ECF:	jp	nz,&H31AD
2ED2:	phsm	$18,8
2ED5:	phs	$10
2ED7:	phsm	$22,4
2EDA:	cal	&H31AD
2EDD:	cal	&H2ADB
2EE0:	ppsm	$19,4
2EE3:	cal	&H2E96
2EE6:	ld	$16,&H3D	;'='
2EE9:	cal	&H2AF1		;display character $16
2EEC:	ppsm	$10,8
2EEF:	pps	$18
2EF1:	sbc	(iz+$sx),$31
2EF3:	jp	nz,&H2B70	;SN Error, syntax
2EF6:	cal	&H219A
2EF9:	jp	&H97D5
2EFC:	cal	&H11D2		;evaluate a string expression
2EFF:	jr	&H2EB9

; *** BASIC variables ***

; structure of the BASIC variable work area
; &H167E: DS 1	;VAR1, number of dimensions for an indexed variable
; &H167F: DS 1	;VAR2, variable type
		;bit 3 set if numerical variable, cleared if string variable
		;bit 7 set if indexed variable
; &H1680: DS 1	;VAR3, variable name length
; &H1681: DS 2	;VAR4, pointer to the variable name

; structure of the variable table entry
;	DS 1	;variable type
		;bit 3 set if numerical variable, cleared if string variable
		;bit 5 set if the contents of the variable is defined
		;bit 7 set if an array
;	DS 1	;variable name length
;	DS n	;variable name string
;	DS 2	;pointer to the variable contents

; variable specification -> variable work area VAR1..VAR4
2F01:	cal	&H2F0C		;parse for a variable specification
2F04:	pre	ix,&H167E	;variable work area VAR1..VAR4
2F08:	stm	$12,(ix+$sx),5
2F0B:	rtn

; parse the command string pointed to by IZ for a variable specification
; returns:
; $15,$16 points to the variable name,
; $14 = variable name length,
; $13 = variable type,
; $12 = number of dimensions for an indexed variable,
; list of indexes on the User Stack
2F0C:	cal	&H2F5D		;parse for a variable name and type
2F0F:	ld	$12,$sx		;number of dimensions = 0
2F11:	anc	$13,&H80	;an indexed variable?
2F14:	rtn	z		;return if not
2F15:	phsm	$16,5
2F18:	cal	&H0EDF		;evaluate the index to an integer in $15,$16
2F1B:	ldw	$19,&H0002	;required free space on the user stack
2F1F:	cal	&H11B2		;check the user stack space
2F22:	phuw	$16		;push the index to the User Stack
2F24:	pps	$12
2F26:	ad	$12,$sy		;increment the number of dimensions
2F28:	phs	$12
2F2A:	cal	&H00C3		;test for a comma
2F2D:	jr	z,&H2F18	;loop for multidimension arrays
2F2F:	cal	&H00C7		;test for ')', SN Error if not found
2F32:	ppsm	$12,5
2F35:	rtn

; parse the command string pointed to by IZ for a variable name and type
; returns Carry cleared if no name variable found,
; otherwise returns Carry set and:
; $15,$16 points to the variable name,
; $14 = variable name length,
; $13 = variable type
2F36:	cal	&H0049		;NEXTC, get next character other than space
2F39:	gre	iz,$15
2F3B:	cal	&H318E		;parse for a variable name
2F3E:	sbc	$14,$sx		;test the variable name length for 0
2F40:	rtn	z		;return with Carry cleared if no name found
2F41:	ld	$13,&H08	;bit 3 set - numerical variable
2F44:	sbc	$0,&H24		;'$'
2F47:	jr	nz,&H2F4D
; process with a string variable
2F49:	ldd	$0,(iz+$sy)
2F4B:	ld	$13,$sx		;bit 3 cleared - string variable
2F4D:	cal	&H0049		;NEXTC, get next character other than space
2F50:	sbc	$0,&H28		;'('
2F53:	jr	nz,&H2F5A
; process with an indexed variable
2F55:	ldd	$0,(iz+$sy)
2F57:	or	$13,&H80	;bit 7 set - indexed variable
2F5A:	sbc	$31,$sy		;set Carry
2F5C:	rtn

2F5D:	cal	&H2F36		;parse for a variable name and type
2F60:	rtn	c
2F61:	jp	&H2B70		;SN Error, syntax

2F64:	pre	ix,&H175C
2F68:	ldim	$0,(ix+$sx),7
2F6B:	pre	iz,$5
2F6D:	ldm	$1,(ix+$sx),5
2F70:	pre	ix,&H16C4
2F74:	std	$0,(ix+$sx)
2F76:	rtn

2F77:	pre	ix,&H1101
2F7B:	ldd	$0,(ix+$sx)	;EDCSR, cursor position
2F7D:	st	$0,(ix+&H04)	;MOEDB, logical line top at the time of INPUT
2F80:	cal	&H29BB
2F83:	cal	&H2002
2F86:	jp	&H975E

2F89:	pre	ix,&H175C
2F8D:	ldim	$5,(ix+$sx),8
2F90:	pre	ss,$6
2F92:	sbc	$5,&H10
2F95:	jr	z,&H2F9E
2F97:	pre	ix,&H16C4
2F9B:	std	$5,(ix+$sx)
2F9D:	rtn

2F9E:	ldm	$15,(ix+$sx),8
2FA1:	ld	$18,$sy
2FA3:	pre	us,$8,jr &H2FC9

; ask the user for the variable contents
2FA6:	ld	$12,$sx
2FA8:	ldm	$19,$13,4
2FAB:	ld	$18,$sy
2FAD:	ldw	$0,&H16C4	;MODE sytem variable
2FB1:	ld	$5,($sz)
2FB3:	st	&H08,($sz)	;INPUT mode
2FB6:	gre	ss,$6
2FB8:	gre	us,$8
2FBA:	gre	iz,$10
2FBC:	pre	ix,&H175C	;INPST
2FC0:	stim	$5,(ix+$sx),8
2FC3:	stim	$13,(ix+$sx),4
2FC6:	stm	$19,(ix+$sx),4
2FC9:	cal	&H2E96		;display a string pointed to by $21,$22
2FCC:	ld	$16,&H3F	;'?'
2FCF:	sbc	$18,$sy
2FD1:	cal	z,&H2AF1	;display character $16
2FD4:	cal	&H2F77
; determine in $17,$18 the length of the typed line (terminated by 0)
2FD7:	sbw	$17,$17
2FDA:	gre	iz,$15
2FDC:	ldi	$0,(iz+$sx)
2FDE:	sbc	$0,$sx
2FE0:	jr	z,&H2FE5
2FE2:	adw	$17,$sy,jr &H2FDC
;
2FE5:	pre	iz,$15
2FE7:	pre	ix,&H1764
2FEB:	sbc	(ix+$sx),$31
2FED:	jr	nlz,&H2FF6
2FEF:	sb	$18,$sy
2FF1:	jp	nc,&H2B74	;ST Error, string too long
2FF4:	jr	&H3020
2FF6:	sbcw	$17,$sy
2FF8:	jr	nc,&H3013
2FFA:	ldm	$12,(ix-$sy),5
2FFD:	cal	&H305E
3000:	pre	ix,$19
3002:	ldd	$0,(ix+$sx)
3004:	or	$0,&H20
3007:	std	$0,(ix+$sx)
3009:	cal	&H2F64
300C:	phsm	$18,8
300F:	phs	$10
3011:	jr	&H3032
3013:	cal	&H1D07		;parser
3016:	pre	iz,&H1000
301A:	cal	&H112F		;EXPRW, evaluate numerical expression
301D:	cal	&H0093		;SN Error if not an end of a BASIC line
3020:	cal	&H2F64
3023:	pre	ix,&H167E	;variable work area VAR1..VAR4
3027:	stm	$1,(ix+$sx),5
302A:	phsm	$18,8
302D:	phs	$10
302F:	cal	&H31AD
3032:	cal	&H95D3
3035:	pps	$10
3037:	ppsm	$11,8
303A:	sbc	$31,$sx		;Zero flag
303C:	rtn

303D:	cal	&H2F5D		;parse for a variable name and type
3040:	sbc	$13,$sx		;test the variable type
3042:	jp	nlz,&H2BB0	;TM Error, mismatch of variable type
3045:	cal	&H2962		;CALC mode?
3048:	jr	z,&H305B	;skip if not
304A:	sbc	$13,&H08	;variable type
304D:	jr	nz,&H305B	;skip if a numerical variable
304F:	cal	&H31A4		;search the BASIC variable name area
3052:	jp	nc,&H2FA6	;ask for the variable contents if not found
3055:	anc	$13,&H20	;variable type, is the variable defined?
3058:	jp	z,&H2FA6	;ask for the variable contents if not
305B:	cal	&H2F0F
305E:	cal	&H31A4		;search the BASIC variable name area
3061:	jr	c,&H306B	;branch if not found
3063:	sbc	$12,$sx		;number of dimensions
3065:	jp	nz,&H2BA8	;FC Error, unrecognized command
3068:	cal	&H324D		;create the variable
306B:	sbc	$12,$sx
306D:	pre	ix,$21
306F:	jr	z,&H30C8
3071:	ldd	$5,(ix+$sx)
3073:	sbc	(ix+$sx),$12
3075:	jp	nz,&H2BA4	;BS Error, subscript out of range
3078:	phs	$12
307A:	sbw	$2,$2
307D:	ldw	$15,$sy
307F:	biu	$5
3081:	ad	$5,$sy
3083:	ldd	$0,(ix+$5)
3086:	ppuw	$5
3088:	ldw	$7,$5
308B:	phsw	$16
308D:	cal	&H0A30		;integer multiplication $5,$6*$15,$16 -> $0,$1
3090:	ppsw	$15
3092:	adw	$2,$sz
3094:	lddw	$6,(ix-$sy)
3096:	sbcw	(ix+$sx),$7
3098:	jp	c,&H2BA4	;BS Error, subscript out of range
309B:	sb	$12,$sy
309D:	jr	z,&H30A7
309F:	adw	$5,$sy
30A1:	cal	&H0A30		;integer multiplication $5,$6*$15,$16 -> $0,$1
30A4:	ldw	$15,$sz,jr &H3086
30A7:	pps	$12
30A9:	biu	$12
30AB:	ad	$12,$sy
30AD:	pre	ix,$21
30AF:	ldd	$0,(ix+$12)
30B2:	sbc	$13,$sx
30B4:	jr	lz,&H30D8
30B6:	anc	$3,&HE0
30B9:	jp	nz,&H2B98	;OV Error, overflow
30BC:	biuw	$2
30BE:	biuw	$2
30C0:	biuw	$2
30C2:	gre	ix,$0
30C4:	adw	$2,$sz
30C6:	pre	ix,$2
30C8:	gre	ix,$21
30CA:	anc	$13,&H40
30CD:	jr	nz,&H30E2
30CF:	sbc	$13,$sx
30D1:	jr	nlz,&H30E9
30D3:	ldi	$17,(ix+$sx)
30D5:	gre	ix,$15
30D7:	rtn
30D8:	sbw	$2,$sy
30DA:	jr	c,&H30C8
30DC:	ldi	$0,(ix+$sx)
30DE:	ldd	$1,(ix+$sz)
30E0:	jr	&H30D8
30E2:	ldm	$14,(ix+$sy),3
30E5:	ld	$17,$14
30E8:	rtn
30E9:	ldm	$10,(ix+$sx),8
; convert the floating point number from the compact 8-byte format to the
; expanded 9-byte format
30EC:	ld	$18,$sx
30EE:	dium	$16,3
30F1:	did	$16
30F3:	rtn

; calculate the size of the variable/array contents in $9,$10
; expects the variable type in $13, number of dimensions for an array in $12,
; list of maximum values of indexes on the User Stack
30F4:	anc	$13,&H80	;variable type
30F7:	jr	nz,&H3102	;branch for an array
30F9:	ldw	$9,$sy		;size of an empty string
30FB:	sbc	$13,$sx		;variable type
30FD:	rtn	lz		;return for a string variable
; numeric variable
30FE:	ld	$9,&H08
3101:	rtn
; array
3102:	phsm	$16,5
3105:	gre	us,$28
; calculate the number of elements (product of all dimension sizes)
3107:	ldw	$15,$sy		;product initial value = 1
3109:	ppuw	$5		;maximum value of an index
310B:	adw	$5,$sy		;dimension size
310D:	jp	z,&H2BA4	;BS Error, subscript out of range
3110:	cal	&H0A30		;integer multiplication $5,$6*$15,$16 -> $0,$1
3113:	ldw	$15,$sz
3115:	sb	$12,$sy		;counter of dimensions
3117:	jr	nz,&H3109	;next dimension
3119:	pre	us,$28
311B:	ppsm	$12,5
311E:	sbc	$13,$sx		;variable type
3120:	jr	lz,&H312D	;skip for a string array
; numeric array: multiply the number of elements by a fixed value size of 8
; bytes
3122:	anc	$1,&HE0
3125:	jr	nz,&H3139	;OM Error if more than 8191 elements
3127:	biuw	$0
3129:	biuw	$0
312B:	biuw	$0
; include the space for the array header: number of dimensions (byte) and the
; list of maximum values of indexes (words)
312D:	ld	$9,$12		;number of dimensions
3130:	biu	$9		;*2
3132:	ad	$9,$sy		;+1
3134:	ld	$10,$sx
3136:	adw	$9,$sz
3138:	rtn	nc
3139:	jp	&H2B6D		;OM Error, insufficient memory

; store the array header
; expects the pointer to the array contents in $21,$22, number of dimensions
; in $12, list of maximum values of indexes on the User Stack
313C:	pre	ix,$21
313E:	std	$12,(ix+$sx)	;number of dimensions
3140:	ld	$0,$12
3143:	ld	$1,$sz
3145:	biu	$0
3147:	ldi	$2,(ix+$sz)	;IX <- IX + 2*number_of_dimensions + 1
3149:	ppuw	$2
314B:	stdw	$3,(ix-$sy)	;maximum value of an index
314D:	sb	$1,$sy		;counter of dimensions
314F:	jr	nz,&H3149	;next dimension
3151:	ldd	$1,(ix+$sz)	;IX <- IX + 2*number_of_dimensions
3153:	gre	ix,$21		;$21,$22 points to the end of the array header
3155:	rtn

; returns in $0,$1 and $15,$16 the number of elements for an array (product of
; all dimension sizes)
; expects the number of dimensions in $24, and the pointer to the variable
; contents in IX
3156:	ld	$4,$24
3159:	ldw	$15,$sy		;product initial value = 1
315B:	ldiw	$5,(ix+$sx)
315D:	adw	$5,$sy		;dimension size
315F:	cal	&H0A30		;integer multiplication $5,$6*$15,$16 -> $0,$1
3162:	ldw	$15,$sz
3164:	sb	$4,$sy		;counter of dimensions
3166:	jr	nz,&H315B	;next dimension
3168:	rtn

; returns in $17,$18 the pointer to the end of the contents of an array,
; expects the pointer to the variable table entry in $19,$20, and the pointer
; to the beginning of the contents in $21,$22
3169:	pre	ix,$21		;pointer to the variable contents
316B:	ldi	$24,(ix+$sx)	;number of dimensions
316D:	cal	&H3156		;$0,$1 <- number of elements
3170:	ld	$2,($19)	;variable type
3173:	sbc	$2,$sx
3175:	jr	nlz,&H3183	;branch if a numeric variable
; string variable: sum up the sizes of all values
3177:	ldi	$2,(ix+$sx)	;$2 <- value size
3179:	ldd	$2,(ix+$2)	;IZ <- IZ + value_size
317C:	sbw	$0,$sy		;counter of values
317E:	jr	nz,&H3177	;next value
3180:	gre	ix,$17
3182:	rtn
; numeric array: multiply the number of elements by a fixed value size of 8
; bytes
3183:	biuw	$0
3185:	biuw	$0
3187:	biuw	$0
3189:	gre	ix,$17
318B:	adw	$17,$sz
318D:	rtn

; parse the command string pointed to by IZ for a variable name
; returns the variable name length in $14
318E:	ld	$14,$sx		;clear the variable name length
3190:	cal	&H00AB		;OKAM1, is $0 a letter?
3193:	jr	c,&H3199	;branch if so
3195:	cal	&H0098		;is $0 in range &HA0..&HDF?
3198:	rtn	nc		;return if not
3199:	ldd	$0,(iz+$sy)	;next character
; subsequent variable name characters can be digits as well
319B:	ad	$14,$sy		;increment the variable name length
319D:	cal	&H002B		;OKNM1, is $0 a digit?
31A0:	jr	c,&H3199	;test the next character if so
31A2:	jr	&H3190

; search the BASIC variable name area for a specified name of length in $14,
; pointed to by $15,$16, variable type in $13
; returns Carry cleared if not found,
; otherwise returns: actual variable type in $13,
; pointer to the variable table entry in $19,$20,
; pointer to the variable contents in $21,$22
31A4:	gre	iz,$2
31A6:	pre	ix,&H18A1
31AA:	jp	&H0B20

31AD:	cal	&H31B3
31B0:	jp	&H014C		;block transfer within the RAM
31B3:	phsm	$17,8
31B6:	phs	$18
31B8:	pre	ix,&H167E	;variable work area VAR1..VAR4
31BC:	ldm	$12,(ix+$sx),5
31BF:	cal	&H305E
31C2:	pps	$18
31C4:	ppsm	$10,8
31C7:	pre	ix,$19
31C9:	ldd	$0,(ix+$sx)
31CB:	an	$0,&H9F
31CE:	or	$0,&H20
31D1:	std	$0,(ix+$sx)
31D3:	pre	ix,$21
31D5:	jr	nlz,&H31FC
31D7:	ldd	$18,(ix+$sx)
31D9:	phs	$17
31DB:	sb	$17,$18
31DE:	jr	z,&H31E7
31E0:	ld	$18,$sx
31E2:	jr	c,&H31F5
31E4:	cal	&H32C8		;expand the string variables contents area
31E7:	pps	$4
31E9:	pre	ix,$21
31EB:	sti	$4,(ix+$sx)
31ED:	ld	$5,$sx
31EF:	gre	ix,$0
31F1:	ldw	$2,$15
31F4:	rtn
31F5:	cmp	$17
31F7:	cal	&H32AE		;shrink the string variables contents area
31FA:	jr	&H31E7
; convert the floating point number from the expanded 9-byte format to the
; compact 8-byte format
31FC:	diu	$16
31FE:	didm	$18,3
3201:	stm	$10,(ix+$sx),8
3204:	ppsw	$0
3206:	rtn

; allocate memory for a variable/array
; expects the variable type in $13, number of dimensions for an array in $12,
; size of the variable contents in $8,$9
3207:	ldw	$17,$9		;data size
320A:	sbc	$13,$sx		;variable type
320C:	jr	lz,&H323E	;branch if a string variable
; numeric variable
320E:	ldw	$23,&H189F
3212:	ldw	$21,($23)	;TONDT
3215:	cal	&H332A		;expand the variables contents area
3218:	ldw	$21,($23)	;TONDT
321B:	phsm	$14,8
321E:	phsm	$22,8
3221:	sbc	$12,$sx		;number of dimensions
3223:	jr	z,&H3249	;branch if not an array
; array
3225:	cal	&H313C		;store the array header
3228:	ld	$1,$sx
322A:	ldw	$2,$9
; subtract the array header size
322D:	sbw	$2,$sz		;$0 = 2*number_of_dimensions
322F:	sbw	$2,$sy
; clear the variable contents ($2,$3 bytes)
3231:	ldw	$0,$21		;address
3234:	cal	&H0157		;CLRME, clear memory block
3237:	ppsm	$15,8
323A:	ppsm	$7,8
323D:	rtn
; string variable
323E:	pre	ix,&H18A5
3242:	ldw	$21,(ix+$sx)	;PDSTD
3244:	cal	&H32C8		;expand the string variables contents area
3247:	jr	&H321B
3249:	ldw	$2,$9,jr &H3231

; create a variable/array, expects:
; $15,$16 = pointer to the variable name,
; $14 = variable name length,
; $13 = variable type,
; $12 = number of dimensions for an array,
; list of maximum values of indexes on the User Stack
324D:	ld	$7,$14		;variable name length
3250:	ld	$8,$sx
3252:	ldw	$0,&H0004	;type byte + name length byte + pointer word
3256:	adw	$7,$sz		;size of the variable table entry
3258:	cal	&H30F4		;$9,$10 <- size of the variable/array contents
325B:	ldw	$0,$7
325E:	sbc	$13,$sx		;variable type
3260:	jr	lz,&H3268	;skip if a string variable
3262:	adw	$0,$9
3265:	jp	c,&H2B6D	;OM Error, insufficient memory
3268:	cal	&H11C2		;test if there's enough free memory space
326B:	cal	&H3207		;allocate memory for the variable/array
326E:	phsw	$22
3270:	ldw	$17,$7		;entry size
3273:	ldw	$23,&H18A1
3277:	ldw	$21,($23)
327A:	cal	&H331F		;make room in the variable table
327D:	ppsw	$21
327F:	ldw	$19,($23)
3282:	pre	ix,$19
3284:	stiw	$13,(ix+$sx)
3286:	gre	ix,$0
3288:	ldw	$2,$15
328B:	ld	$4,$14
328E:	ld	$5,$sx
3290:	ldw	$23,$sz
3292:	adw	$23,$4
3295:	phsm	$13,7
3298:	cal	&H014C		;block transfer within the RAM
329B:	ppsm	$7,7
329E:	pre	ix,$23
32A0:	sbc	$13,$sx
32A2:	jr	lz,&H32AB
32A4:	ldw	$23,&H189F
32A8:	ldw	$21,($23)
32AB:	stiw	$21,(ix+$sx)
32AD:	rtn

; shrink the string variables contents area at address $21,$22 by $17,$18 bytes
32AE:	phsm	$18,5
32B1:	phsm	$13,8
32B4:	ldw	$0,$21		;destination address
32B7:	ldw	$2,$17
32BA:	adw	$2,$sz		;source address
32BC:	pre	ix,&H18A5
32C0:	ldw	$4,(ix+$sx)	;PDSTD
32C2:	sbw	$4,$2		;number of bytes
32C5:	cmpw	$17,jr &H32EC
; expand the string variables contents area at address $21,$22 by $17,$18 bytes
32C8:	phsm	$18,5
32CB:	phsm	$13,8
32CE:	ldw	$0,$21
32D1:	ldw	$2,$sz		;source address
32D3:	pre	ix,&H18A5
32D7:	ldw	$4,(ix+$sx)	;PDSTD
32D9:	ldiw	$6,(ix+$sx)	;PDSTD
32DB:	adw	$6,$17
32DE:	jr	c,&H32E2
32E0:	sbcw	(ix+$sx),$6	;HIMEM
32E2:	jp	c,&H2B6D	;OM Error, insufficient memory
32E5:	sbw	$4,$sz		;number of bytes
32E7:	jr	z,&H3312
32E9:	adw	$0,$17		;destination address
32EC:	cal	&H014C		;block transfer within the RAM
; update the pointers to the variable contents stored above address $21,$22
32EF:	pre	ix,&H18A1
32F3:	ldm	$0,(ix+$sx),4	;$0,$1 <- DTTB, $2,$3 <- TOSDT
32F6:	pre	ix,$0
32F8:	sbcw	$2,$sz		;end of the table reached?
32FA:	jr	z,&H3312	;leave the loop if so
32FC:	ldiw	$0,(ix+$sx)	;$0=variable type, $1=name length
32FE:	sbc	$0,$sx
3300:	ldd	$0,(ix+$1)	;IX<-IX+$1, pointer to the variable contents
3303:	jr	nlz,&H330D	;skip if not a string variable
3305:	sbcw	(ix+$sx),$21
3307:	jr	z,&H3312
3309:	jr	c,&H3312
330B:	adw	(ix+$sx),$17	;update the pointer
330D:	ldiw	$0,(ix+$sx)	;IX<-IX+2
330F:	gre	ix,$0,jr &H32F8	;next entry
3312:	pre	ix,&H18A5
3316:	adw	(ix+$sx),$17	;update the pointer PDSTD
3318:	ppsm	$6,8
331B:	ppsm	$14,5
331E:	rtn

; make room for $17,$18 bytes in the variable table at address $21,$22
331F:	ld	$28,&H04,jr &H332D
; make room for $17,$18 bytes on the FOR stack at address $21,$22
3323:	ld	$28,$sy,jr &H332D
; make room for $17,$18 bytes on the GOSUB stack at address $21,$22
3326:	ld	$28,&H02,jr &H332D
; expand the numeric variables contents area at address $21,$22 by $17,$18
; bytes
332A:	ld	$28,&H03
332D:	phsm	$18,5
3330:	phsm	$13,8
; move the memory block
3333:	ldw	$0,$17		;$0,$1 = required amount of memory
3336:	cal	&H11C2		;test if there's enough free memory space
3339:	pre	ix,&H189B
333D:	ldw	$0,(ix+$sx)	;FORSK
333F:	ldw	$2,$sz		;source address
3341:	ldw	$4,$21		;destination address
3344:	sbw	$0,$17
3347:	sbw	$4,$2		;number of bytes
334A:	cal	&H014C		;block transfer within the RAM
334D:	cmpw	$17
334F:	sbc	$28,&H04	;is the variable table being resized?
3352:	jr	nz,&H3375	;skip if not
; update the pointers to the variable contents stored below address $21,$22
3354:	pre	ix,&H18A1
3358:	ldm	$0,(ix+$sx),4	;$0,$1 <- DTTB, $2,$3 <- TOSDT
335B:	pre	ix,$0
335D:	sbcw	$2,$sz		;end of the table reached?
335F:	jr	z,&H3375	;leave the loop if so
3361:	ldiw	$0,(ix+$sx)	;$0=variable type, $1=name length
3363:	sbc	$0,$sx
3365:	ldd	$0,(ix+$1)	;IX<-IX+$1, pointer to the variable contents
3368:	jr	lz,&H3370	;skip if not a numeric variable
336A:	sbcw	(ix+$sx),$21
336C:	jr	nc,&H3375
336E:	adw	(ix+$sx),$17	;update the pointer
3370:	ldiw	$0,(ix+$sx)	;IX<-IX+2
3372:	gre	ix,$0,jr &H335D	;next entry
; update the pointers to the memory areas: FORSK, GOSSK, TONDT, DTTB
3375:	pre	ix,&H189B
3379:	adw	(ix+$sx),$17	;update the pointer
337B:	ldiw	$0,(ix+$sx)	;IX<-IX+2
337D:	sb	$28,$sy		;number of pointers being updated
337F:	jr	nz,&H3379	;next pointer
3381:	jr	&H3318

; shrink the FOR stack at address $21,$22 by $17,$18 bytes
3383:	ld	$28,$sy,jr &H3393
; shrink the GOSUB stack at address $21,$22 by $17,$18 bytes
3386:	ld	$28,&H02,jr &H3393
; shrink the variable table at address $21,$22 by $17,$18 bytes
338A:	pre	ix,&H18A1	;DTTB
338E:	adw	(ix+$sx),$17
; shrink the numeric variables contents area at address $21,$22 by $17,$18
; bytes
3390:	ld	$28,&H03
3393:	phsm	$18,5
3396:	phsm	$13,8
3399:	pre	ix,&H189B
339D:	ldw	$0,(ix+$sx)	;FORSK
339F:	ldw	$2,$sz		;source address
33A1:	ldw	$4,$21
33A4:	sbw	$4,$sz		;number of bytes
33A6:	adw	$0,$17		;destination address
33A9:	cal	&H014C		;block transfer within the RAM
33AC:	sbc	$28,&H03
33AF:	jr	z,&H3354
33B1:	jr	&H3375

; low tone beep
33B3:	ldw	$2,&H1000
33B7:	ld	$4,$sy,jr &H33C0

; print control code &H07, high tone beep
33BA:	ldw	$2,&H0200
33BE:	ld	$4,$sx
33C0:	gst	pd,$1
33C2:	an	$1,&H3F
33C5:	or	$1,&H40
33C8:	pst	pd,$1
33CA:	xr	$1,&HC0
33CD:	sbbw	$2,$sy
33CF:	jr	c,&H33E2
33D1:	sbc	$4,$sx
33D3:	jr	z,&H33D9
33D5:	ldm	$0,$0,6,jr &H33C8
33D9:	ad	$4,&H0D
33DC:	jr	nc,&H33D9
33DE:	ld	$4,$sx
33E0:	jr	&H33C8
33E2:	or	$1,&HC0
33E5:	pst	pd,$1
33E7:	rtn

33E8:	pre	ix,&H16CF	;currently edited file
33EC:	jr	&H33F2

; returns the pointer to the table of file addresses &H18A7 (in IZ),
; the starting address (in $25,$26), and the ending address (in $27,$28)
; of currently used file
33EE:	pre	ix,&H16C9	;NOWFL, currently used file
33F2:	ldw	$1,(ix+$sx)
33F4:	pre	iz,$1
33F6:	ldm	$25,(iz+$sx),4
33F9:	rtn

; expects the file starting address in $25,$26 and ending address in $27,$28
; returns the file size (with ommision of the EOF byte) in $2,$3
33FA:	ldm	$0,$25,4
33FD:	sbw	$2,$sz
33FF:	sbw	$2,$sy		;skip the EOF byte
3401:	rtn

3402:	ld	$14,$sx
3404:	cal	&H3428
3407:	pre	ix,&H16C7
340B:	stiw	$1,(ix+$sx)
340D:	stw	$1,(ix+$sx)
340F:	sbbw	$5,$5
3412:	pre	ix,&H16CB
3416:	stw	$5,(ix+$sx)
3418:	rtn

3419:	cal	&H3425
341C:	pre	ix,&H16CF
3420:	stw	$1,(ix+$sx)
3422:	rtn

; returns the starting address (in $25,$26), and the ending address (in $27,$28)
; of the file with the number in register $14
3423:	jr	z,&H3428	;skip if 'P' file
3425:	ad	$14,&H0A
3428:	ldw	$1,&H18A7	;table of file addresses
342C:	ld	$15,$14
342F:	ld	$16,$sx
3431:	biu	$15
3433:	adw	$1,$15		;$1,$2 = pointer to the table entry
3436:	jr	&H33F4

3438:	cal	&H46EE
343B:	cal	&H95D3
343E:	cal	&H33EE		;get starting/ending address of current file
3441:	cal	&H529B		;PR Error if password set
3444:	cal	&H28BC
3447:	pre	iz,&H1000
344B:	sbc	(iz+$sx),$31
344D:	rtn	z
344E:	ldd	$2,(iz+$sx)
3450:	ldw	$5,(iz+$sy)
3452:	cal	&H3412
3455:	ldw	$15,(iz+$sy)
3457:	cal	&H0B8C		;search for a BASIC line $15,$16
345A:	jr	c,&H347E
345C:	sbc	$2,&H04
345F:	rtn	z
3460:	phs	$2
3462:	ld	$0,$2
3465:	ld	$1,$sx
3467:	adw	$0,$sy
3469:	gre	iz,$2
346B:	cal	&H34B1		;expand a memory block in a RAM file
346E:	ldw	$0,$2
3471:	pps	$4
3473:	ld	$5,$sx
3475:	adw	$4,$sy
3477:	ldw	$2,&H1000
347B:	jp	&H00F9
347E:	sbc	$2,&H04
3481:	jr	z,&H34A6
3483:	sbc	(iz+$sx),$2
3485:	jr	nc,&H3494
3487:	phs	$2
3489:	ldd	$1,(iz+$sx)
348B:	ld	$0,$2
348E:	sb	$0,$1
3491:	ld	$1,$sx,jr &H3469
3494:	phs	$2
3496:	gre	iz,$0
3498:	jr	z,&H3471
349A:	ldd	$3,(iz+$sx)
349C:	sb	$3,$2
349F:	bydw	$3
34A1:	cal	&H34EA		;shrink a memory block in a RAM file
34A4:	jr	&H346E
34A6:	ldd	$2,(iz+$sx)
34A8:	ld	$3,$sx
34AA:	adw	$2,$sy
34AC:	gre	iz,$0
34AE:	jp	&H34EA		;shrink a memory block in a RAM file

; expand a memory block in a RAM file
; $0,$1 = number of bytes
; $2,$3 = addres within the file at which the memory block has to be expanded
; $25,$26 = starting address of the file
; $27,$28 = ending address of the file, updated
34B1:	sbcw	$0,$sy
34B3:	rtn	c		;return if 0 bytes requested
34B4:	phsw	$3
34B6:	pre	ix,&H18CF
34BA:	ldm	$4,(ix+$sx),4	;$0,$1 <- MEMEN, $2,$3 <- top of the RAM
34BD:	sbw	$6,$4		;$6,$7 <- free RAM space
34C0:	sbcw	$6,$sz
34C2:	jp	c,&H2B6D	;OM Error, insufficient memory
; move the memory block
34C5:	phsw	$1
34C7:	adw	$0,$2		;$0,$1=destination address
34CA:	sbw	$4,$2		;$4,$5=number of bytes
34CD:	cal	&H014C		;block transfer within the RAM
34D0:	ppsw	$0
34D2:	ppsw	$2
34D4:	adw	$27,$sz		;update the ending address of the file
; update the starting addresses of the files
34D6:	ldw	$4,&H18CF
34DA:	ldw	$6,($4)
34DD:	sbcw	$6,$25
34E0:	rtn	z
34E1:	pre	ix,$4
34E3:	adw	(ix+$sx),$0
34E5:	sbw	$4,$sy
34E7:	sbw	$4,$sy,jr &H34DA

; shrink a memory block in a RAM file
; $0,$1 = addres within the file at which the memory block has to be shrunk
; $2,$3 = number of bytes
; $25,$26 = starting address of the file
; $27,$28 = ending address of the file, updated
34EA:	sbcw	$2,$sy
34EC:	rtn	c		;return if 0 bytes requested
34ED:	phsw	$1
34EF:	pre	ix,&H18CF
34F3:	gre	ix,$4
34F5:	cmpw	$2
34F7:	phsw	$3
34F9:	cmpw	$2
34FB:	ldw	$4,(ix+$sx)
34FD:	adw	$2,$sz,jr &H34CA

; command STOP, prefix 4, code &HAE
3500:	cal	&H5044		;FC Error if BASIC interpreter not in RUN mode
3503:	cal	&H35DC
3506:	cal	&H2D4E
3509:	cal	&H2D23
350C:	pre	ix,&H16C6
3510:	ld	$0,&H02
3513:	std	$0,(ix+$sx)
3515:	gre	iz,$0
3517:	pre	ix,&H16DD
351B:	stw	$0,(ix+$sx)
351D:	jp	&H1FD7

; command END, prefix 4, code &H87
3520:	cal	&H0093		;SN Error if not an end of a BASIC line
3523:	cal	&H3C65
3526:	cal	&H2A0C
3529:	jp	&H1FB9

; command RUN, prefix 4, code &H6D
352C:	cal	&H5037
352F:	cal	&H503D
3532:	cal	&H1EDF
3535:	cal	&H0093		;SN Error if not an end of a BASIC line
3538:	ldw	$2,&H2DA9
353C:	cal	&H297A		;BRSTR, set ACJMP
353F:	cal	&H29C5		;test the power switch and BRK key
3542:	cal	&H3C72
3545:	pre	ss,&H1BD7
3549:	cal	&H35E8
354C:	cal	&H503D
354F:	std	$30,(ix+$sx)
3551:	ldw	$15,$17
3554:	cal	&H5176		;LNSCH, search for a BASIC line $4,$5
3557:	jr	&H355E
3559:	cal	&H506E
355C:	jr	z,&H3506
355E:	adc	(iz+$sx),$31
3560:	jr	z,&H3523
3562:	ldim	$4,(iz+$sx),3
3565:	pre	ix,&H16CB
3569:	stw	$5,(ix+$sx)
356B:	pre	ss,&H1BD7
356F:	cal	&H3574
3572:	jr	&H3559
3574:	cal	&H3C88
3577:	cal	&H28AF
357A:	gre	iz,$0
357C:	pre	ix,&H16CD
3580:	stw	$0,(ix+$sx)
3582:	cal	&H0049
3585:	sbc	$0,&H02
3588:	jr	z,&H359B
358A:	sbc	$0,&H04
358D:	jr	nz,&H35A9
358F:	ldi	$0,(iz+$sy)
3591:	sb	$0,&H49
3594:	ldw	$3,&H57DE
3598:	cal	&H1183
359B:	cal	&H35DC
359E:	adc	(iz-$sy),$31
35A0:	rtn	z
35A1:	cal	&H506E
35A4:	jr	nz,&H3574
35A6:	jp	&H3506
35A9:	ld	$0,&H4F,jr &H3591

; command CONT, prefix 4, code &H50
35AD:	cal	&H504A
35B0:	anc	$1,&H02
35B3:	jp	z,&H2BA8	;FC Error, unrecognized command
35B6:	cal	&H0093		;SN Error if not an end of a BASIC line
35B9:	pre	ix,&H16C6
35BD:	std	$30,(ix+$sx)
35BF:	ldw	$2,&H2DA9
35C3:	cal	&H297A		;BRSTR, set ACJMP
35C6:	cal	&H33EE		;get starting/ending address of current file
35C9:	pre	ix,&H16DD
35CD:	ldw	$0,(ix+$sx)
35CF:	pre	iz,$0
35D1:	sbcw	$25,$sz
35D3:	jr	z,&H35D7
35D5:	adc	(iz-$sy),$31
35D7:	jp	z,&H3559
35DA:	jr	&H356B
35DC:	cal	&H0093		;SN Error if not an end of a BASIC line
35DF:	sbc	$0,&H02
35E2:	cal	z,&H0B9B
35E5:	ldd	$1,(iz+$sy)
35E7:	rtn
35E8:	pre	ix,&H18BB
35EC:	ldm	$0,(ix+$sx),4
35EF:	pre	ix,&H16D5
35F3:	stm	$0,(ix+$sx),4
35F6:	ldw	$0,&H16D9
35FA:	ldw	$2,&H0010
35FE:	cal	&H0157		;CLRME, clear memory block
3601:	cal	&H28A0
3604:	cal	&H28A6
3607:	cal	&H278D
360A:	cal	&H09AA
360D:	pre	ix,&H1748
3611:	jp	&H51B4

; command TROFF, prefix 4, code &H5F
3614:	ld	$15,$sx,jr &H3619
; command TRON, prefix 4, code &H5D
3617:	ld	$15,$sy
3619:	pre	ix,&H16E9
361D:	std	$15,(ix+$sx)
361F:	rtn

; command GOSUB, prefix 4, code &H4A
3620:	cal	&H5044		;FC Error if BASIC interpreter not in RUN mode
3623:	cal	&H3699
3626:	cal	&H0093		;SN Error if not an end of a BASIC line
3629:	phsw	$2
362B:	phsw	$16
362D:	cal	&H3636
3630:	ppsw	$15
3632:	ppsw	$1
3634:	jr	&H3693
3636:	pre	ix,&H189D
363A:	ldw	$21,(ix+$sx)
363C:	ldw	$17,&H0006
3640:	cal	&H3326
3643:	pre	ix,&H16C9
3647:	ldm	$11,(ix+$sx),4
364A:	gre	iz,$15
364C:	pre	ix,$21
364E:	ldd	$0,(ix-&H06)
3651:	stm	$11,(ix+$sx),6
3654:	pre	iz,$15
3656:	rtn
3657:	sbcw	(ix+$sx),$11
3659:	jr	z,&H3651
365B:	cal	&H3651
365E:	stdw	$12,(ix-$sy)
3660:	jp	&H3C72

; command RETURN, prefix 4, code &H4B
3663:	cal	&H5044		;FC Error if BASIC interpreter not in RUN mode
3666:	pre	ix,&H189D
366A:	ldiw	$21,(ix+$sx)
366C:	sbcw	(ix+$sx),$21
366E:	jp	z,&H2BC8
3671:	cal	&H003C		;ENDSC, test for an end of a BASIC line
3674:	gfl	$25
3676:	ldw	$17,&H0006
367A:	pre	ix,$21
367C:	ldm	$11,(ix+$sx),6
367F:	cal	&H3386
3682:	pre	ix,&H16C9
3686:	pfl	$25
3688:	jr	c,&H3657

; command GOTO, prefix 4, code &H49
368A:	cal	&H5044		;FC Error if BASIC interpreter not in RUN mode
368D:	cal	&H3699
3690:	cal	&H0093		;SN Error if not an end of a BASIC line
3693:	cal	&H36AB
3696:	jp	&H3559
3699:	cal	&H36C4
369C:	sbcw	$15,$sy
369E:	jr	c,&H36A8
36A0:	gre	iz,$21
36A2:	cal	&H5176		;LNSCH, search for a BASIC line $4,$5
36A5:	jp	nc,&H2BAC
36A8:	pre	iz,$21
36AA:	rtn
36AB:	sbcw	$15,$sy
36AD:	jr	c,&H36B2
36AF:	pre	iz,$19
36B1:	rtn
36B2:	cal	&H3407
36B5:	cal	&H0B8C		;search for a BASIC line $15,$16
36B8:	jr	z,&H36BF
36BA:	ldiw	$5,(iz+$sy)
36BC:	cal	&H3412
36BF:	cal	&H3C72
36C2:	jr	&H36AF
36C4:	cal	&H0049
36C7:	sbc	$0,&H03
36CA:	jr	z,&H36DA
36CC:	cal	&H00CD		;test for '#'
36CF:	jr	z,&H36DD
36D1:	cal	&H0EDF
36D4:	sbcw	$15,$sy
36D6:	jp	c,&H2BAC
36D9:	rtn
36DA:	ldiw	$15,(iz+$sy)
36DC:	rtn
36DD:	cal	&H0EC3		;evaluate num. expression to integer (byte)
36E0:	sbc	$15,&H0A
36E3:	jp	nc,&H2BA4	;BS Error, subscript out of range
36E6:	bydw	$15
36E8:	gre	iz,$21
36EA:	cal	&H3428
36ED:	pre	iz,$21
36EF:	sbbw	$15,$15
36F2:	rtn
36F3:	cal	&H0FF8
36F6:	ld	$18,$sy,jr &H3738

; command FOR, prefix 4, code &H81
36F9:	cal	&H5044		;FC Error if BASIC interpreter not in RUN mode
36FC:	cal	&H2F01		;variable specification -> variable work area
36FF:	pre	ix,&H167F	;VAR2 system variable
3703:	ldd	$0,(ix+$sx)	;variable type
3705:	adc	$0,$sx
3707:	jp	lz,&H2BB0	;TM Error, mismatch of variable type
370A:	biu	$0
370C:	jp	c,&H2BB0	;TM Error, mismatch of variable type
370F:	cal	&H00E3		;test for '=', SN Error if not found
3712:	cal	&H112F		;EXPRW, evaluate numerical expression
3715:	cal	&H0058		;push a FP number $10-$18 on the US
; TO
3718:	ld	$2,&HC1		;code of the keyword TO
371B:	cal	&H00E9		;test for keyword prefix 7 and code $2
371E:	jp	nz,&H2B70	;SN Error, syntax
3721:	cal	&H112F		;EXPRW, evaluate numerical expression
3724:	cal	&H006C		;pop a FP number from the US to $0-$8
3727:	cal	&H0058		;push a FP number $10-$18 on the US
372A:	cal	&H0068		;push a FP number $0-$8 on the US
; STEP
372D:	ld	$2,&HC0		;code of the keyword STEP
3730:	cal	&H00E9		;test for keyword prefix 7 and code $2
3733:	jr	nz,&H36F3	;default=1 if no STEP value specified
3735:	cal	&H112F		;EXPRW, evaluate numerical expression
3738:	cal	&H0093		;SN Error if not an end of a BASIC line
373B:	cal	&H006C		;pop a FP number from the US to $0-$8
373E:	cal	&H0058		;push a FP number $10-$18 on the US
3741:	ldm	$10,$sz,8
3744:	ld	$18,$8
3747:	cal	&H31AD
374A:	pre	ix,&H16CB	;NOWLN, current execution line number
374E:	ldw	$5,(ix+$sx)
3750:	ldw	$21,(ix+$sx)
3752:	gre	iz,$23
3754:	phum	$24,6
3757:	ldw	$3,&H0403
375B:	ld	$7,$sy,jr &H3784
375E:	sbc	$3,$sz
3760:	jr	nz,&H377A
3762:	ldiw	$0,(iz+$sx)
3764:	jr	&H3784
3766:	cal	&H0049		;NEXTC, get next character other than space
3769:	jr	c,&H3784
376B:	ad	$7,$sy
376D:	jr	nz,&H3784
376F:	jp	&H2BC4		;NX error, FOR without NEXT
3772:	ld	$2,&H82
3775:	cal	&H00EF		;test for keyword prefix 4 and code $2
3778:	jr	&H3784
377A:	adc	$0,$sx
377C:	jr	nz,&H3784
377E:	adc	(iz+$sx),$31
3780:	jr	z,&H376F
3782:	ldiw	$5,(iz+$sy)
3784:	ldi	$0,(iz+$sx)
3786:	sbc	$4,$sz
3788:	jr	nz,&H375E
378A:	ldi	$0,(iz+$sx)
378C:	sbc	$0,&H81
378F:	jr	z,&H3766
3791:	sbc	$0,&H4C
3794:	jr	z,&H3772
3796:	sbc	$0,&H82
3799:	jr	nz,&H3784
379B:	sb	$7,$sy
379D:	jr	z,&H37B6
379F:	cal	&H003C		;ENDSC, test for an end of a BASIC line
37A2:	jr	c,&H3784
37A4:	cal	&H3412		;NOWLN <- $5,$6
37A7:	cal	&H2F36		;parse for a variable name and type
37AA:	jp	nc,&H2B70	;SN Error, syntax
37AD:	cal	&H00C3		;test for a comma
37B0:	jr	nz,&H3784
37B2:	sb	$7,$sy
37B4:	jr	nz,&H37A7
37B6:	cal	&H3412		;NOWLN <- $5,$6
37B9:	sbc	$0,&H2C
37BC:	jr	z,&H37C3
37BE:	cal	&H003C		;ENDSC, test for an end of a BASIC line
37C1:	jr	c,&H37DA
37C3:	cal	&H2F36		;parse for a variable name and type
37C6:	jp	nc,&H2B70	;SN Error, syntax
37C9:	cal	&H31A4		;search the BASIC variable name area
37CC:	jp	nc,&H2BC0	;FO error, NEXT without FOR
37CF:	ppuw	$0
37D1:	phuw	$1
37D3:	sbcw	$19,$sz
37D5:	jp	nz,&H2BC0	;FO error, NEXT without FOR
37D8:	pre	iz,$15
37DA:	cal	&H3818
37DD:	jr	c,&H3803
37DF:	pre	ix,&H16CB	;NOWLN, current execution line number
37E3:	ldw	$7,(ix+$sx)
37E5:	ppum	$3,4
37E8:	phum	$6,4
37EB:	stw	$5,(ix+$sx)
37ED:	pre	ix,&H189B
37F1:	ldw	$21,(ix+$sx)
37F3:	ldw	$17,&H001A	;entry size
37F7:	cal	&H3323		;make room on the FOR stack
37FA:	sbw	$21,$17
37FD:	ldw	$5,$7
3800:	cal	&H3412		;NOWLN <- $5,$6
3803:	pre	ix,$21
3805:	gre	iz,$0
3807:	ppum	$2,6
380A:	stim	$0,(ix+$sx),8
380D:	cal	&H3832
3810:	cal	&H3832
3813:	cal	&H38A8
3816:	jr	&H386E
3818:	gre	iz,$4
381A:	pre	ix,&H189B
381E:	ldm	$21,(ix+$sx),4
3821:	pre	ix,$21
3823:	sbcw	$21,$23
3826:	rtn	z
3827:	sbcw	(ix+$sx),$4
3829:	jp	z,&H9676
382C:	ldd	$0,(ix+&H1A)
382F:	gre	ix,$21,jr &H3823
3832:	cal	&H005C		;pop a FP number from the US to $10-$18
3835:	stim	$10,(ix+$sx),8
3838:	sti	$18,(ix+$sx)
383A:	rtn

; command NEXT, prefix 4, code &H82
383B:	cal	&H5044		;FC Error if BASIC interpreter not in RUN mode
383E:	cal	&H0049
3841:	cal	&H3818
3844:	jp	nc,&H2BC0
3847:	cal	&H38A8
384A:	phsm	$23,3
384D:	phsw	$1
384F:	pre	ix,$21
3851:	ld	$0,&H08
3854:	ldim	$0,(ix+$sz),8
3857:	ldd	$8,(ix+$sx)
3859:	cal	&H05DA
385C:	diu	$16
385E:	didm	$18,3
3861:	ppsm	$19,5
3864:	pre	ix,$19
3866:	stm	$10,(ix+$sx),8
3869:	dium	$16,3
386C:	did	$16
386E:	pre	ix,$21
3870:	ld	$0,&H11
3873:	ldim	$0,(ix+$sz),8
3876:	ldd	$8,(ix+$sx)
3878:	cal	&H0A72
387B:	jr	z,&H389A
387D:	jr	c,&H3895
387F:	sbc	$23,&H05
3882:	jr	nc,&H389A
3884:	ldw	$17,&H001A
3888:	cal	&H3383
388B:	cal	&H2F36
388E:	rtn	nc
388F:	cal	&H00C3
3892:	jr	z,&H383B
3894:	rtn
3895:	sbc	$23,&H05
3898:	jr	nc,&H3884
389A:	pre	ix,$21
389C:	ldm	$2,(ix+$sy),7
389F:	pre	ix,&H16CB
38A3:	stw	$5,(ix+$sx)
38A5:	pre	iz,$7
38A7:	rtn
38A8:	pre	ix,$21
38AA:	ldm	$1,(ix+$sy),3
38AD:	ld	$23,(ix+&H10)
38B0:	pre	ix,$2
38B2:	ldi	$0,(ix+$sy)
38B4:	ldw	$0,(ix+$sz)
38B6:	pre	ix,$0
38B8:	jp	&H30E9

; command IF, prefix 4, code &H8D
38BB:	cal	&H112F
38BE:	sbc	$16,$sy
38C0:	jr	c,&H38E4
38C2:	ld	$2,&H49
38C5:	cal	&H00EF
38C8:	jr	z,&H38E1
38CA:	ld	$2,&H47
38CD:	cal	&H00E9		;test for keyword prefix 7 and code $2
38D0:	jp	nz,&H2B70	;SN Error, syntax
38D3:	cal	&H0049
38D6:	sbc	$0,&H03
38D9:	jr	z,&H38E1
38DB:	sbc	$0,&H23
38DE:	jp	nz,&H356B
38E1:	jp	&H368A
38E4:	cal	&H38EA
38E7:	rtn	nc
38E8:	jr	&H38D3
38EA:	ldw	$2,&H031F
38EE:	ldw	$4,&H0704
38F2:	ld	$6,$sy
38F4:	ldi	$0,(iz+$sx)
38F6:	adc	$0,$sx
38F8:	jr	z,&H3926
38FA:	sbc	$2,$sz
38FC:	jr	c,&H38F4
38FE:	sbc	$3,$sz
3900:	jr	z,&H391A
3902:	jr	nc,&H38F4
3904:	ldi	$1,(iz+$sx)
3906:	sbc	$4,$sz
3908:	jr	z,&H391E
390A:	sbc	$5,$sz
390C:	jr	nz,&H38F4
390E:	sbc	$1,&H48
3911:	jr	nz,&H38F4
3913:	sb	$6,$sy
3915:	jr	nz,&H38F4
3917:	sbc	$31,$sy
3919:	rtn
391A:	ldiw	$0,(iz+$sx)
391C:	jr	&H38F4
391E:	sbc	$1,&H8D
3921:	jr	nz,&H38F4
3923:	ad	$6,$sy,jr &H38F4
3926:	ldd	$0,(iz-$sy)
3928:	rtn

; command ANGLE, prefix 4, code &H6E
3929:	cal	&H0EC3		;evaluate num. expression to integer (byte)
392C:	cal	&H0093		;SN Error if not an end of a BASIC line
392F:	sbc	$15,&H03
3932:	jp	nc,&H2BA4	;BS Error, subscript out of range
3935:	pre	ix,&H1132
3939:	std	$15,(ix+$sx)
393B:	jp	&H928A

; command ???, prefix 4, code &H4F
393E:	cal	&H0049
3941:	sbc	$0,&H20
3944:	jp	nc,&H2EA2
3947:	ldi	$2,(iz+$sy)
3949:	sbc	$0,&H06
394C:	jr	z,&H395C
394E:	sbc	$0,&H07
3951:	jr	nz,&H3959
3953:	sbc	$2,&H48		;code of the ELSE keyword
3956:	jp	z,&H0B9B
3959:	jp	&H2B70		;SN Error, syntax
395C:	sbc	$2,&H9B		;code of the INPUT keyword
395F:	jp	z,&H3DEE
3962:	sbc	$2,&HAD		;code of the STAT keyword
3965:	jr	nz,&H3959
3967:	cal	&H00E3
396A:	cal	&H11D2		;evaluate a string expression
396D:	cal	&H125D		;append zero
3970:	cal	&H0093		;SN Error if not an end of a BASIC line
3973:	pre	ix,$15
3975:	ld	$2,$17
3978:	ld	$3,$sx
397A:	jp	&H233A

; command DEF, prefix 4, code &H76
397D:	ld	$2,&HA0
3980:	cal	&H00EB
3983:	jp	nz,&H2B70	;SN Error, syntax
3986:	cal	&H00E1
3989:	cal	&H0EC3		;evaluate num. expression to integer (byte)
398C:	sb	$15,&HFC
398F:	jp	c,&H2BA4	;BS Error, subscript out of range
3992:	biu	$15
3994:	ld	$0,$15
3997:	biu	$15
3999:	ad	$15,$sz
399B:	phs	$15
399D:	cal	&H00DF
39A0:	cal	&H00E3
39A3:	cal	&H11D2		;evaluate a string expression
39A6:	sbc	$17,&H0D
39A9:	jp	nc,&H2BA8	;FC Error, unrecognized command
39AC:	ldw	$0,&H153C
39B0:	pps	$2
39B2:	ld	$3,$sx
39B4:	adw	$2,$sz
39B6:	gre	iz,$4
39B8:	phsw	$3
39BA:	pre	iz,&H165E
39BE:	sbbm	$6,$6,6
39C1:	stm	$6,(iz+$sx),6
39C4:	pre	ix,$15
39C6:	sb	$17,$sy
39C8:	jr	c,&H39E9
39CA:	ldi	$0,(ix+$sx)
39CC:	cal	&H009D
39CF:	jr	nc,&H39DE
39D1:	ld	$1,$sz
39D3:	diu	$1
39D5:	sb	$17,$sy
39D7:	jr	c,&H39E7
39D9:	ldi	$0,(ix+$sx)
39DB:	cal	&H009D
39DE:	jp	nc,&H2B70	;SN Error, syntax
39E1:	ad	$1,$sz
39E3:	sti	$1,(iz+$sx)
39E5:	jr	&H39C6
39E7:	std	$1,(iz+$sx)
39E9:	pre	iz,&H165E
39ED:	ldm	$6,(iz+$sx),6
39F0:	ppsw	$2
39F2:	pre	iz,$2
39F4:	stm	$6,(iz+$sx),6
39F7:	pre	iz,$4
39F9:	rtn

; command LOCATE, prefix 4, code &H91
39FA:	cal	&H0EC3		;evaluate num. expression to integer (byte)
39FD:	sbc	$15,&H20
3A00:	jr	nc,&H3A20
3A02:	phs	$15
3A04:	cal	&H00DB
3A07:	cal	&H0EC3		;evaluate num. expression to integer (byte)
3A0A:	sbc	$15,&H08
3A0D:	jr	nc,&H3A20
3A0F:	pps	$0
3A11:	diu	$15
3A13:	biu	$15
3A15:	ad	$15,$sz
3A17:	pre	ix,&H1101
3A1B:	std	$15,(ix+$sx)
3A1D:	jp	&H956A
3A20:	jp	&H2BA4		;BS Error, subscript out of range

; command POKE, prefix 4, code &H63
3A23:	cal	&H0EFA		;evaluate num. expression to integer (word)
3A26:	phsw	$16
3A28:	cal	&H00DB
3A2B:	cal	&H0EC3		;evaluate num. expression to integer (byte)
3A2E:	bydw	$15		;= LD $14,$15
3A30:	ppsw	$15
3A32:	cal	&H19A0		;UA,IX <- effective address
3A35:	std	$14,(ix+$sx)
3A37:	pst	ua,$2
3A39:	rtn

; command DEFSEG, prefix 4, code &H78
3A3A:	cal	&H00E3
3A3D:	cal	&H0EFA		;evaluate num. expression to integer (word)
3A40:	cal	&H0093		;SN Error if not an end of a BASIC line
3A43:	pre	ix,&H16C0
3A47:	stw	$15,(ix+$sx)
3A49:	rtn

; command DIM, prefix 4, code &H7C
3A4A:	cal	&H2F0C
3A4D:	adc	$12,$sx
3A4F:	jp	z,&H2B70	;SN Error, syntax
3A52:	cal	&H31A4
3A55:	jr	c,&H3A60
3A57:	cal	&H324D
3A5A:	cal	&H00C3
3A5D:	jr	z,&H3A4A
3A5F:	rtn
3A60:	pre	ix,$21
3A62:	ldi	$24,(ix+$sx)
3A64:	cal	&H3156
3A67:	sbc	$12,$24
3A6A:	jp	nz,&H2BA0
3A6D:	gre	us,$0
3A6F:	pre	ix,$0
3A71:	ldw	$2,$15
3A74:	cal	&H3156
3A77:	sbcw	$2,$sz
3A79:	jp	nz,&H2BA0
3A7C:	cal	&H313C
3A7F:	jr	&H3A5A

; command ERASE, prefix 4, code &H85
3A81:	cal	&H2F36
3A84:	jr	nc,&H3A8B
3A86:	ad	$13,&H80
3A89:	jr	c,&H3AF7
3A8B:	cal	&H00C3
3A8E:	jr	z,&H3A95
3A90:	cal	&H0093		;SN Error if not an end of a BASIC line
3A93:	sbc	$31,$sy
3A95:	gfl	$0
3A97:	phs	$0
3A99:	cal	&H31A4
3A9C:	jr	nc,&H3ABF
3A9E:	cal	&H3169
3AA1:	sbw	$17,$21
3AA4:	adc	$13,$sx
3AA6:	jr	lz,&H3AC6
3AA8:	cal	&H3390
3AAB:	ld	$17,$14
3AAE:	ld	$18,$sx
3AB0:	ldw	$0,&H0004
3AB4:	adw	$17,$sz
3AB6:	ldw	$21,$19
3AB9:	cal	&H338A
3ABC:	cal	&H28A6
3ABF:	pps	$0
3AC1:	pfl	$0
3AC3:	jr	nc,&H3A81
3AC5:	rtn
3AC6:	cal	&H32AE
3AC9:	jr	&H3AAB

; command RESUME, prefix 4, code &H4C
3ACB:	cal	&H5044		;FC Error if BASIC interpreter not in RUN mode
3ACE:	pre	ix,&H16C9
3AD2:	ldw	$0,(ix+$sx)
3AD4:	pre	ix,&H16DF
3AD8:	sbcw	(ix+$sx),$0
3ADA:	jp	nz,&H2BB4
3ADD:	ldim	$1,(ix+$sx),8
3AE0:	sbc	(ix+$sy),$30
3AE2:	jp	c,&H2BB4
3AE5:	ld	$2,&H82
3AE8:	cal	&H00EF
3AEB:	jr	z,&H3B05
3AED:	cal	&H003C		;ENDSC, test for an end of a BASIC line
3AF0:	jr	c,&H3AFA
3AF2:	sbc	$0,&H03
3AF5:	jr	z,&H3B17
3AF7:	jp	&H2B70		;SN Error, syntax
3AFA:	pre	iz,$7
3AFC:	cal	&H3412
3AFF:	cal	&H3B23
3B02:	jp	&H356B
3B05:	cal	&H0093		;SN Error if not an end of a BASIC line
3B08:	pre	iz,$7
3B0A:	cal	&H0B99
3B0D:	ldd	$1,(iz+$sy)
3B0F:	jr	z,&H3AFC
3B11:	cal	&H3B23
3B14:	jp	&H3559
3B17:	cal	&H3699
3B1A:	cal	&H0093		;SN Error if not an end of a BASIC line
3B1D:	cal	&H3B23
3B20:	jp	&H3693
3B23:	pre	ix,&H16E8
3B27:	std	$31,(ix+$sx)
3B29:	rtn
3B2A:	ld	$2,&H49
3B2D:	cal	&H00EF
3B30:	jr	nz,&H3AF7
3B32:	cal	&H0049
3B35:	sbc	$0,&H03
3B38:	jr	z,&H3B5A
3B3A:	sbc	$0,&H30
3B3D:	jr	nz,&H3AF7
3B3F:	ldd	$0,(iz+$sy)
3B41:	sbbm	$17,$17,4
3B44:	cal	&H3B66
3B47:	pre	ix,&H16E3
3B4B:	ldm	$5,(ix+$sx),6
3B4E:	sbc	$10,$sy
3B50:	rtn	c
3B51:	cal	&H3412
3B54:	ld	$18,$9
3B57:	jp	&H2C6D
3B5A:	cal	&H36DA
3B5D:	cal	&H36A0
3B60:	pre	ix,&H16C9
3B64:	ldw	$17,(ix+$sx)
3B66:	cal	&H0093		;SN Error if not an end of a BASIC line
3B69:	pre	ix,&H16DF
3B6D:	stm	$17,(ix+$sx),4
3B70:	rtn

; command ON, prefix 4, code &H9A
3B71:	cal	&H5044		;FC Error if BASIC interpreter not in RUN mode
3B74:	ld	$2,&H86
3B77:	cal	&H00EF
3B7A:	jr	z,&H3B2A
3B7C:	cal	&H112F
3B7F:	sbc	$18,$sy
3B81:	jp	nz,&H0B99
3B84:	sbc	$17,&H02
3B87:	jp	nc,&H0B99
3B8A:	cal	&H0EC6
3B8D:	ld	$2,&H49
3B90:	cal	&H00EF
3B93:	jr	z,&H3B9D
3B95:	ad	$2,$sy
3B97:	cal	&H00EF
3B9A:	jp	nz,&H2B70	;SN Error, syntax
3B9D:	cal	&H003C		;ENDSC, test for an end of a BASIC line
3BA0:	jp	c,&H2B70	;SN Error, syntax
3BA3:	ld	$14,$2
3BA6:	sb	$15,$sy
3BA8:	jr	z,&H3BC3
3BAA:	phsw	$15
3BAC:	cal	&H00C3
3BAF:	jr	z,&H3BBA
3BB1:	cal	&H36C4
3BB4:	cal	&H125D		;append zero
3BB7:	cal	&H00C3
3BBA:	ppsw	$14
3BBC:	jr	z,&H3BA6
3BBE:	rtn
3BBF:	ldiw	$0,(iz+$sy)
3BC1:	jr	&H3BB7
3BC3:	cal	&H003C		;ENDSC, test for an end of a BASIC line
3BC6:	rtn	c
3BC7:	cal	&H00C3
3BCA:	jp	z,&H0B99
3BCD:	phs	$14
3BCF:	cal	&H3699
3BD2:	phsw	$2
3BD4:	cal	&H00C3
3BD7:	cal	nz,&H0093	;SN Error if not an end of a BASIC line
3BDA:	ppsm	$1,3
3BDD:	sbc	$3,&H49
3BE0:	jp	z,&H3693
3BE3:	phsw	$2
3BE5:	cal	&H0B99
3BE8:	jp	&H362B

; command VAR, prefix 4, code &HB2
3BEB:	ld	$2,&H57
3BEE:	cal	&H00EF
3BF1:	jp	nz,&H2B70	;SN Error, syntax
3BF4:	cal	&H0093		;SN Error if not an end of a BASIC line
3BF7:	cal	&H3C5A
3BFA:	gre	iz,$28
3BFC:	pre	ix,&H18A1
3C00:	ldm	$23,(ix+$sx),4
3C03:	pre	ix,$23
3C05:	gre	ix,$0
3C07:	sbcw	$25,$sz
3C09:	jr	z,&H3C4F
3C0B:	ldiw	$17,(ix+$sx)
3C0D:	gre	ix,$15
3C0F:	phsm	$18,4
3C12:	ld	$23,$17
3C15:	bydw	$18
3C17:	cal	&H2981
3C1A:	cal	&H97D5
3C1D:	adc	$23,$sx
3C1F:	ld	$16,&H24	;'$'
3C22:	cal	lz,&H2AF1	;display character $16
3C25:	biu	$23
3C27:	jr	nc,&H3C34
3C29:	ld	$16,&H28	;'('
3C2C:	cal	&H2AF1		;display character $16
3C2F:	ad	$16,$sy
3C31:	cal	&H2AF1		;display character $16
3C34:	cal	&H2991		;select the LCD as the output device
3C37:	pre	ix,&H173B
3C3B:	sbc	(ix+$sx),$30
3C3D:	jr	z,&H3C55
3C3F:	cal	&H505C
3C42:	cal	&H3C98
3C45:	ppsm	$15,4
3C48:	pre	ix,$15
3C4A:	ldiw	$0,(ix+$18)
3C4D:	jr	&H3C05
3C4F:	cal	&H3C5A
3C52:	pre	iz,$28
3C54:	rtn
3C55:	cal	&H29C5		;test the power switch and BRK key
3C58:	jr	&H3C42
3C5A:	cal	&H2B3D
3C5D:	jr	nz,&H3C65
3C5F:	cal	&H2989		;select the printer as the output device
3C62:	cal	&H3C82
3C65:	pre	ix,&H1101
3C69:	ldd	$0,(ix+$sx)
3C6B:	anc	$0,&H1F
3C6E:	rtn	z
3C6F:	jp	&H2AE8		;OUTCR, display CR-LF
3C72:	pre	ix,&H16E9
3C76:	sbc	(ix+$sx),$31
3C78:	rtn	z
3C79:	cal	&H3C5A
3C7C:	cal	&H2981
3C7F:	cal	&H3CC3
3C82:	cal	&H2AE8		;OUTCR, display CR-LF
3C85:	jp	&H2991		;select the LCD as the output device

3C88:	pre	ix,&H16E9
3C8C:	sbc	(ix+$sx),$31
3C8E:	rtn	z
3C8F:	cal	&H2981
3C92:	cal	&H3CCE
3C95:	cal	&H2991		;select the LCD as the output device
3C98:	cal	&H2B3D
3C9B:	jr	nz,&H3CB0
3C9D:	cal	&H2989		;select the printer as the output device
3CA0:	cal	&H2AD7		;display a space
3CA3:	cal	&H2B57
3CA6:	anc	$0,&H07
3CA9:	jr	z,&H3CAD
3CAB:	jr	&H3CA0
3CAD:	cal	&H2991		;select the LCD as the output device
3CB0:	pre	ix,&H1101
3CB4:	ldd	$0,(ix+$sx)
3CB6:	an	$0,&HF8
3CB9:	ad	$0,&H08
3CBC:	jr	c,&H3C6F
3CBE:	std	$0,(ix+$sx)
3CC0:	jp	&H956A
3CC3:	ld	$16,&H5B	;'['
3CC6:	cal	&H2AF1		;display character $16
3CC9:	cal	&H2D71
3CCC:	jr	&H3CD7
3CCE:	ld	$16,&H5B	;'['
3CD1:	cal	&H2AF1		;display character $16
3CD4:	cal	&H2D94
3CD7:	ld	$16,&H5D	;']'
3CDA:	jp	&H2AF1		;display character $16

; command DELETE, prefix 4, code &H55
3CDD:	cal	&H5053		;check if BASIC and not RUN mode, no password
3CE0:	cal	&H3CE5
3CE3:	jr	&H3D47

3CE5:	cal	&H003C		;ENDSC, test for an end of a BASIC line
3CE8:	jp	c,&H2B70	;SN Error, syntax
3CEB:	cal	&H1F1A		;parse the input buffer for line number range
3CEE:	cal	&H5173		;LNSCH, search for a BASIC line $4,$5
3CF1:	phsw	$20
3CF3:	ldw	$15,$6
3CF6:	cal	&H0B8C		;search for a BASIC line $15,$16
3CF9:	jr	nc,&H3D00
3CFB:	sbc	(iz+$sx),$31
3CFD:	cal	nz,&H5952
3D00:	cal	&H340F
3D03:	ppsw	$0
3D05:	gre	iz,$2
3D07:	sbw	$2,$sz
3D09:	ldw	$19,$sz
3D0B:	jp	&H34EA		;shrink a memory block in a RAM file
3D0E:	cal	&H5056
3D11:	cal	&H0093		;SN Error if not an end of a BASIC line
3D14:	ld	$14,$sx
3D16:	cal	&H6B63
3D19:	cal	&H33FA		;$2,$3 <- file size
3D1C:	cal	nz,&H6B9D	;display a text file
3D1F:	jr	&H3D44

; command LLIST, prefix 4, code &H58
3D21:	cal	&H2989		;select the printer as the output device
3D24:	jr	&H3D29

; command LIST, prefix 4, code &H57
3D26:	cal	&H2981
3D29:	cal	&H00CD		;test for '#'
3D2C:	jr	z,&H3D0E	;list text file F0
3D2E:	cal	&H5053		;check if BASIC and not RUN mode, no password
3D31:	ld	$2,&HBB		;code of the keyword "ALL"
3D34:	cal	&H00E9		;test for keyword prefix 7 and code $2
3D37:	jr	z,&H3D57
3D39:	cal	&H00CF		;test for '.'
3D3C:	jr	z,&H3D4A	;branch if LIST .
3D3E:	cal	&H1F1A		;parse the input buffer for line number range
3D41:	cal	&H3D91		;list a BASIC program file
3D44:	cal	&H2991		;select the LCD as the output device
3D47:	jp	&H1FB9
; LIST the most recently handled line number
3D4A:	pre	ix,&H16CB	;NOWLN, current execution line number
3D4E:	ldw	$4,(ix+$sx)
3D50:	ldw	$6,(ix+$sx)
3D52:	cal	&H0093		;SN Error if not an end of a BASIC line
3D55:	jr	&H3D41
; LIST all programs
3D57:	cal	&H0093		;SN Error if not an end of a BASIC line
3D5A:	ld	$17,$sx		;starting file number = 0
3D5C:	phs	$17
3D5E:	ld	$14,$17
3D61:	cal	&H6B57
3D64:	cal	&H33EE		;get starting/ending address of current file
3D67:	cal	&H33FA		;$2,$3 <- file size
3D6A:	jr	z,&H3D81
3D6C:	cal	&H2AE8		;OUTCR, display CR-LF
3D6F:	ld	$16,&H50	;'P'
3D72:	cal	&H2AF1		;display character $16
3D75:	ld	$16,$17		;file number
3D78:	cal	&H7BD7		;display character $16 + '0'
3D7B:	cal	&H2AE8		;OUTCR, display CR-LF
3D7E:	cal	&H3D8C		;list a BASIC program file
3D81:	pps	$17
3D83:	adb	$17,$sy		;increment the file number
3D85:	jr	uz,&H3D5C	;next file
3D87:	cal	&H3402
3D8A:	jr	&H3D44

; list a BASIC program file to the OUTDV device
3D8C:	sbbm	$4,$4,4
3D8F:	sbw	$6,$sy
3D91:	cal	&H5173		;LNSCH, search for a BASIC line $4,$5
3D94:	adc	(iz+$sx),$31
3D96:	phsw	$7
3D98:	cal	nz,&H2AE8	;OUTCR, display CR-LF
3D9B:	ppsw	$6
; this loop displays BASIC line pointed to by the IZ register
3D9D:	adc	(iz+$sx),$31
3D9F:	rtn	z
3DA0:	sbcw	(iz+$sy),$6
3DA2:	jr	z,&H3DA5
3DA4:	rtn	nc
3DA5:	phsw	$7
3DA7:	cal	&H508B		;ENLST
3DAA:	gre	iz,$17
3DAC:	std	$31,(ix+$sx)
3DAE:	pre	ix,&H1000
; character display loop
3DB2:	ldi	$16,(ix+$sx)
3DB4:	adc	$16,$sx
3DB6:	jr	z,&H3DC0
3DB8:	gre	ix,$19
3DBA:	cal	&H3DCB
3DBD:	pre	ix,$19,jr &H3DB2 ;next character
3DC0:	cal	&H2AE8		;OUTCR, display CR-LF
3DC3:	cal	&H49F5
3DC6:	ppsw	$6
3DC8:	pre	iz,$17,jr &H3D9D ;next line

3DCB:	pre	ix,&H1739	;OUTDV, output device
3DCF:	ldd	$0,(ix+$sx)
3DD1:	anc	$0,&H0F
3DD4:	jr	nz,&H3DDC	;branch if not LCD
3DD6:	cal	&H505C
3DD9:	jp	&H2AF1		;display character $16
3DDC:	sbc	$0,&H08
3DDF:	jr	nz,&H3DE9
3DE1:	pre	ix,&H173B	;PRT ON/OFF
3DE5:	sbc	(ix+$sx),$30
3DE7:	jr	nz,&H3DD6
3DE9:	cal	&H29C5		;test the power switch and BRK key
3DEC:	jr	&H3DD9

; command INPUT, prefix 6, code &H9B
3DEE:	cal	&H5044		;FC Error if BASIC interpreter not in RUN mode
3DF1:	cal	&H00CD		;test for '#'
3DF4:	jr	nz,&H3E66	;input from the keyboard
; INPUT# from a file
3DF6:	cal	&H3EB1
3DF9:	cal	&H00DB		;test for a comma, SN Error if not found
3DFC:	phsw	$9
3DFE:	cal	&H2F01		;variable specification -> variable work area
3E01:	ppsw	$8
3E03:	pre	ix,&H1000
3E07:	gre	iz,$19
3E09:	phsw	$20
3E0B:	cal	&H4D2B
3E0E:	pre	iz,&H1000
3E12:	phsw	$9
3E14:	ld	$1,$sx
3E16:	cal	&H129D
3E19:	ppsw	$8
3E1B:	ppsw	$19
3E1D:	pre	iz,$19
3E1F:	cal	&H00C3		;test for a comma
3E22:	jr	z,&H3DFC
3E24:	jr	&H3E63

; command LINE, prefix 4, code &H90
3E26:	ld	$2,&H9B
3E29:	cal	&H00EB
3E2C:	jp	nz,&H2B70	;SN Error, syntax
3E2F:	cal	&H00CD		;test for '#'
3E32:	jr	nz,&H3E2C
3E34:	cal	&H3EB1
3E37:	cal	&H00DB
3E3A:	phsw	$9
3E3C:	cal	&H2F01
3E3F:	ppsw	$8
3E41:	pre	ix,&H167F
3E45:	sbc	(ix+$sx),$31
3E47:	jp	nlz,&H2BA8	;FC Error, unrecognized command
3E4A:	gre	iz,$21
3E4C:	phsw	$22
3E4E:	pre	ix,&H1000
3E52:	cal	&H4D28
3E55:	ppsw	$21
3E57:	pre	iz,$21
3E59:	ld	$17,$23
3E5C:	ldw	$15,&H1000
3E60:	cal	&H31AD
3E63:	jp	&H0093		;SN Error if not an end of a BASIC line

; command INPUT from the keyboard
3E66:	gre	iz,$0
3E68:	pre	ix,&H16EA	;INPER, return address for INPUT error
3E6C:	stw	$0,(ix+$sx)
3E6E:	pre	us,&H1CD0
3E72:	pre	ix,&H16EA
3E76:	ldw	$0,(ix+$sx)
3E78:	pre	iz,$0
3E7A:	cal	&H0049		;NEXTC, get next character other than space
3E7D:	sbbm	$20,$20,4
3E80:	ld	$18,$sy
3E82:	sbc	$0,&H22		;quotation mark?
3E85:	jr	nz,&H3E9C
; message to print
3E87:	cal	&H11D2		;evaluate a string expression
3E8A:	ldw	$21,$15		;message address
3E8D:	ld	$20,$17		;message length
3E90:	ld	$18,$sy		;$18 <- 1, semicolon used as separator
3E92:	cal	&H00CB		;test for a semicolon
3E95:	jr	z,&H3E9C
3E97:	cal	&H00DB		;test for a comma, SN Error if not found
3E9A:	ld	$18,$sx		;$18 <- 0, comma used as separator
; variable assignment
3E9C:	phsm	$23,6
3E9F:	cal	&H2F01		;variable specification -> variable work area
3EA2:	ppsm	$18,6
3EA5:	cal	&H2FAD		;ask the user for the variable contents
3EA8:	jr	nz,&H3E6E
3EAA:	cal	&H00C3		;test for a comma
3EAD:	jr	z,&H3E66	;next message+variable group
3EAF:	jr	&H3E63		;SN Error if not an end of a BASIC line

3EB1:	cal	&H3EBF
3EB4:	sbc	$0,&H32		;access mode = INPUT
3EB7:	rtn	z
3EB8:	sbc	$0,&H41
3EBB:	rtn	z
3EBC:	jp	&H2BDB		;AM Error, file access

3EBF:	cal	&H4FD0
3EC2:	pre	ix,&H1770
3EC6:	ldw	$0,(ix+$sx)
3EC8:	sbcw	$0,$sy		;is the file opened?
3ECA:	jp	c,&H2BD7	;OP Error if not
3ECD:	ld	$0,(ix+&H03)	;access mode
3ED0:	rtn

3ED1:	cal	&H2985		;select the file as the output device
3ED4:	cal	&H3EBF
3ED7:	sb	$0,&H31		;access mode = RANDOM
3EDA:	jp	z,&H2BDB	;AM Error, file access
3EDD:	sb	$0,$sy
3EDF:	jp	z,&H2BDB	;AM Error, file access
3EE2:	cal	&H003C		;ENDSC, test for an end of a BASIC line
3EE5:	jr	c,&H3F07
3EE7:	cal	&H00DB
3EEA:	jr	&H3EF9

; command LPRINT, prefix 4, code &HA4
3EEC:	cal	&H2989		;select the printer as the output device
3EEF:	jr	&H3EF9

; command PRINT, prefix 4, code &HA3
3EF1:	cal	&H2981
3EF4:	cal	&H00CD		;test for '#'
3EF7:	jr	z,&H3ED1
3EF9:	ld	$2,&HC2
3EFC:	cal	&H00E9		;test for keyword prefix 7 and code $2
3EFF:	jp	z,&H3FC6
3F02:	cal	&H003C		;ENDSC, test for an end of a BASIC line
3F05:	jr	nc,&H3F0D
3F07:	cal	&H2AE8		;OUTCR, display CR-LF
3F0A:	jp	&H2991		;select the LCD as the output device
3F0D:	sbc	$0,&H3B
3F10:	jr	z,&H3F1A
3F12:	sbc	$0,&H2C
3F15:	jr	nz,&H3F23
3F17:	cal	&H517C
3F1A:	ldd	$0,(iz+$sy)
3F1C:	cal	&H003C		;ENDSC, test for an end of a BASIC line
3F1F:	jr	nc,&H3F0D
3F21:	jr	&H3F0A
3F23:	sbc	$0,&H07
3F26:	jr	nz,&H3F53
3F28:	ld	$0,(iz+$sy)
3F2A:	sb	$0,&HBB
3F2D:	jr	nc,&H3F53
3F2F:	ad	$0,&H05
3F32:	jp	nc,&H2B70	;SN Error, syntax
3F35:	ldi	$1,(iz+$sy)
3F37:	jr	z,&H3F4A
3F39:	cal	&H3F74
3F3C:	jr	nz,&H3F02
3F3E:	sbc	$0,&H04
3F41:	jr	z,&H3F4F
3F43:	or	$1,&H20
3F46:	std	$1,(ix+$sx)
3F48:	jr	&H3F02
3F4A:	cal	&H3F8D
3F4D:	jr	&H3F02
3F4F:	an	$1,&HDF,jr &H3F46
3F53:	cal	&H1088
3F56:	gre	iz,$28
3F58:	jr	c,&H3F6F
3F5A:	cal	&H0054
3F5D:	cal	&H22A4
3F60:	cal	&H005C
3F63:	cal	&H131F
3F66:	cal	&H97D5
3F69:	cal	&H2AD7		;display a space
3F6C:	pre	iz,$28,jr &H3F02
3F6F:	cal	&H97D5
3F72:	jr	&H3F6C
3F74:	pre	ix,&H1739
3F78:	adc	(ix+$sx),$31
3F7A:	pre	ix,&H1100
3F7E:	ldd	$1,(ix+$sx)
3F80:	rtn
3F81:	pre	ix,&H1102
3F85:	ld	$1,(ix+$sy)
3F87:	ld	$0,(ix-$sy)
3F89:	sb	$0,$1,jr &H3FA1
3F8D:	cal	&H0F0D
3F90:	cal	&H0EC6
3F93:	pre	ix,&H1739
3F97:	ldd	$0,(ix+$sx)
3F99:	anc	$0,&H06
3F9C:	jr	z,&H3F81
3F9E:	cal	&H2B44
3FA1:	sb	$15,$sz
3FA3:	rtn	z
3FA4:	jr	nc,&H3FAB
3FA6:	ad	$15,$sz
3FA8:	cal	&H2AE8		;OUTCR, display CR-LF
3FAB:	ld	$17,$15
3FAE:	sb	$17,$sy
3FB0:	rtn	c
3FB1:	cal	&H2AD7		;display a space
3FB4:	jr	&H3FAE

3FB6:	A3 C3 40 2E  A3 C1 40 A1  A3 40 A6 AA  40 C0 BE 40

3FC6:	cal	&H11D2		;evaluate a string expression
3FC9:	cal	&H125D		;append zero
3FCC:	cal	&H00D7
3FCF:	phsw	$16
3FD1:	phsw	$16
3FD3:	cal	&H1088
3FD6:	gre	iz,$28
3FD8:	jr	c,&H4020
3FDA:	cal	&H0054
3FDD:	ppsw	$15
3FDF:	cal	&H4053
3FE2:	jp	z,&H2BB0
3FE5:	jp	c,&H2BB0
3FE8:	gre	iz,$15
3FEA:	phsw	$16
3FEC:	cal	&H419E
3FEF:	cal	&H97D5
3FF2:	ppsw	$15
3FF4:	cal	&H4053
3FF7:	jr	nz,&H3FFD
3FF9:	ppsw	$15
3FFB:	phsw	$16
3FFD:	pre	iz,$28
3FFF:	cal	&H003C		;ENDSC, test for an end of a BASIC line
4002:	jr	c,&H401B
4004:	sbc	$0,&H3B
4007:	jr	z,&H400F
4009:	sbc	$0,&H2C
400C:	jp	nz,&H2B70	;SN Error, syntax
400F:	ldd	$0,(iz+$sy)
4011:	cal	&H003C		;ENDSC, test for an end of a BASIC line
4014:	jr	nc,&H3FD1
4016:	ppsw	$0
4018:	jp	&H2991		;select the LCD as the output device
401B:	cal	&H2AE8		;OUTCR, display CR-LF
401E:	jr	&H4016
4020:	ldm	$19,$15,3
4023:	ppsw	$15
4025:	cal	&H4053
4028:	jp	nc,&H2BB0
402B:	gre	iz,$15
402D:	phsw	$16
402F:	sbc	$17,$21
4032:	jr	c,&H4041
4034:	adc	$17,$sy
4036:	jr	c,&H403E
4038:	sb	$17,$21
403B:	ld	$27,$17
403E:	ld	$17,$21
4041:	gfl	$26
4043:	ldw	$15,$19
4046:	cal	&H97D5
4049:	ld	$17,$27
404C:	pfl	$26
404E:	cal	nc,&H3FAE
4051:	jr	&H3FF2
4053:	sbbm	$23,$23,4
4056:	ld	$24,&H10
4059:	gst	ua,$1
405B:	phs	$1
405D:	pst	ua,&H44
4060:	pre	ix,&H3FB6
4064:	pre	iz,$15
4066:	ldi	$0,(iz+$sx)
4068:	ldd	$1,(ix+$sx)
406A:	an	$1,&H7F
406D:	ldi	$2,(ix+$sx)
406F:	sbc	$1,$sz
4071:	jr	nz,&H4081
4073:	biu	$2
4075:	jr	nc,&H4066
4077:	ldd	$0,(iz-$sy)
4079:	ldw	$5,(ix+$sx)
407B:	pps	$1
407D:	pst	ua,$1
407F:	jp	$5
4081:	biu	$2
4083:	ldi	$2,(ix+$sx)
4085:	jr	nc,&H4081
4087:	ldd	$0,(ix+$sy)
4089:	sbc	$1,&H40
408C:	jr	nz,&H4064
408E:	pps	$1
4090:	pst	ua,$1
4092:	pre	iz,$15
4094:	ldi	$16,(iz+$sx)
4096:	adc	$16,$sx
4098:	jr	z,&H40A0
409A:	cal	&H2AF1		;display character $16
409D:	gre	iz,$15,jr &H4059
40A0:	ldd	$0,(iz-$sy)
40A2:	rtn
40A3:	ld	$17,$sy
40A5:	ldd	$0,(iz+$sy)
40A7:	sbc	$31,$sy
40A9:	rtn
40AA:	gre	iz,$1
40AC:	ldd	$3,(iz+$sy)
40AE:	cal	&H0049
40B1:	sbc	$0,&H26
40B4:	jr	nz,&H4092
40B6:	ldd	$0,(iz+$sy)
40B8:	gre	iz,$17
40BA:	sbw	$17,$1,jr &H40A7
40BE:	na	$17,$sx,jr &H40A5
40C1:	ldd	$0,(iz-$sy)
40C3:	ldi	$0,(iz+$sx)
40C5:	sbc	$0,&H23
40C8:	jr	nz,&H40D5
40CA:	anc	$24,&H04
40CD:	jr	z,&H40D2
40CF:	ad	$26,$sy,jr &H40C3
40D2:	ad	$25,$sy,jr &H40C3
40D5:	sbc	$0,&H2E
40D8:	jr	nz,&H40E3
40DA:	anc	$24,&H04
40DD:	jr	nz,&H410C
40DF:	or	$24,&H04,jr &H40C3
40E3:	sbc	$0,&H2C
40E6:	jr	nz,&H40F1
40E8:	anc	$24,&H04
40EB:	jr	nz,&H410C
40ED:	or	$24,&H02,jr &H40D2
40F1:	sbc	$0,&H5E
40F4:	jr	nz,&H410C
40F6:	gre	iz,$0
40F8:	ld	$2,&H03
40FB:	ldi	$3,(iz+$sx)
40FD:	sbc	$3,&H5E
4100:	jr	nz,&H410A
4102:	sb	$2,$sy
4104:	jr	nz,&H40FB
4106:	or	$24,&H08,jr &H410E
410A:	pre	iz,$0
410C:	ldd	$0,(iz-$sy)
410E:	or	$24,&H10
4111:	ldw	$0,$25
4114:	ad	$1,$sz
4116:	sbc	$1,&H20
4119:	jp	nc,&H2B70	;SN Error, syntax
411C:	adc	$1,$sx
411E:	rtn
411F:	sbc	$25,&H02
4122:	jr	nc,&H4153
4124:	adc	$26,$sx
4126:	jr	z,&H4184
4128:	ld	$7,$26
412B:	cal	&H179E
412E:	adc	$25,$sx
4130:	jr	nz,&H4139
4132:	sbc	$22,&H05
4135:	jr	nc,&H4184
4137:	or	$24,$sy
4139:	sbcw	$17,$sy
413B:	jr	c,&H4148
413D:	adc	$18,$sx
413F:	jr	z,&H4146
4141:	sbc	$17,&H99
4144:	jr	z,&H4184
4146:	adbw	$17,$sy
4148:	adc	$25,$sx
414A:	jr	z,&H414E
414C:	sb	$25,$sy
414E:	ld	$0,$sx
4150:	jp	&H4202
4153:	ld	$7,$25
4156:	ad	$7,$26
4159:	sb	$7,$sy
415B:	cal	&H179E
415E:	ld	$0,$25
4161:	sb	$0,&H02
4164:	cal	&H519F
4167:	anc	$18,$sy
4169:	jr	nz,&H417B
416B:	sbc	$0,$17
416E:	jr	c,&H417B
4170:	sbc	$17,$sy
4172:	jr	nc,&H4184
4174:	ld	$0,$25
4177:	sb	$0,&H02,jr &H4181
417B:	ld	$1,$sx
417D:	sbbw	$17,$sz
417F:	ld	$0,$sx
4181:	sb	$25,$sy,jr &H4202
4184:	pre	us,&H1CC7
4188:	cal	&H005C
418B:	phsm	$18,8
418E:	phs	$10
4190:	ld	$16,&H25	;'%'
4193:	cal	&H2AF1		;display character $16
4196:	pps	$10
4198:	ppsm	$11,8
419B:	jp	&H13A7
419E:	cal	&H005C
41A1:	ld	$22,$18
41A4:	cal	&H0A25		;absolute value of a FP number $10-$18
41A7:	pre	ix,&H165E
41AB:	anc	$24,&H08
41AE:	jp	nz,&H411F
41B1:	sbc	$22,&H05
41B4:	jr	c,&H4212
41B6:	sb	$25,$sy
41B8:	jr	c,&H4184
41BA:	ld	$7,$26
41BD:	phsw	$18
41BF:	adc	$18,$sx
41C1:	jr	nz,&H4215
41C3:	byuw	$17
41C5:	sbb	$17,$18
41C8:	cal	&H0AFA		;NISIN, BCD to binary conversion
41CB:	sb	$7,$17
41CE:	ad	$7,$sy
41D0:	ppsw	$17
41D2:	cal	&H179E
41D5:	phs	$17
41D7:	cal	&H0AFA		;NISIN, BCD to binary conversion
41DA:	ld	$0,$17
41DD:	ld	$20,$sz
41DF:	pps	$17
41E1:	adc	$18,$sx
41E3:	jr	z,&H41F9
41E5:	anc	$24,&H02
41E8:	jr	z,&H421C
41EA:	sbc	$0,$25
41ED:	jr	nc,&H4184
41EF:	ld	$19,$sz
41F1:	sb	$19,&H03
41F4:	jr	c,&H421C
41F6:	sb	$25,$sy,jr &H41F1
41F9:	ld	$0,$25
41FC:	sb	$0,$sy
41FE:	jr	nc,&H4202
4200:	ld	$0,$sx
4202:	sbcw	$25,$sy
4204:	jr	c,&H41B8
4206:	ld	$21,&H20
4209:	sb	$0,$sy
420B:	jr	c,&H4227
420D:	sti	$21,(ix+$sx)
420F:	sb	$25,$sy,jr &H4209
4212:	or	$24,$sy,jr &H41BA
4215:	cal	&H0AFA		;NISIN, BCD to binary conversion
4218:	ad	$7,$17,jr &H41CE
421C:	sb	$0,$25
421F:	jp	nc,&H4184
4222:	ad	$0,$sy
4224:	cmp	$0,jr &H4202
4227:	ld	$19,$22
422A:	anc	$24,$sy
422C:	cal	z,&H0B12
422F:	adc	$25,$sx
4231:	jr	z,&H4241
4233:	anc	$24,&H08
4236:	jr	nz,&H4275
4238:	adc	$18,$sx
423A:	jr	nz,&H4275
423C:	ld	$21,&H30
423F:	sti	$21,(ix+$sx)
4241:	anc	$24,&H04
4244:	jr	z,&H4268
4246:	ld	$21,&H2E
4249:	sti	$21,(ix+$sx)
424B:	adc	$26,$sx
424D:	jr	z,&H4268
424F:	anc	$24,&H08
4252:	jr	nz,&H4297
4254:	adc	$18,$sx
4256:	jr	nz,&H4297
4258:	ld	$21,&H30
425B:	ad	$20,$sy
425D:	sbc	$20,&H64
4260:	jr	z,&H4297
4262:	sti	$21,(ix+$sx)
4264:	sb	$26,$sy
4266:	jr	nz,&H425B
4268:	anc	$24,&H08
426B:	cal	nz,&H12F1
426E:	ldw	$15,&H165E
4272:	jp	&H143B
4275:	cal	&H12E5
4278:	sb	$25,$sy
427A:	jr	z,&H4241
427C:	anc	$24,&H02
427F:	jr	z,&H4275
4281:	anc	$24,&H08
4284:	jr	nz,&H4275
4286:	ld	$0,$25
4289:	sb	$0,&H03
428C:	jr	c,&H4275
428E:	jr	nz,&H4289
4290:	ld	$21,&H2C
4293:	sti	$21,(ix+$sx)
4295:	jr	&H4275
4297:	cal	&H12E5
429A:	sb	$26,$sy
429C:	jr	nz,&H4297
429E:	jr	&H4268
42A0:	cal	&H5044		;FC Error if BASIC interpreter not in RUN mode
42A3:	cal	&H00CD		;test for '#'
42A6:	jp	z,&H543D
42A9:	cal	&H2F01
42AC:	gre	iz,$0
42AE:	phsw	$1
42B0:	pre	ix,&H16DB
42B4:	ldw	$15,(ix+$sx)
42B6:	pre	iz,$15
42B8:	sbcw	$15,$sy
42BA:	jr	c,&H42CF
42BC:	cal	&H00C3
42BF:	jr	z,&H42D7
42C1:	ldd	$1,(iz+$sy)
42C3:	sbc	$0,&H80
42C6:	jr	z,&H42D7
42C8:	adc	$0,$sx
42CA:	jr	z,&H42D4
42CC:	jp	&H2B70		;SN Error, syntax
42CF:	cal	&H33EE		;get starting/ending address of current file
42D2:	pre	iz,$25
42D4:	cal	&H0BAC
42D7:	ld	$1,$sy
42D9:	cal	&H129D
42DC:	gre	iz,$15
42DE:	cal	&H4313
42E1:	ppsw	$0
42E3:	pre	iz,$0
42E5:	cal	&H00C3
42E8:	jr	z,&H42A9
42EA:	rtn

; command RESTORE, prefix 4, code &H4D
42EB:	cal	&H5044		;FC Error if BASIC interpreter not in RUN mode
42EE:	cal	&H00CD		;test for '#'
42F1:	jp	z,&H56EA
42F4:	cal	&H0049
42F7:	sbc	$0,&H03
42FA:	jr	c,&H431E
42FC:	jr	z,&H431A
42FE:	cal	&H0F0D
4301:	cal	&H0EE2
4304:	gre	iz,$23
4306:	cal	&H5176		;LNSCH, search for a BASIC line $4,$5
4309:	jp	nc,&H2BAC
430C:	cal	&H0BAC
430F:	sbw	$15,$sy
4311:	pre	iz,$23
4313:	pre	ix,&H16DB
4317:	stw	$15,(ix+$sx)
4319:	rtn
431A:	ldiw	$15,(iz+$sy)
431C:	jr	&H4304
431E:	sbw	$15,$15,jr &H4313

; command STAT, prefix 4, code &HAD
4322:	cal	&H003C		;ENDSC, test for an end of a BASIC line
4325:	jr	c,&H4357
4327:	ld	$2,&H6A
432A:	cal	&H00EF
432D:	jr	nz,&H433A
432F:	ldw	$0,&H16F1
4333:	ldw	$2,&H0048
4337:	jp	&H0157		;CLRME, clear memory block
433A:	cal	&H003C		;ENDSC, test for an end of a BASIC line
433D:	jr	z,&H4357
433F:	cal	&H00C3
4342:	jr	z,&H43A1
4344:	cal	&H112F
4347:	cal	&H1BED
434A:	cal	&H51B4
434D:	cal	&H00C3
4350:	jr	z,&H43A1
4352:	cal	&H00CB
4355:	jr	z,&H43A6
4357:	cal	&H0669
435A:	cal	&H06B8
435D:	cal	&H0093		;SN Error if not an end of a BASIC line
4360:	pre	ix,&H165E
4364:	stim	$10,(ix+$sx),8
4367:	std	$18,(ix+$sx)
4369:	ld	$29,$sx
436B:	ld	$28,&H13
436E:	pre	ix,&H165E
4372:	ldim	$10,(ix+$sx),8
4375:	ldd	$18,(ix+$sx)
4377:	sbc	$28,&H13
437A:	jr	z,&H4387
437C:	anc	$28,$sy
437E:	cal	&H43B6
4381:	sbc	$28,&H2E
4384:	cal	nc,&H43B6
4387:	cal	&H1C0B
438A:	cal	&H05DA
438D:	sbc	$29,&H80
4390:	cal	z,&H51B1
4393:	ad	$28,&H09
4396:	sbc	$28,&H41
4399:	jr	c,&H436E
439B:	ad	$29,&H80
439E:	jr	nc,&H436B
43A0:	rtn
43A1:	cal	&H00CB
43A4:	jr	nz,&H43AB
43A6:	cal	&H112F
43A9:	jr	&H435D
43AB:	cal	&H112F
43AE:	cal	&H1BF0
43B1:	cal	&H51B4
43B4:	jr	&H4352
43B6:	phs	$28
43B8:	ld	$28,$sy
43BA:	jr	z,&H43BF
43BC:	ld	$28,&H0A
43BF:	cal	&H1C0B
43C2:	pps	$28
43C4:	jp	&H0607

; command BEEP, prefix 4, code &H70
43C7:	cal	&H003C		;ENDSC, test for an end of a BASIC line
43CA:	jr	c,&H43D7
43CC:	cal	&H0EC3		;evaluate num. expression to integer (byte)
43CF:	sbcw	$15,$sy
43D1:	jp	z,&H33B3
43D4:	jp	nc,&H2BA4	;BS Error, subscript out of range
43D7:	jp	&H33BA

; command RENUM, prefix 4, code &H5C
43DA:	cal	&H5053		;check if BASIC and not RUN mode, no password
43DD:	ldw	$15,&H000A
43E1:	sbw	$17,$17
43E4:	ldw	$19,&H000A
43E8:	cal	&H003C		;ENDSC, test for an end of a BASIC line
43EB:	jr	c,&H4436
43ED:	cal	&H00C3
43F0:	jr	z,&H4409
43F2:	phsm	$18,4
43F5:	cal	&H112F
43F8:	cal	&H0EE8
43FB:	ldw	$19,$15
43FE:	ppsm	$15,4
4401:	cal	&H003C		;ENDSC, test for an end of a BASIC line
4404:	jr	c,&H4436
4406:	cal	&H00DB
4409:	cal	&H00C3
440C:	jr	z,&H4427
440E:	phsw	$20
4410:	phsw	$16
4412:	cal	&H112F
4415:	cal	&H0EE8
4418:	ldw	$17,$15
441B:	ppsw	$15
441D:	ppsw	$19
441F:	cal	&H003C		;ENDSC, test for an end of a BASIC line
4422:	jr	c,&H4436
4424:	cal	&H00DB
4427:	phsm	$20,4
442A:	cal	&H112F
442D:	cal	&H0EE8
4430:	ppsm	$17,4
4433:	cal	&H0093		;SN Error if not an end of a BASIC line
4436:	gre	iz,$23
4438:	cal	&H33EE		;get starting/ending address of current file
443B:	cal	&H33FA		;$2,$3 <- file size
443E:	jp	z,&H1FB9
4441:	pre	iz,$25
4443:	sbcw	$17,$sy
4445:	ldw	$3,$sy
4447:	jr	c,&H445B
4449:	sbw	$1,$1
444C:	ldw	$5,$17
444F:	cal	&H4535
4452:	jp	nc,&H2BAC
4455:	sbcw	$1,$19
4458:	jp	nc,&H2BA8	;FC Error, unrecognized command
445B:	sbw	$3,$sy
445D:	phuw	$4
445F:	gre	iz,$21
4461:	sbw	$5,$5
4464:	cal	&H4535
4467:	sbw	$3,$sy
4469:	cal	&H454A
446C:	adcw	$19,$sz
446E:	jp	c,&H2B98	;OV Error, overflow
4471:	ld	$29,$sx
4473:	pre	iz,$25
4475:	sbw	$13,$13
4478:	sbc	(iz+$sx),$31
447A:	jr	z,&H44E6
447C:	ldim	$0,(iz+$sx),3
447F:	pre	ix,&H16CB
4483:	stw	$1,(ix+$sx)
4485:	pre	ix,&H1795
4489:	sbcw	$1,$17
448C:	jr	c,&H4497
448E:	ldw	$1,$19
4491:	adw	$1,$13
4494:	adw	$13,$15
4497:	stim	$0,(ix+$sx),3
449A:	ldi	$0,(iz+$sx)
449C:	sti	$0,(ix+$sx)
449E:	sbc	$0,$sx
44A0:	jr	z,&H44CD
44A2:	sbc	$0,&H03
44A5:	jr	nz,&H449A
44A7:	ldiw	$5,(iz+$sx)
44A9:	gre	iz,$7
44AB:	cal	&H4533
44AE:	jr	nc,&H44C6
44B0:	sbcw	$5,$17
44B3:	jr	c,&H44C9
44B5:	ppuw	$0
44B7:	phuw	$1
44B9:	sbw	$3,$sz
44BB:	cal	&H454A
44BE:	adw	$0,$19
44C1:	stiw	$0,(ix+$sx)
44C3:	pre	iz,$7,jr &H449A
44C6:	cal	&H455E
44C9:	ldw	$0,$5,jr &H44C1
44CD:	gre	iz,$11
44CF:	pre	iz,&H1795
44D3:	phsm	$16,6
44D6:	cal	&H29C5		;test the power switch and BRK key
44D9:	cal	&H508B		;ENLST
44DC:	ppsm	$11,6
44DF:	pre	iz,$11
44E1:	cal	c,&H455A
44E4:	jr	&H4478
44E6:	cal	&H340F
44E9:	sbc	$29,$sx
44EB:	jp	nz,&H1FB9
44EE:	pre	iz,$25
44F0:	sbc	(iz+$sx),$31
44F2:	jr	z,&H451E
44F4:	ldd	$0,(iz+&H03)
44F7:	ldi	$0,(iz+$sx)
44F9:	sbc	$0,$sx
44FB:	jr	z,&H44F0
44FD:	sbc	$0,&H03
4500:	jr	nz,&H44F7
4502:	ldw	$0,(iz+$sx)
4504:	sbcw	$0,$17
4507:	jr	c,&H451A
4509:	gre	iz,$7
450B:	pre	iz,$21
450D:	ldw	$5,$sz
450F:	cal	&H4535
4512:	cal	&H454A
4515:	adw	$0,$19
4518:	pre	iz,$7
451A:	stiw	$0,(iz+$sx)
451C:	jr	&H44F7
451E:	pre	iz,$21
4520:	stw	$19,(iz+$sy)
4522:	ldd	$0,(iz+$sx)
4524:	ldi	$0,(iz+$sz)
4526:	sbc	(iz+$sx),$31
4528:	jr	z,&H452E
452A:	adw	$19,$15,jr &H4520
452E:	pre	iz,$23
4530:	jp	&H1FB9
4533:	pre	iz,$25
4535:	ldw	$3,$sy
4537:	sbc	(iz+$sx),$31
4539:	jr	z,&H4549
453B:	sbcw	(iz+$sy),$5
453D:	jr	z,&H4547
453F:	ldm	$0,(iz+$sx),3
4542:	ldi	$0,(iz+$sz)
4544:	adw	$3,$sy,jr &H4537
4547:	sbc	$31,$sy
4549:	rtn
454A:	phsw	$16
454C:	ldw	$5,$3
454F:	sbw	$5,$sy
4551:	cal	&H0A35
4554:	jp	c,&H2B98	;OV Error, overflow
4557:	ppsw	$15
4559:	rtn
455A:	ld	$0,&H05,jr &H4561
455E:	ld	$0,&H12
4561:	ld	$29,$sy
4563:	gre	ix,$1
4565:	phsm	$8,8
4568:	phsm	$16,8
456B:	phsm	$24,8
456E:	ld	$18,$sz
4570:	pre	ix,&H16C6
4574:	std	$30,(ix+$sx)
4576:	cal	&H2D0A
4579:	cal	&H032E		;cursor display disable
457C:	cal	&H23C8
457F:	cal	&H032E		;cursor display disable
4582:	pre	ix,&H16C6
4586:	std	$31,(ix+$sx)
4588:	ppsm	$17,8
458B:	ppsm	$9,8
458E:	ppsm	$1,8
4591:	pre	ix,$1
4593:	rtn

; command NEW, prefix 4, code &H6B
4594:	cal	&H5056
4597:	cal	&H00CD		;test for '#'
459A:	jr	z,&H45B0
459C:	cal	&H5037
459F:	ld	$2,&HBB		;code of the keyword "ALL"
45A2:	cal	&H00E9		;test for keyword prefix 7 and code $2
45A5:	jr	z,&H45BC
45A7:	cal	&H0093		;SN Error if not an end of a BASIC line
45AA:	cal	&H45D1		;delete the current file
45AD:	jp	&H2431
45B0:	cal	&H0093		;SN Error if not an end of a BASIC line
45B3:	ld	$14,&H0A
45B6:	cal	&H45DA
45B9:	jp	&H1FB9
45BC:	cal	&H0093		;SN Error if not an end of a BASIC line
45BF:	ld	$14,&H09
45C2:	cal	&H45DA
45C5:	sb	$14,$sy
45C7:	jr	nc,&H45C2
45C9:	cal	&H5416
45CC:	cal	&H3402
45CF:	jr	&H45AD

; delete the current file
45D1:	cal	&H33EE		;get starting/ending address of current file
45D4:	cal	&H33FA		;$2,$3 <- file size
45D7:	jp	&H34EA		;shrink a memory block in a RAM file

45DA:	cal	&H3428
45DD:	jr	&H45D4

; command OPEN, prefix 4, code &H97
45DF:	cal	&H5044		;FC Error if BASIC interpreter not in RUN mode
45E2:	cal	&H4E43		;process the file descriptor
45E5:	pre	ix,&H1770
45E9:	sbcw	(ix+$sx),$30
45EB:	jp	nc,&H2BD7	;OP Error if the file #1 is already opened
45EE:	ldw	$2,&H3181	;code of the keyword "FOR"
45F2:	cal	&H00EF		;test for keyword prefix 4 and code $2
45F5:	jr	nz,&H461B
45F7:	ldw	$2,&H329B	;code of the keyword "INPUT"
45FB:	cal	&H00EB		;test for keyword prefix 6 and code $2
45FE:	jr	z,&H461B
4600:	ldw	$2,&H34BD	;code of the keyword "APPEND"
4604:	cal	&H00E9		;test for keyword prefix 7 and code $2
4607:	jr	z,&H461B
; the keyword "OUTPUT" is coded with two tokens: "OUT"+"PUT"
4609:	ld	$2,&H99		;code of the keyword "OUT"
460C:	cal	&H00EF		;test for keyword prefix 4 and code $2
460F:	jp	nz,&H2B70	;SN Error, syntax
4612:	ldw	$2,&H30A5	;code of the keyword "PUT"
4616:	cal	&H00EF		;test for keyword prefix 4 and code $2
4619:	jr	nz,&H460F
461B:	ld	$2,&HBC		;code of the keyword "AS"
461E:	cal	&H00E9		;test for keyword prefix 7 and code $2
4621:	jr	nz,&H460F
4623:	ld	$10,$3		;access mode = keyword code
4626:	phsm	$13,4
4629:	cal	&H4FCD		;parse the command string for the file handle
462C:	ppsm	$10,4
462F:	cal	&H0093		;SN Error if not an end of a BASIC line
4632:	ld	$9,$sy
4634:	ld	$14,&H24
;
4637:	pre	ix,&H1770	;address of the file control block
463B:	ldw	$7,&H0123	;size of the file control block
463F:	stim	$7,(ix+$sx),5
4642:	cal	&H4FA9		;copy the file name to the file control block
4645:	pre	ix,&H1780
4649:	ldw	$2,&H1793	;data buffer
464D:	stiw	$2,(ix+$sx)	;pointer to the begin of the data buffer
464F:	sbbm	$4,$4,7
4652:	ldw	$7,$2
4655:	ad	$3,$sy
4657:	stim	$2,(ix+$sx),7
465A:	stiw	$9,(ix+$sx)
465C:	ld	$10,$14
465F:	stiw	$9,(ix+$sx)
4661:	pre	ix,&H1770
4665:	ld	$0,&H03
4668:	ldw	$10,(ix+$sz)	;$10 = access mode, $11 = device type
466A:	sbc	$11,&H02
466D:	jp	z,&H8492	;open an RS232C file
4670:	jp	nc,&H86DD	;open a cassette tape file
; RAM or FDD file
4673:	sbc	(ix+&H02),$30
4676:	jr	nc,&H46A0
4678:	sbc	$10,&H30
467B:	jr	z,&H4699	;branch if opened for OUTPUT
467D:	sbc	$14,&H10	;tokenized BASIC?
4680:	jr	nz,&H46A8	;branch if not
4682:	cal	&H819A		;load tokenized BASIC file from disk
4685:	rtn	nz		;return if not the expected file type
4686:	pre	ix,&H178C
468A:	ld	$14,&H24	;'$'
468D:	std	$14,(ix+$sx)
468F:	ldd	$15,(ix+&H03)
4692:	or	$15,$sy
4694:	std	$15,(ix+$sx)
4696:	jp	&H80A3		;open a disk file
4699:	anc	$15,$sy
469B:	jr	nz,&H4696
469D:	jp	&H80E0		;save file to disk
46A0:	sbc	$10,&H31	;access mode = RANDOM
46A3:	jp	z,&H2BDB	;AM Error, RANDOM isn't supported for disk files
46A6:	jr	&H4696
; sequential disk file
46A8:	cal	&H8146		;load untyped file from disk
46AB:	jp	nz,&H2B90	;NF Error if the file turned out to be typed
46AE:	jr	&H4696

; command CLOSE, prefix 4, code &H72
46B0:	cal	&H0093		;SN Error if not an end of a BASIC line
46B3:	cal	&H294F
46B6:	an	$1,&HDF
46B9:	std	$1,(ix+$sx)
46BB:	pre	ix,&H1770
46BF:	sbcw	(ix+$sx),$30
46C1:	jr	c,&H4702
46C3:	ld	$0,$sx
46C5:	stw	$31,(ix+$sx)
46C7:	ldm	$0,(ix+$sx),5
46CA:	anc	$3,&H02
46CD:	jr	nz,&H46D8
46CF:	ld	$5,(ix+&H1C)
46D2:	sbc	$5,&H24
46D5:	cal	z,&H4723
46D8:	cal	&H4719
46DB:	pre	ix,&H1770
46DF:	ldm	$0,(ix+$sx),5
46E2:	adc	$4,$sy
46E4:	rtn	c
46E5:	sbc	$4,&H02
46E8:	jp	nc,&H8563
46EB:	jp	&H8306		;close a disk file

46EE:	pre	ix,&H1774
46F2:	st	$31,(ix+&H18)
46F5:	ldd	$0,(ix+$sx)
46F7:	sbc	$0,&H02
46FA:	jr	nc,&H46B3
46FC:	na	$0,$sx
46FE:	std	$0,(ix+$sx)
4700:	jr	&H46B3
4702:	cal	&H0179		;INT1 interrupt disable
4705:	gst	ua,$1
4707:	gre	iz,$2
4709:	phsm	$3,3
470C:	pst	ua,&HD4
470F:	cal	&H8342		;reset the gate array registers
4712:	ppsm	$0,3
4715:	pst	ua,$0
4717:	pre	iz,$1
4719:	pre	ix,&H178D
471D:	sbw	$0,$sz
471F:	stm	$31,(ix+$sx),3
4722:	rtn
4723:	sbc	$4,&H02
4726:	rtn	z
4727:	ld	$0,&H19
472A:	ldw	$5,(ix+$sz)	;number of bytes
472C:	jp	c,&H82E3	;write from address &H1793 to a disk file
472F:	ldw	$25,&H1793	;data buffer
4733:	jp	&H49B1

; command SAVE, prefix 4, code &H6C
4736:	cal	&H4771
4739:	cal	&H477D
473C:	cal	&H294F
473F:	ldw	$0,&H0200
4743:	sbcw	(ix+$sx),$0
4745:	jp	z,&H6A4F
4748:	jp	&H1FB9

; command MERGE, prefix 4, code &H5A
474B:	ld	$15,&H30,jr &H4756
; command VERIFY, prefix 4, code &H60
474F:	ld	$15,&H40,jr &H4756
; command LOAD, prefix 4, code &H59
4753:	ld	$15,&H10
4756:	phs	$15
4758:	cal	&H4771
475B:	pps	$15
475D:	cal	&H4A13
4760:	jr	&H473C

; command CHAIN, prefix 4, code &H69
4762:	cal	&H4771
4765:	ld	$15,&H20
4768:	cal	&H4A13
476B:	cal	&H340F
476E:	jp	&H24D6

4771:	cal	&H7F05		;make sure there is not an opened file
4774:	cal	&H46B3
4777:	sbbm	$17,$17,4
477A:	jp	&H3B69

477D:	ld	$15,$sx
477F:	cal	&H48B9
4782:	sbc	$14,&H24
4785:	cal	z,&H529B	;PR Error if password set
4788:	sbc	$14,&H24
478B:	jr	z,&H47A7
478D:	anc	$15,&H02
4790:	jr	nz,&H47C2
4792:	ldw	$0,&H16C9
4796:	ldw	$0,($sz)
4798:	pre	ix,$0
479A:	ldm	$0,(ix+$sx),4
479D:	sbw	$2,$sy
479F:	sbw	$2,$sz
47A1:	pre	ix,&H178D
47A5:	stw	$2,(ix+$sx)
47A7:	phsm	$15,5
47AA:	cal	&H495F
47AD:	ppsm	$17,5
47B0:	sbc	$17,$sy
47B2:	jr	nz,&H47D0
47B4:	anc	$21,$sy
47B6:	jr	nz,&H47D0
47B8:	pre	ix,&H1770
47BC:	ld	$0,$sx
47BE:	stw	$31,(ix+$sx)
47C0:	jr	&H4825
47C2:	pre	ix,&H18A7	;table of file addresses
47C6:	ldw	$0,(ix+$sx)
47C8:	pre	ix,&H18BB
47CC:	ldw	$2,(ix+$sx)
47CE:	jr	&H479F
47D0:	cal	&H33EE		;get starting/ending address of current file
47D3:	pre	iz,$25
47D5:	sbc	$17,&H03
47D8:	jr	nz,&H47DF
47DA:	sbc	$20,&H24
47DD:	jr	nz,&H47F5
47DF:	anc	$21,$sy
47E1:	jr	nz,&H47FA
47E3:	gre	iz,$0
47E5:	adw	$0,$sy
47E7:	sbcw	$27,$sz
47E9:	jr	z,&H480F
47EB:	ldi	$16,(iz+$sx)
47ED:	cal	&H2AF1		;display character $16
47F0:	cal	&H29C5		;test the power switch and BRK key
47F3:	jr	&H47E3
47F5:	cal	&H4978
47F8:	jr	&H480F
47FA:	phs	$17
47FC:	sbbm	$4,$4,4
47FF:	sbw	$6,$sy
4801:	cal	&H5173		;LNSCH, search for a BASIC line $4,$5
4804:	cal	&H3D9D
4807:	pps	$17
4809:	sbc	$17,&H03
480C:	cal	z,&H2AE8	;OUTCR, display CR-LF
480F:	sbc	$17,&H02
4812:	jr	nz,&H4822
4814:	ld	$16,&H1A
4817:	pre	ix,&H173D
481B:	ld	$0,(ix+$sx)
481D:	anc	$0,$sy
481F:	cal	nz,&H2AF1	;display character $16
4822:	cal	&H46B3
4825:	cal	&H2A0C
4828:	cal	&H4EB8
482B:	jp	&H2991		;select the LCD as the output device

482E:	pre	ix,&H1770
4832:	ld	$7,(ix+&H04)	;device type
4835:	sbc	$7,&H02		;RS232C?
4838:	jp	z,&H85C8	;transmit $16 through the RS232C port
483B:	ld	$0,&H17
483E:	ldw	$2,(ix+$sz)
4840:	adw	(ix+$sz),$30
4842:	pre	ix,$2
4844:	sti	$16,(ix+$sx)
4846:	pre	ix,&H1770	;file control block
484A:	ld	$0,&H19
484D:	adw	(ix+$sz),$30
484F:	sbc	$7,$sy		;writing to the FDD?
4851:	jr	z,&H485E	;branch if so
4853:	sbc	(ix+&H02),$31
4856:	jr	nz,&H485E
4858:	ld	$0,(ix+&H1F)
485B:	anc	$0,$sy
485D:	rtn	nz
485E:	sbc	(ix+&H1A),$30
4861:	rtn	c
4862:	cal	&H4877
4865:	cal	&H4882
4868:	sbc	$7,$sy
486A:	jp	z,&H82E3	;write from address &H1793 to a disk file
486D:	phsm	$26,5
4870:	cal	&H49B7
4873:	ppsm	$22,5
4876:	rtn

4877:	ld	$0,&H10
487A:	ldw	$1,(ix+$sz)	;pointer to the begin of the data buffer
487C:	ld	$0,&H17
487F:	stw	$1,(ix+$sz)	;pointer to the current position
4881:	rtn

4882:	pre	ix,&H1789
4886:	ldw	$5,(ix+$sx)
4888:	ld	$0,$sx
488A:	stw	$31,(ix+$sx)
488C:	rtn

488D:	cal	&H503D
4890:	ld	$14,&H24
4893:	or	$15,&H08
4896:	sbc	$15,$sx
4898:	jr	uz,&H48CD
489A:	anc	$15,&H10
489D:	jr	nz,&H48CD
489F:	jp	&H2B70		;SN Error, syntax
48A2:	ld	$14,&H90
48A5:	or	$15,&H02
48A8:	sbc	$15,&H20
48AB:	jr	c,&H48CD
48AD:	jr	&H489F
48AF:	sbc	$15,&H18
48B2:	jr	nz,&H489F
48B4:	or	$15,&H20
48B7:	jr	&H48FA
48B9:	cal	&H00CD		;test for '#'
48BC:	jp	z,&H488D
48BF:	cal	&H4944
48C2:	ld	$2,&HBB		;code of the keyword "ALL"
48C5:	cal	&H00E9		;test for keyword prefix 7 and code $2
48C8:	jr	z,&H48A2
48CA:	cal	&H4930
48CD:	phsw	$15
48CF:	cal	&H4E43		;process the file descriptor
48D2:	ppsw	$14
48D4:	sbc	$15,&H30
48D7:	jr	nc,&H48FC
48D9:	cal	&H00C3
48DC:	jr	nz,&H48FC
48DE:	cal	&H0049
48E1:	cal	&H00B6		;TCAPS, lower to upper case conversion
48E4:	sbc	$0,&H4D
48E7:	jr	z,&H48AF
48E9:	sbc	$0,&H41
48EC:	jr	nz,&H489F
48EE:	sbc	$15,$sx
48F0:	jr	nlz,&H489F
48F2:	sbc	$14,&H10
48F5:	jr	nz,&H489F
48F7:	cal	&H492D
48FA:	ldd	$0,(iz+$sy)
48FC:	cal	&H0093		;SN Error if not an end of a BASIC line
48FF:	cal	&H4920
4902:	gre	iz,$0
4904:	phuw	$1
4906:	anc	$15,&H42
4909:	jr	z,&H4911
490B:	sbc	$11,&H03
490E:	jp	nz,&H2B88	;BF Error, improper filename
4911:	anc	$15,&H08
4914:	rtn	z
4915:	ldw	$4,&H18BB
4919:	pre	ix,&H16C9
491D:	stw	$4,(ix+$sx)
491F:	rtn
4920:	sbc	$11,&H02
4923:	jr	z,&H4929
4925:	sbc	$15,&H30
4928:	rtn	nz
4929:	sbc	$14,&H10
492C:	rtn	nz
492D:	or	$15,$sy,jr &H4940

4930:	pre	ix,&H16C9
4934:	ldw	$2,(ix+$sx)
4936:	ldw	$0,&H18BB
493A:	sbcw	$2,$sz
493C:	ld	$14,&H10
493F:	rtn	c
4940:	ld	$14,&H24
4943:	rtn

4944:	pre	ix,&H16C4
4948:	ldm	$1,(ix+$sx),3
494B:	anc	$3,$sy
494D:	jr	nz,&H4959
494F:	sbc	$1,$sy
4951:	rtn	z
4952:	anc	$2,&H02
4955:	rtn	nz
4956:	jp	&H2BA8		;FC Error, unrecognized command
4959:	sbc	$15,&H20
495C:	rtn	z
495D:	jr	&H4956
495F:	cal	&H2985		;select the file as the output device
4962:	ld	$10,&H30
4965:	ld	$9,$sx
4967:	pre	ix,&H178F
496B:	std	$15,(ix+$sx)
496D:	cal	&H294F
4970:	or	$1,&H20
4973:	std	$1,(ix+$sx)
4975:	jp	&H4637
4978:	anc	$21,&H02
497B:	jr	z,&H49A5
497D:	pre	ix,&H1014
4981:	pre	iz,&H18A7	;table of file addresses
4985:	ld	$8,&H0A
4988:	ldiw	$0,(iz+$sx)
498A:	ldw	$2,(iz+$sx)
498C:	sbw	$2,$sz
498E:	stdw	$3,(ix-$sy)
4990:	sb	$8,$sy
4992:	jr	nz,&H4988
4994:	ldw	$5,&H0014
4998:	ldw	$25,&H1000
499C:	cal	&H49BB
499F:	pre	iz,&H18A7	;table of file addresses
49A3:	ldw	$25,(iz+$sx)
49A5:	pre	ix,&H178D
49A9:	ldw	$5,(ix+$sx)
49AB:	ldw	$22,&H10FF
49AF:	jr	&H49BF
49B1:	ldw	$22,&H24FF
49B5:	jr	&H49BF
49B7:	ldw	$25,&H1793	;data buffer
49BB:	ldw	$22,&H2400
49BF:	cal	&H8581		;save UA and IZ on the user stack, UA <- &HD4
49C2:	cal	&H8983		;enable MT communication
49C5:	ld	$4,&H78		;lead-in length = 5 sec
49C8:	ld	$0,&H44		;character 'D' - the data segment identifier
49CB:	cal	&H88E1		;write the lead-in followed by byte $0
49CE:	ld	$0,$23
49D1:	cal	&H88EA		;write byte to the tape, update the checksum
49D4:	ld	$0,$22
49D7:	cal	&H88EA		;write byte to the tape, update the checksum
49DA:	sbc	$23,&H10
49DD:	jr	z,&H49EB
49DF:	ld	$0,$5
49E2:	cal	&H88EA		;write byte to the tape, update the checksum
49E5:	ld	$0,$6
49E8:	cal	&H88EA		;write byte to the tape, update the checksum
49EB:	pre	ix,$25
49ED:	sbcw	$5,$sy
49EF:	cal	nc,&H88FA	;write $5,$6 bytes pointed to by IX to the tape
49F2:	jp	&H878F

49F5:	pre	ix,&H1739
49F9:	ldd	$0,(ix+$sx)
49FB:	sbc	$0,&H04
49FE:	rtn	nz
49FF:	pre	ix,&H1770
4A03:	ld	$0,(ix+&H04)
4A06:	sbc	$0,&H03
4A09:	rtn	nz
4A0A:	cal	&H4877
4A0D:	cal	&H4882
4A10:	jp	&H49B7

4A13:	cal	&H48B9
4A16:	cal	&H2930
4A19:	ldd	$0,(ix+$sy)
4A1B:	an	$0,&HF8
4A1E:	std	$0,(ix+$sx)
4A20:	phs	$11
4A22:	ld	$10,&H32
4A25:	cal	&H4965
4A28:	pps	$11
4A2A:	pre	ix,&H178C
4A2E:	ldd	$5,(ix+$sx)
4A30:	ldd	$6,(ix+&H03)
4A33:	sbc	$11,$sy
4A35:	jr	nz,&H4A3D
4A37:	sbc	$5,&H10
4A3A:	jp	z,&H4AC1
4A3D:	anc	$6,&H40
4A40:	jp	nz,&H4BDE
4A43:	sbc	$6,&H30
4A46:	jr	uz,&H4A52
4A48:	phsw	$6
4A4A:	cal	&H28BC
4A4D:	cal	&H45D1		;delete the current file
4A50:	ppsw	$5
4A52:	sbc	$5,&H24
4A55:	jp	nz,&H4B00
4A58:	anc	$6,$sy
4A5A:	jr	nz,&H4AC7
4A5C:	cal	&H4E36
4A5F:	jr	nz,&H4AC1
4A61:	pre	ix,&H19D5
4A65:	cal	&H4D28
4A68:	jr	c,&H4A97
4A6A:	gre	ix,$0
4A6C:	pre	ix,&H1774
4A70:	ld	$2,&H02
4A73:	sbc	(ix+$sx),$2
4A75:	jr	z,&H4AB3
4A77:	pre	ix,$0
4A79:	ldw	$0,&H0A0D
4A7D:	stw	$0,(ix+$sx)
4A7F:	ld	$24,$sx
4A81:	adw	$23,$sy
4A83:	adw	$23,$sy
4A85:	cal	&H33EE		;get starting/ending address of current file
4A88:	ldw	$19,$27
4A8B:	sbw	$19,$sy
4A8D:	ldw	$0,$23
4A90:	pre	iz,$19
4A92:	cal	&H5901
4A95:	jr	&H4A5C
4A97:	jr	nz,&H4AA2
4A99:	cal	&H4CA8
4A9C:	jp	nz,&H2B74	;ST Error, string too long
4A9F:	ld	$24,$sy,jr &H4A85
4AA2:	sbc	$23,$sy
4AA4:	jr	c,&H4AC1
4AA6:	ld	$24,$sx
4AA8:	pre	ix,&H1786
4AAC:	ld	$0,&HFF
4AAF:	std	$0,(ix+$sx)
4AB1:	jr	&H4A85
4AB3:	ld	$0,&H0D
4AB6:	cal	&H4CE0
4AB9:	ld	$0,&H0A
4ABC:	cal	&H4CE0
4ABF:	jr	&H4A5C
4AC1:	cal	&H4EB8
4AC4:	jp	&H46B3
4AC7:	cal	&H4E36
4ACA:	jr	nz,&H4AC1
4ACC:	ldw	$0,&H1AD3
4AD0:	stw	&H0000,($sz)
4AD4:	pre	ix,&H19D5
4AD8:	cal	&H4D28
4ADB:	jr	c,&H4AC1
4ADD:	cal	&H9753		;INCLR, clear the INTOP input buffer
4AE0:	sbw	$14,$14
4AE3:	pre	ix,&H1AD3
4AE7:	pre	iz,&H19D5
4AEB:	ld	$0,&H20
4AEE:	sbc	(iz+$sx),$0
4AF0:	jr	c,&H4AC7
4AF2:	cal	&H4AF7
4AF5:	jr	&H4AC7
4AF7:	cal	&H1D2C
4AFA:	cal	&H33EE		;get starting/ending address of current file
4AFD:	jp	&H3444
4B00:	pre	ix,&H176E
4B04:	ldw	$2,(ix+$sx)
4B06:	sbc	$5,&H90
4B09:	jr	nz,&H4B58
4B0B:	phsw	$3
4B0D:	ldw	$25,&H1793	;data buffer
4B11:	cal	&H4B69
4B14:	pre	ix,&H176E
4B18:	ldw	$5,(ix+$sx)
4B1A:	ldw	$0,&H0014
4B1E:	sbcw	$5,$sz
4B20:	jp	nz,&H2B84	;RW Error, I/O device operation error
4B23:	ppsw	$4
4B25:	stw	$4,(ix+$sx)
4B27:	pre	ix,&H18A7	;table of file addresses
4B2B:	ldw	$25,(ix+$sx)
4B2D:	pre	ix,&H18BB
4B31:	ldw	$27,(ix+$sx)
4B33:	cal	&H4BC2
4B36:	pre	iz,&H18BB
4B3A:	ldw	$2,(iz+$sx)
4B3C:	pre	ix,&H1793	;data buffer
4B40:	ld	$6,&H0A
4B43:	ldiw	$0,(ix+$sx)
4B45:	sbw	$2,$sz
4B47:	stdw	$3,(iz-$sy)
4B49:	sb	$6,$sy
4B4B:	jr	nz,&H4B43
4B4D:	ldw	$25,$2
4B50:	cal	&H4B6F
4B53:	cal	&H3402
4B56:	jr	&H4B66
4B58:	ldw	$4,$2
4B5B:	adw	$4,$sy
4B5D:	cal	&H33EE		;get starting/ending address of current file
4B60:	cal	&H4BC2
4B63:	cal	&H4B6F
4B66:	jp	&H4AC1

4B69:	ldw	$8,&H2430
4B6D:	jr	&H4B73
4B6F:	ldw	$8,&H1010
4B73:	cal	&H8938		;check for the data segment identifier 'D'
4B76:	cal	&H8905		;read byte from the tape, update the checksum
4B79:	ld	$7,$sz
4B7B:	sbc	$8,$sz
4B7D:	jr	z,&H4B84
4B7F:	sbc	$9,$sz
4B81:	jp	nz,&H2B84	;RW Error, I/O device operation error
4B84:	cal	&H8905		;read byte from the tape, update the checksum
4B87:	sti	$0,(ix+$sy)
4B89:	ldw	$5,(ix+$sx)
4B8B:	anc	$7,&H20
4B8E:	jr	z,&H4BA8
4B90:	cal	&H8905		;read byte from the tape, update the checksum
4B93:	ld	$5,$sz
4B95:	cal	&H8905		;read byte from the tape, update the checksum
4B98:	ld	$6,$sz
4B9A:	ldw	$0,&H0101
4B9E:	sbcw	$5,$sz
4BA0:	jp	nc,&H2B7C
4BA3:	ld	$0,&H02
4BA6:	stw	$5,(ix+$sz)
4BA8:	pre	ix,&H178F
4BAC:	ldd	$8,(ix+$sx)
4BAE:	sbw	$5,$sy
4BB0:	jp	c,&H8884
4BB3:	cal	&H8905		;read byte from the tape, update the checksum
4BB6:	anc	$8,&H40
4BB9:	jr	nz,&H4BAE
4BBB:	st	$0,($25)
4BBE:	adw	$25,$sy
4BC0:	jr	&H4BAE
4BC2:	ldm	$0,$25,4
4BC5:	sbw	$2,$sz
4BC7:	sbcw	$2,$4
4BCA:	rtn	z
4BCB:	jr	nc,&H4BD8
4BCD:	sbw	$4,$2
4BD0:	ldw	$2,$sz
4BD2:	ldw	$0,$4
4BD5:	jp	&H34B1		;expand a memory block in a RAM file
4BD8:	sbw	$2,$4
4BDB:	jp	&H34EA		;shrink a memory block in a RAM file
4BDE:	sbc	$5,&H24
4BE1:	jr	z,&H4C00
4BE3:	sbc	$5,&H10
4BE6:	jr	z,&H4BFD
4BE8:	sbc	$5,&H90
4BEB:	jp	nz,&H2B84	;RW Error, I/O device operation error
4BEE:	pre	ix,&H176E
4BF2:	ldw	$15,(ix+$sx)
4BF4:	cal	&H4B69
4BF7:	pre	ix,&H176E
4BFB:	stw	$15,(ix+$sx)
4BFD:	jp	&H4B63
4C00:	cal	&H4B69
4C03:	pre	ix,&H176D
4C07:	sbc	(ix+$sx),$31
4C09:	jr	z,&H4C00
4C0B:	jp	&H4AC1
4C0E:	pre	ix,&H1770
4C12:	ld	$0,&H02
4C15:	sbc	(ix+&H04),$0
4C18:	jp	z,&H8590
4C1B:	ld	$0,&H16
4C1E:	ldm	$2,(ix+$sz),5
4C21:	sbc	$2,$sx
4C23:	jp	nz,&H2BBC	;DA error, no data for READ
4C26:	ld	$16,($3)
4C29:	adw	$3,$sy
4C2B:	sbw	$5,$sy
4C2D:	stm	$2,(ix+$sz),5
4C30:	phs	$16
4C32:	jr	nz,&H4C45
4C34:	ld	$0,$sy
4C36:	sbc	(ix+&H04),$0
4C39:	jr	nz,&H4C48
4C3B:	ld	$0,&H12
4C3E:	sbcw	(ix+$sz),$3
4C40:	jr	nz,&H4C4F
4C42:	cal	&H4C54
4C45:	pps	$0
4C47:	rtn

4C48:	ld	$0,&H14
4C4B:	sbc	(ix+$sz),$31
4C4D:	jr	&H4C40
4C4F:	sb	(ix+&H16),$30
4C52:	jr	&H4C45

4C54:	pre	ix,&H1770
4C58:	ld	$0,&H02
4C5B:	sbc	(ix+&H04),$0
4C5E:	rtn	z
4C5F:	jr	c,&H4C8E
4C61:	sb	(ix+&H16),$30
4C64:	cal	&H4877
4C67:	ldw	$25,$1
4C6A:	cal	&H4B69
4C6D:	pre	ix,&H176D
4C71:	ldm	$2,(ix+$sx),3
4C74:	pre	ix,&H1770
4C78:	st	$2,(ix+&H14)
4C7B:	ld	$0,&H19
4C7E:	stw	$3,(ix+$sz)
4C80:	adc	$2,$sy
4C82:	jr	nc,&H4C88
4C84:	sbcw	$3,$sy
4C86:	jr	c,&H4C8A
4C88:	ld	$2,$sx
4C8A:	st	$2,(ix+&H16)
4C8D:	rtn

4C8E:	cal	&H82A5		;read to address &H1793 from a disk file
4C91:	pre	ix,&H1770
4C95:	st	$31,(ix+&H16)
4C98:	sbcw	$26,$sy
4C9A:	jr	c,&H4CA4
4C9C:	ld	$0,&H19
4C9F:	stw	$26,(ix+$sz)
4CA1:	jp	&H4877
4CA4:	sb	(ix+&H16),$30
4CA7:	rtn
4CA8:	gre	ix,$5
4CAA:	pre	ix,&H1770
4CAE:	ldm	$1,(ix+$sy),4
4CB1:	pre	ix,$5
4CB3:	sbc	$2,$sx
4CB5:	rtn
4CB6:	gre	ix,$5
4CB8:	pre	ix,&H178F
4CBC:	ldd	$1,(ix+$sx)
4CBE:	pre	ix,$5
4CC0:	anc	$1,$sy
4CC2:	rtn
4CC3:	sbc	$21,$sx
4CC5:	rtn	z
4CC6:	cal	&H4CA8
4CC9:	rtn	nz
4CCA:	sbc	$4,&H02
4CCD:	rtn	z
4CCE:	cal	&H4CB6
4CD1:	rtn	nz
4CD2:	gre	ix,$5
4CD4:	pre	ix,&H1786
4CD8:	adc	(ix+$sx),$30
4CDA:	pre	ix,$5
4CDC:	rtn
4CDD:	sbc	$30,$sx		;Not Zero flag
4CDF:	rtn
4CE0:	gre	ix,$1
4CE2:	phsm	$23,3
4CE5:	phsm	$2,3
4CE8:	cal	&H33EE		;get starting/ending address of current file
4CEB:	ldw	$19,$27
4CEE:	sbw	$19,$sy
4CF0:	ldw	$0,$sy
4CF2:	ldw	$2,$19
4CF5:	cal	&H34B1		;expand a memory block in a RAM file
4CF8:	ppsm	$0,3
4CFB:	st	$0,($19)
4CFE:	ppsm	$21,3
4D01:	pre	ix,$1
4D03:	rtn
4D04:	cal	&H4CB6
4D07:	jr	nz,&H4D32
4D09:	jr	&H4D25
4D0B:	sbc	$21,$sx
4D0D:	jr	z,&H4D32
4D0F:	cal	&H4CA8
4D12:	jr	nz,&H4D32
4D14:	sbc	$4,&H02
4D17:	jr	nz,&H4D04
4D19:	ldw	$0,&H173D
4D1D:	ld	$2,($sz)
4D1F:	anc	$2,$sy
4D21:	jr	z,&H4D32
4D23:	ld	$23,$sx
4D25:	sbc	$31,$sy
4D27:	rtn
4D28:	na	$21,$sx,jr &H4D2D
4D2B:	ld	$21,$sx
4D2D:	gre	iz,$28
4D2F:	sbw	$22,$22
4D32:	cal	&H4CC3
4D35:	jr	c,&H4D25
4D37:	cal	&H4DDC
4D3A:	sbc	$0,&H1A
4D3D:	jr	z,&H4D0B
4D3F:	sbc	$0,&H0D
4D42:	jp	z,&H4DCA
4D45:	sbc	$21,$sx
4D47:	jr	nz,&H4D58
4D49:	sbc	$0,&H22
4D4C:	jr	z,&H4DA3
4D4E:	sbc	$0,&H2C
4D51:	jr	z,&H4D9D
4D53:	sbc	$0,&H20
4D56:	jr	z,&H4D8D
4D58:	sbc	$0,&H7F
4D5B:	jr	z,&H4D32
4D5D:	sbc	$0,&H20
4D60:	jr	c,&H4D32
4D62:	cal	&H4CA8
4D65:	jr	nz,&H4D76
4D67:	sbc	$4,&H02
4D6A:	jr	nz,&H4D76
4D6C:	cal	&H4CB6
4D6F:	jr	nz,&H4D76
4D71:	cal	&H4CE0
4D74:	jr	&H4D32
4D76:	sti	$0,(ix+$sx)
4D78:	ad	$23,$sy
4D7A:	jr	nz,&H4D32
4D7C:	cal	&H4CA8
4D7F:	jp	nz,&H2B74	;ST Error, string too long
4D82:	cal	&H4CB6
4D85:	jp	nz,&H2B74	;ST Error, string too long
4D88:	sb	$23,$sy
4D8A:	ad	$23,$sy
4D8C:	rtn
4D8D:	sbc	$23,$sx
4D8F:	jr	z,&H4D32
4D91:	pre	iz,&H167F
4D95:	ld	$1,(iz+$sx)
4D97:	sbc	$1,$sx
4D99:	jr	lz,&H4D62
4D9B:	jr	&H4DAB
4D9D:	sbc	$22,$sx
4D9F:	jr	nz,&H4D62
4DA1:	jr	&H4DD7
4DA3:	sbc	$23,$sx
4DA5:	jr	z,&H4DBA
4DA7:	sbc	$22,$sx
4DA9:	jr	z,&H4D62
4DAB:	cal	&H4DE5
4DAE:	jr	nz,&H4DD7
4DB0:	sbc	$0,&H20
4DB3:	jr	nz,&H4DBD
4DB5:	cal	&H4DDC
4DB8:	jr	&H4DAB
4DBA:	sb	$22,$sy,jr &H4D62
4DBD:	sbc	$0,&H2C
4DC0:	jr	z,&H4DD4
4DC2:	sbc	$0,&H0D
4DC5:	jr	nz,&H4DD7
4DC7:	cal	&H4DDC
4DCA:	cal	&H4DED
4DCD:	jr	nz,&H4DD7
4DCF:	sbc	$0,&H0A
4DD2:	jr	nz,&H4DD7
4DD4:	cal	&H4DDC
4DD7:	std	$31,(ix+$sx)
4DD9:	sbc	$31,$sx		;Zero flag
4DDB:	rtn
4DDC:	gre	ix,$1
4DDE:	phsw	$2
4DE0:	cal	&H4C0E
4DE3:	jr	&H4E05
4DE5:	gre	ix,$1
4DE7:	phsw	$2
4DE9:	ld	$1,$sy
4DEB:	jr	&H4DF3
4DED:	gre	ix,$1
4DEF:	phsw	$2
4DF1:	ld	$1,$sx
4DF3:	pre	ix,&H1770
4DF7:	ld	$0,&H02
4DFA:	sbc	(ix+&H04),$0
4DFD:	jr	z,&H4E0A
4DFF:	cal	&H4E3A
4E02:	ld	$0,($5)
4E05:	ppsw	$1
4E07:	pre	ix,$1
4E09:	rtn
4E0A:	phs	$1
4E0C:	cal	&H506E
4E0F:	pre	ix,&H1559
4E13:	adc	(ix-&H02),$31
4E16:	jp	nz,&H4E2F
4E19:	adc	(ix+$sx),$31
4E1B:	pps	$1
4E1D:	jr	z,&H4E29
4E1F:	ldiw	$0,(ix+$sx)
4E21:	sb	$1,$sz
4E23:	ld	$0,(ix+$1)
4E26:	sbc	$0,$sz,jr &H4E05
4E29:	sbc	$1,$sy
4E2B:	jr	z,&H4E0A
4E2D:	jr	&H4E05
4E2F:	pre	ix,&H1558
4E33:	jp	&H85E7
4E36:	pre	ix,&H1770
4E3A:	ld	$0,&H14
4E3D:	ldm	$2,(ix+$sz),5
4E40:	sbc	$4,$sx
4E42:	rtn

; process the file descriptor
4E43:	cal	&H003C		;ENDSC, test for an end of a BASIC line
4E46:	jp	c,&H2B88	;BF Error, improper filename
4E49:	cal	&H4F99		;provide a string from the input text
4E4C:	phs	$17		;string length
4E4E:	cal	&H4FD9		;parse the command string for the device name
4E51:	pps	$17
4E53:	sb	$17,$20		;subtract the device name length
4E56:	sbc	$11,&H02	;I/O device type
4E59:	jr	z,&H4EBD	;branch if RS232C
4E5B:	jr	c,&H4EA7	;branch if ramdisk or FDD
; MT
4E5D:	pre	ix,&H173D
4E61:	ld	$16,(ix+$sx)
4E63:	ldw	$12,$sy
4E65:	anc	$22,$sy
4E67:	jr	z,&H4EA3
4E69:	an	$22,&HFE
4E6C:	an	$16,&HFD
4E6F:	or	$22,$16
4E72:	pre	ix,&H1790
4E76:	std	$22,(ix+$sx)
4E78:	ld	$0,&H60		;Fast mode, 011 = 1200 bps
4E7B:	anc	$22,&H04
4E7E:	jr	z,&H4E83
4E80:	ld	$0,&HA0		;Slow mode, 101 = 300 bps
4E83:	or	$12,$sz
4E85:	cal	&H4FBE		;create an empty file name in the WORK1 buffer
4E88:	ld	$1,&H08
4E8B:	pre	ix,&H165E
4E8F:	sb	$17,$sy
4E91:	jr	c,&H4EB8
4E93:	ldi	$0,(iz+$sx)
4E95:	sbc	$0,&H3A		;'*'
4E98:	jp	z,&H2B88	;BF Error, improper filename
4E9B:	sti	$0,(ix+$sx)
4E9D:	sb	$1,$sy
4E9F:	jr	nz,&H4E8F
4EA1:	jr	&H4EB8
4EA3:	an	$16,&HF9,jr &H4E6F
; ramdisk or FDD
4EA7:	ld	$10,$sy		;flag: disallow wildcards in the filename
4EA9:	gre	iz,$15
4EAB:	phs	$11
4EAD:	ldw	$0,&H165E	;destination pointer = WORK1
4EB1:	pre	ix,$15		;source pointer
4EB3:	cal	&H7E13		;expand the filename
4EB6:	pps	$11
4EB8:	ppuw	$0
4EBA:	pre	iz,$0
4EBC:	rtn
; parse the RS232C file descriptor (for example 2,E,7,1,N,N,N,B,N)
4EBD:	pre	ix,&H173E
4EC1:	ldw	$12,(ix+$sx)
4EC3:	cal	&H4F8E		;test for a comma or an end of the BASIC line
4EC6:	jr	c,&H4F42	;branch if an end of the BASIC line
4EC8:	jr	z,&H4EE3	;branch if a comma found
4ECA:	cal	&H002B		;OKNM1, is $0 a digit?
4ECD:	jr	nc,&H4EFF	;syntax error if not
4ECF:	sbc	$0,&H37		;'7'
4ED2:	jr	nc,&H4EFF	;syntax error if invalid baud rate selected
4ED4:	adc	$0,&HCF		;test for '0'
4ED7:	jr	nc,&H4EFF	;syntax error if invalid baud rate selected
4ED9:	inv	$0
4EDB:	diu	$0
4EDD:	cal	&H4F83		;$12 <- baud rate bits 7..5
4EE0:	cal	&H4F76		;comma or an end of the BASIC line expected
4EE3:	cal	&H4F8E		;test for a comma or an end of the BASIC line
4EE6:	jr	c,&H4F42	;branch if an end of the BASIC line
4EE8:	jr	z,&H4F05	;branch if a comma found
4EEA:	an	$12,&HF9
4EED:	sbc	$0,&H45		;'E' (parity even)
4EF0:	jr	z,&H4F02
4EF2:	or	$12,&H02
4EF5:	sb	$0,&H4F		;'O' (parity odd)
4EF8:	jr	z,&H4F02
4EFA:	or	$12,&H04
4EFD:	adc	$0,$sy
4EFF:	jp	nc,&H2B70	;SN Error, syntax
4F02:	cal	&H4F76		;comma or an end of the BASIC line expected
4F05:	ld	$2,&HF7		;$2=bit 4
4F08:	ldw	$3,&H3837	;$3='7', $4='8' (number of data bits)
4F0C:	cal	&H4F4E
4F0F:	ld	$2,&HEF		;$2=bit 5
4F12:	ldw	$3,&H3231	;$3='2', $4='1' (number of stop bits)
4F16:	cal	&H4F4E
4F19:	ld	$4,&H4E		;$4='N'
4F1C:	ldw	$2,&H43FB	;$3='C', $2=bit 2
4F20:	cal	&H4F4E
4F23:	ldw	$2,&H44F7	;$3='D', $2=bit 3
4F27:	cal	&H4F4E
4F2A:	ldw	$2,&H43EF	;$3='C', $2=bit 4
4F2E:	cal	&H4F4E
4F31:	ldw	$2,&H42FD	;$3='B', $2=bit 1
4F35:	cal	&H4F4E
4F38:	ldw	$2,&H53FE	;$3='S', $2=bit 0
4F3C:	cal	&H4F4E
4F3F:	cal	&H0093		;SN Error if not an end of a BASIC line
4F42:	phsm	$13,3
4F45:	cal	&H4FBE		;create an empty file name in the WORK1 buffer
4F48:	ppsm	$11,3
4F4B:	jp	&H4EB8

; $12 = value of RS1, $13 = value of RS3
; $2 = bit mask of the parameter in RS1 or RS3
; $3 = letter that sets the parameter
; $4 = letter that clears the parameter
4F4E:	cal	&H4F8E		;test for a comma or an end of the BASIC line
4F51:	jr	c,&H4F7F	;branch if an end of the BASIC line
4F53:	rtn	z		;return if a comma found
; check the letter that clears the parameter
4F54:	sbc	$4,&H4E		;'N'
4F57:	jr	z,&H4F5D
4F59:	an	$12,$2,jr &H4F60
4F5D:	an	$13,$2
4F60:	sbc	$4,$sz
4F62:	jr	z,&H4F76	;branch if the letter matches
; check the letter that sets the parameter
4F64:	inv	$2
4F66:	sbc	$4,&H4E		;'N'
4F69:	jr	z,&H4F6F
4F6B:	or	$12,$2,jr &H4F72
4F6F:	or	$13,$2
4F72:	sbc	$3,$sz
4F74:	jr	nz,&H4F7C	;branch if invalid letter
; comma or an end of the BASIC line expected, otherwise SN Error
4F76:	ldd	$0,(iz+$sy)
4F78:	cal	&H00C3		;test for a comma
4F7B:	rtn	z
4F7C:	jp	&H0093		;SN Error if not an end of a BASIC line
; premature end of the BASIC line
4F7F:	ppsw	$0		;drop the return address
4F81:	jr	&H4F42

4F83:	biu	$0
4F85:	an	$0,&HE0		;baud rate bits 7..5
4F88:	an	$12,&H1F
4F8B:	or	$12,$sz
4F8D:	rtn

; returns Zero if a comma found, or Carry set if an end of the BASIC line
4F8E:	cal	&H00C3		;test for a comma
4F91:	rtn	z
4F92:	cal	&H00B6		;TCAPS, lower to upper case conversion
4F95:	sbc	$0,&H03
4F98:	rtn

; provide a string from the input text pointed to by IZ
4F99:	cal	&H11D2		;evaluate a string expression
4F9C:	cal	&H125D		;append zero
4F9F:	cal	&H28B3		;clear the string operation stack
4FA2:	gre	iz,$0
4FA4:	phuw	$1		;save the pointer to the text on the user stack
4FA6:	pre	iz,$15		;pointer to the string
4FA8:	rtn

; copy the file name from the WORK1 buffer to the file control block
4FA9:	pre	ix,&H1775	;destination address
4FAD:	ldw	$0,&H165E	;source address = WORK1
4FB1:	ld	$3,&H0C		;counter of copied bytes
4FB4:	sb	$3,$sy
4FB6:	rtn	z
4FB7:	ld	$2,($sz)
4FB9:	sti	$2,(ix+$sx)
4FBB:	adw	$0,$sy,jr &H4FB4

; create an empty file name (11 spaces) in the WORK1 buffer
4FBE:	ldw	$2,&H1493	;source address = string of 11 spaces
4FC2:	ldw	$0,&H165E	;destination address = WORK1
4FC6:	ldw	$4,&H000B	;number of transferred bytes
4FCA:	jp	&H0EBB		;block transfer from bank 2 to bank 1

; parse the command string for the file handle
4FCD:	cal	&H00CD		;test for '#'
4FD0:	cal	&H0EC3		;evaluate num. expression to integer (byte)
4FD3:	sbc	$15,$sy		;only "#1" allowed
4FD5:	rtn	z
4FD6:	jp	&H2B8C		;BN Error, improper file handle

; parse the command string for the I/O device name
4FD9:	gst	ua,$4
4FDB:	pst	ua,&H64
4FDE:	ldw	$5,&H1562	;table 'CAS0:(', 'CAS1:(', 'cas0:(', 'cas1:('
4FE2:	ldw	$22,&H0004	;$22 = number of notation variations
; notation variation loop
4FE6:	ld	$7,&H06		;string length
4FE9:	ld	$17,$7
4FEC:	gre	iz,$15		;pointer to the command string
4FEE:	cal	&H0A82		;MCP, string comparison
4FF1:	jr	z,&H4FFF
4FF3:	ldw	$0,&H0006	;string length
4FF7:	adw	$5,$sz		;advance the pointer by the string length
4FF9:	sb	$22,$sy		;counter of notation variations
4FFB:	jr	nz,&H4FE6	;next notation variation
4FFD:	jr	&H5001		;skip if no match
4FFF:	ld	$23,$sy		;mark that a matching string was found
5001:	pre	ix,&H149E	;table of I/O device names
; I/O device loop
5005:	ldim	$19,(ix+$sx),4	;$19 = number of notation variations
				;$20 = string length
				;$21 = I/O device type, $22 = I/O device option
5008:	ld	$11,$21		;I/O device type
500B:	sbc	$19,$sx		;end of the table?
500D:	jr	z,&H502C	;exit the loop if so
; notation variation loop
500F:	ld	$7,$20		;string length
5012:	ld	$17,$20
5015:	gre	ix,$5		;pointer to the table of I/O device names
5017:	gre	iz,$15		;pointer to the command string
5019:	cal	&H0A82		;MCP, string comparison
501C:	jr	z,&H5029
501E:	pre	ix,$5
5020:	ldd	$0,(ix+$20)	;advance the pointer by the string length
5023:	sb	$19,$sy		;counter of notation variations
5025:	jr	z,&H5005	;next I/O device
5027:	jr	&H500F		;next notation variation
; matching string was found
5029:	ldd	$0,(iz+$20)	;advance the command string pointer
502C:	pst	ua,$4
502E:	anc	$23,$sy
5030:	rtn	z
5031:	anc	$22,$sy
5033:	jp	nz,&H2B70	;SN Error, syntax
5036:	rtn

; FC Error if not BASIC mode
5037:	cal	&H2972		;returns Not Zero if BASIC mode
503A:	rtn	nz
503B:	jr	&H5041		;FC Error, unrecognized command

; FC Error if BASIC interpreter in the RUN mode
503D:	cal	&H504A		;test the BASIC interpreter mode
5040:	rtn	z		;return if not RUN mode
5041:	jp	&H2BA8		;FC Error, unrecognized command

; FC Error if BASIC interpreter not in the RUN mode
5044:	cal	&H504A		;test the BASIC interpreter mode
5047:	rtn	nz		;return if RUN mode
5048:	jr	&H5041		;FC Error, unrecognized command

; returns Not Zero if BASIC interpreter in the RUN mode
504A:	pre	ix,&H16C6	;BASIC interpreter mode
504E:	ldd	$1,(ix+$sx)
5050:	anc	$1,$sy
5052:	rtn

5053:	cal	&H5037		;FC Error if not BASIC mode
5056:	cal	&H503D		;FC Error if BASIC interpreter in the RUN mode
5059:	jp	&H529B		;PR Error if password set

505C:	cal	&H506E
505F:	rtn	nz
5060:	cal	&H032E		;cursor display disable
5063:	cal	&H23C8
5066:	sbc	$0,&HE9
5069:	jr	z,&H5063
506B:	jp	&H031B		;cursor display enable

; KYCHK:
506E:	cal	&H29C5		;test the power switch and BRK key
5071:	ld	$0,&H46
5074:	cal	&H0381		;select KO column $0, read KI to $1,$2
5077:	sbc	$2,$sx
5079:	rtn	nz
507A:	sbc	$1,&H04
507D:	rtn	nz
507E:	pre	ix,&H1115
5082:	stm	$0,(ix+$sy),3
5085:	cal	&H0458
5088:	sbc	$31,$sx		;Zero flag
508A:	rtn

; ENLST:
; Conversion of a BASIC line pointed to by IZ from the internal format to an
; ASCII string in the INTOP buffer.
508B:	ld	$13,$sx		;character counter
508D:	pre	ix,&H1000	;destination buffer
5091:	ldd	$0,(iz+$sy)	;specified line length
5093:	cal	&H50B2		;convert the line number to a string
5096:	ld	$5,&H20
5099:	sbc	(iz+$sx),$5
509B:	jr	nz,&H50AD
509D:	ldi	$5,(iz+$sx)
509F:	sbc	$5,$sx
50A1:	rtn	z
50A2:	sbc	$5,&H20
50A5:	jr	nc,&H50AD
50A7:	cal	&H50DB		;convert a single item in the BASIC line
50AA:	jr	nc,&H509D
50AC:	rtn
50AD:	sti	$5,(ix+$sx)
50AF:	ad	$13,$sy,jr &H50AA

; this procedure converts the line number pointed to by IZ into a string,
; updates the character counter,
; returns Carry set if out of the destination buffer
50B2:	ldiw	$3,(iz+$sx)
50B4:	sbbm	$14,$14,3	;clear the destination registers
50B7:	cal	&H0AB4		;binary to BCD conversion
50BA:	ldw	$11,&H0005	;$11=counter, $12=flag of suppressed leading 0s
; this loop expands the BCD number and converts it to ASCII
50BE:	an	$16,&H0F	;separate the top digit
50C1:	jr	nz,&H50CF	;branch if the digit <> 0
50C3:	sbc	$12,$sx		;should this 0 be supressed?
50C5:	jr	nz,&H50D1	;branch if not
50C7:	dium	$14,3		;shift the next digit to $16
50CA:	sb	$11,$sy		;decrement the digit counter
50CC:	jr	nz,&H50BE	;next digit
50CE:	rtn
; process with a non-suppressed digit
50CF:	ld	$12,$sy		;flag - don't suppress any digits any more
50D1:	ad	$16,&H30	;convert the digit to ASCII
50D4:	sti	$16,(ix+$sx)	;store it to the buffer
50D6:	ad	$13,$sy		;increment the character counter
50D8:	jr	nc,&H50C7	;next digit if not buffer overflow
50DA:	rtn

; convert a single item in the BASIC line from the binary format to a string
; $5 = input byte, IZ = input pointer, IX = output pointer
; returns Carry set if output buffer overflow
50DB:	sbc	$5,&H02
50DE:	jr	nc,&H50F8
; code &H01 = colon separating multiple statements
50E0:	ldw	$5,(iz+$sx)
50E2:	sbc	$5,&H07		;prefix of the keyword ELSE?
50E5:	jr	nz,&H50EC
50E7:	sbc	$6,&H48		;code of the keyword ELSE?
50EA:	jr	z,&H50F4	;ignore the colon before the ELSE statement
50EC:	ld	$5,&H3A		;colon
50EF:	sti	$5,(ix+$sx)	;store the character to the output buffer
50F1:	ad	$13,$sy		;increment the counter of characters
50F3:	rtn
50F4:	ldiw	$5,(iz+$sx)
50F6:	jr	&H5105
50F8:	jr	nz,&H50FE
50FA:	ld	$5,&H27,jr &H50EF	;code &H02 = apostrophe used as remark
50FE:	sbc	$5,&H03		;prefix of a binary encoded line number
5101:	jr	z,&H50B2	;convert the line number to a string
5103:	ldi	$6,(iz+$sx)
5105:	sbc	$5,&H05		;prefix
5108:	jr	nz,&H5122
510A:	sbc	$6,&H71		;code
510D:	jr	c,&H5122
510F:	sbc	$6,&H77
5112:	jr	nc,&H5122
; keyword prefix = &H05 and codes = &H71 to &H77 (hyperbolic functions)
5114:	sb	$6,&H06		;convert them to trigonometric
5117:	phsw	$6
5119:	ld	$6,&H9B		;code of the keyword "HYP"
511C:	cal	&H5122		;convert the keyword code to a string
511F:	ppsw	$5
5121:	rtn	c
; convert the keyword of the prefix $5 and code $6 to a string at the memory
; location pointed to by IX
5122:	gst	ua,$3
5124:	gre	iz,$14
5126:	pst	ua,&H94
5129:	sbc	$5,&H08
512C:	jr	nc,&H516D	;branch if prefix >= 8
512E:	sbc	$6,&HC8
5131:	jr	nc,&H516D	;branch if code >= &HC8
5133:	sb	$5,&H04
5136:	jr	c,&H516D	;branch if prefix < 4
5138:	biu	$5
513A:	pre	iz,&H0FA1	;table of 4 addresses of tables with keyword
				;names
513E:	ldw	$7,(iz+$5)	;table of addresses of keyword names
5141:	ld	$0,$6
5144:	sb	$0,&H47
5147:	jr	c,&H516D	;branch if keyword code < &H47
5149:	ld	$1,$sx
514B:	biuw	$0
514D:	adw	$7,$sz
514F:	pre	iz,$7
5151:	ldw	$7,(iz+$sx)
5153:	pre	iz,$7		;pointer to the keyword name
; copy the keyword name with the bit 7 of the last character set, pointed to
; by IZ, to the memory location pointed to by IX
5155:	ldi	$5,(iz+$sx)
5157:	an	$5,&H7F
515A:	sti	$5,(ix+$sx)
515C:	ad	$13,$sy		;increment the counter of characters
515E:	jr	c,&H5168	;branch if output buffer overflow
5160:	ld	$5,(iz-$sy)
5162:	biu	$5		;test the bit 7
5164:	jr	nc,&H5155	;process the next character if bit 7 cleared
5166:	sbc	$30,$sx
5168:	pre	iz,$14
516A:	pst	ua,$3
516C:	rtn
; three question marks for unrecognized keywords
516D:	pre	iz,&H0EAE	;string "???", last character has bit 7 set
5171:	jr	&H5155

5173:	ldw	$15,$4
; LNSCH
; search for a BASIC line with a number specified in $15,$16
; returns the address of the line in $19,$20 and Carry set if exact match
5176:	cal	&H33EE		;get starting/ending address of current file
5179:	jp	&H0B8C		;search for a BASIC line $15,$16

517C:	pre	ix,&H1739
5180:	ldd	$0,(ix+$sx)
5182:	anc	$0,&H06
5185:	jp	z,&H2AE8	;OUTCR, display CR-LF
5188:	cal	&H2B44
518B:	ld	$17,$sx
518D:	ad	$17,&H0E
5190:	jr	c,&H519C
5192:	sbc	$0,$17
5195:	jr	nc,&H518D
5197:	sb	$17,$sz
5199:	jp	&H3FAE
519C:	ld	$17,$sx,jr &H5197
519F:	ld	$1,&HF0
51A2:	ad	$1,&H10
51A5:	sb	$0,&H0A
51A8:	jr	nc,&H51A2
51AA:	ad	$0,&H0A
51AD:	ad	$0,$1
51B0:	rtn
51B1:	cal	&H06B8
51B4:	stdm	$8,(ix+$sx),8
51B7:	std	$0,(ix-$sy)
51B9:	rtn

; command SYSTEM, prefix 4, code &H52
51BA:	ld	$1,&H2A		;'*'
51BD:	cal	&H00D1		;test for a specified character
51C0:	jp	z,&H8A2E	;self-test
51C3:	cal	&H0093		;SN Error if not an end of a BASIC line
51C6:	cal	&H2ADB
51C9:	pre	ix,&H173B
51CD:	ldd	$1,(ix+$sx)
51CF:	pre	ix,&H16E9
51D3:	ldd	$0,(ix+$sx)
51D5:	pre	ix,&H2510
51D9:	cal	&H6512
51DC:	cal	&H5231
51DF:	cal	&H7CC6
51E2:	cal	&H7B86		;display a comma
51E5:	cal	&H5229
51E8:	cal	&H7CC6
51EB:	ldw	$17,&H2528
51EF:	cal	&H6520		;display a string from bank 2
51F2:	cal	&H5223
51F5:	cal	&H7CC6
51F8:	cal	&H6520		;display a string from bank 2
51FB:	cal	&H523F
51FE:	cal	&H7CC6
5201:	cal	&H6520		;display a string from bank 2
5204:	cal	&H5245
5207:	cal	&H7CC6
520A:	jp	&H2AE8		;OUTCR, display CR-LF

520D:	sbc	$15,&H05
5210:	jr	z,&H5245
5212:	jp	nc,&H2BA4	;BS Error, subscript out of range
5215:	sbc	$15,&H03
5218:	jr	z,&H5231
521A:	jr	nc,&H523F
521C:	sb	$15,$sy
521E:	jp	c,&H2BA4	;BS Error, subscript out of range
5221:	jr	nz,&H5229
5223:	pre	ix,&H18CF
5227:	jr	&H5249
5229:	pre	ix,&H1897
522D:	ldw	$13,(ix+$sx)
522F:	jr	&H5237
5231:	pre	ix,&H18A3
5235:	ldw	$13,(ix+$sx)
5237:	pre	ix,&H18A7	;table of file addresses
523B:	ldw	$15,(ix+$sx)
523D:	jr	&H524C
523F:	pre	ix,&H1899
5243:	jr	&H5249
5245:	pre	ix,&H18A5
5249:	ldm	$13,(ix+$sx),4
524C:	sbw	$15,$13
524F:	ldw	$3,$15
5252:	rtn

; function FRE, prefix 5, code &H8D
5253:	cal	&H0EC6
5256:	cal	&H520D
5259:	jp	&H187E

; command PASS, prefix 4, code &H53
525C:	cal	&H11D2		;evaluate a string expression
525F:	pre	ix,$15		;pointer to the specified string
5261:	sbbm	$8,$8,8		;clear the password buffer
5264:	ld	$0,&H08,jr &H526B	;maximal number of characters
; this loop copies the characters to $8..$15
5268:	bydm	$15,8
526B:	sbc	$17,$sx		;length of the specified string
526D:	jr	z,&H5273
526F:	sb	$17,$sy
5271:	ldi	$15,(ix+$sx)
5273:	sb	$0,$sy
5275:	jr	nz,&H5268
5277:	sbc	$8,$sx		;was an empty string specified?
5279:	jp	z,&H2B70	;SN Error, syntax
527C:	invm	$8,8		;encrypt the password
527F:	cal	&H5294		;IX <- password buffer
5282:	jr	z,&H5290	;branch if empty
5284:	ldm	$0,(ix+$sx),8	;current password
5287:	xrm	$8,$sz,8	;does it match the specified one?
528A:	jp	nz,&H2BB8	;PR Error if not
; new password
528D:	invm	$8,8		;encrypt the password
5290:	stm	$8,(ix+$sx),8	;store the new password
5293:	rtn

5294:	pre	ix,&H1683	;password buffer
5298:	adc	(ix+$sx),$30	;is the password set?
529A:	rtn

529B:	cal	&H5294		;IX <- password buffer
529E:	jp	nz,&H2BB8	;PR Error if password set
52A1:	rtn

; command MODE, prefix 4, code &HB0
52A2:	cal	&H0EC3		;evaluate num. expression to integer (byte)
52A5:	sbc	$15,&H04
52A8:	jr	c,&H52F3	;BS Error if MODE3 or less
52AA:	sbc	$15,&H09
52AD:	jr	nc,&H52D2
; MODE4 to MODE8
52AF:	cal	&H0093		;SN Error if not an end of a BASIC line
52B2:	ld	$0,$15
52B5:	sbc	$0,&H02		;nonsense? values below 4 are already excluded
52B8:	jr	c,&H52CD	;never going to happen
52BA:	sbc	$0,&H07
52BD:	jr	c,&H52C6
; MODE7 or MODE8
52BF:	pre	ix,&H173B	;printer on/off mode
52C3:	an	$0,$sy,jr &H52CD
; MODE4 to MODE6
52C6:	pre	ix,&H1132	;ANGFL, angle mode
52CA:	sb	$0,&H04		;0: DEG, 1: RAD, 2: GRA
52CD:	std	$0,(ix+$sx)
52CF:	jp	&H928A
; MODE9 or higher
52D2:	sb	$15,&H0A
52D5:	jr	c,&H52F3	;BS Error if MODE9
52D7:	sbc	$15,&H02
52DA:	jr	nc,&H52E3
; MODE10 and MODE11
52DC:	pre	ix,&H1133	;"integer cheating" flag
52E0:	an	$15,$sy,jr &H52AF
52E3:	sbc	$15,&H64
52E6:	jr	z,&H52F6	;branch if MODE110
52E8:	sb	$15,&HBE
52EB:	jp	z,&H823A	;branch if MODE200
52EE:	sb	$15,$sy
52F0:	jp	z,&H823E	;branch if MODE201
52F3:	jp	&H2BA4		;BS Error, subscript out of range
; MODE110
52F6:	cal	&H00E1		;'(' expected
52F9:	cal	&H0EDF		;evaluate num. expression to integer (word)
52FC:	cal	&H00C7		;')' expected
52FF:	gst	ie,$0
5301:	gre	iz,$1
5303:	phsm	$2,3
5306:	pst	ie,$31
5308:	ldw	$0,&H5312	;return address
530C:	phsw	$1
530E:	pst	ua,&H55
5311:	jp	$15

; return from a machine code routine called by MODE110
5313:	ppsm	$0,3
5316:	pre	iz,$1
5318:	pst	ie,$0
531A:	pre	us,&H1CD0
531E:	rtn

; execute a ROM routine pointed to by IY from the RAM
531F:	gre	iy,$28
5321:	cal	&H5328
5324:	pst	ua,&H55		;return to the RAM
5327:	rtn
5328:	jp	$28

; command SET, prefix 4, code &HAC
532A:	cal	&H0049
532D:	cal	&H00B6
5330:	ldw	$15,$sx
5332:	cal	&H004D
5335:	sbc	$16,&H4E
5338:	jr	z,&H5359
533A:	sb	$16,&H45
533D:	ld	$1,&H20
5340:	jr	z,&H534A
5342:	ld	$1,&H10
5345:	sb	$16,$sy
5347:	jp	nz,&H2B70	;SN Error, syntax
534A:	phs	$1
534C:	cal	&H0EC3		;evaluate num. expression to integer (byte)
534F:	pps	$0
5351:	sbc	$15,&H0A
5354:	jp	nc,&H2BA4	;BS Error, subscript out of range
5357:	or	$15,$sz
5359:	cal	&H0093		;SN Error if not an end of a BASIC line
535C:	pre	ix,&H16C3
5360:	std	$15,(ix+$sx)
5362:	rtn
5363:	pre	ix,&H1897
5367:	ldw	$0,(ix+$sx)
5369:	pre	ix,&H18A7	;table of file addresses
536D:	ldw	$8,(ix+$sx)
536F:	ldw	$2,(ix+$sx)
5371:	pre	ix,&H18CF
5375:	ldm	$4,(ix+$sx),4
5378:	sbw	$6,$4
537B:	sbw	$4,$2
537E:	sbw	$8,$sz
5380:	sbw	$15,$8
5383:	rtn	z
5384:	jr	c,&H538C
5386:	sbw	$6,$15
5389:	jp	c,&H2B6D	;OM Error, insufficient memory
538C:	ldw	$0,$2
538F:	adw	$0,$15
5392:	phsw	$16
5394:	cal	&H00F9
5397:	ppsw	$1
5399:	ld	$0,&H28
539C:	pre	ix,&H18A7	;table of file addresses
53A0:	adw	(ix+$sz),$1
53A2:	sb	$0,$sy
53A4:	rtn	c
53A5:	sb	$0,$sy,jr &H53A0

; command CLEAR, prefix 4, code &H6A
53A8:	cal	&H46B3
53AB:	pre	ix,&H18A3
53AF:	ldim	$16,(ix+$sx),6
53B2:	ldw	$18,$20
53B5:	pre	ix,&H1897
53B9:	ldw	$0,(ix+$sx)
53BB:	sbw	$20,$sz
53BD:	sbw	$18,$16
53C0:	ld	$28,$sx
53C2:	cal	&H003C		;ENDSC, test for an end of a BASIC line
53C5:	jr	c,&H5416
53C7:	cal	&H00C3
53CA:	jr	z,&H53E2
53CC:	phsw	$21
53CE:	phs	$28
53D0:	cal	&H0EDF
53D3:	pps	$28
53D5:	ldw	$18,$15
53D8:	ppsw	$15
53DA:	cal	&H003C		;ENDSC, test for an end of a BASIC line
53DD:	jr	c,&H53F5
53DF:	cal	&H00DB
53E2:	cal	&H503D
53E5:	phsw	$19
53E7:	cal	&H0EDF
53EA:	cal	&H0093		;SN Error if not an end of a BASIC line
53ED:	ppsw	$18
53EF:	ld	$28,$sy
53F1:	sbcw	$15,$sy
53F3:	jr	c,&H53F8
53F5:	sbcw	$15,$18
53F8:	jp	c,&H2BA4	;BS Error, subscript out of range
53FB:	cal	&H5363
53FE:	pre	ix,&H18A7	;table of file addresses
5402:	ldw	$16,(ix+$sx)
5404:	sbw	$16,$18
5407:	pre	ix,&H18A3
540B:	stw	$16,(ix+$sx)
540D:	cal	&H5416
5410:	sbc	$28,$sx
5412:	rtn	z
5413:	jp	&H1FB9
5416:	pre	ix,&H18A3
541A:	ldw	$16,(ix+$sx)
541C:	ld	$0,&H06
541F:	pre	ix,&H189B
5423:	stiw	$16,(ix+$sx)
5425:	sb	$0,$sy
5427:	jr	nz,&H5423
5429:	jp	&H28B3		;clear the string operation stack

; command CALCJMP, prefix 4, code &H9F
542C:	cal	&H2972
542F:	jp	nz,&H2BA8	;FC Error, unrecognized command
5432:	cal	&H0093		;SN Error if not an end of a BASIC line
5435:	cal	&H2930
5438:	std	$31,(ix+$sy)
543A:	jp	&H2DB8
543D:	cal	&H2F01
5440:	gre	iz,$0
5442:	phsw	$1
5444:	cal	&H5460
5447:	pre	iz,$15
5449:	cal	&H5474
544C:	gre	iz,$15
544E:	pre	ix,&H16D9
5452:	stw	$15,(ix+$sx)
5454:	ppsw	$0
5456:	pre	iz,$0
5458:	cal	&H00C3
545B:	jr	z,&H543D
545D:	jp	&H0093		;SN Error if not an end of a BASIC line

5460:	ldw	$2,&H16D9
5464:	ldw	$15,($2)
5467:	sbcw	$15,$sy
5469:	rtn	nc
546A:	pre	ix,&H16D5
546E:	ldw	$15,(ix+$sx)
5470:	stw	$15,($2)
5473:	rtn
5474:	cal	&H0049
5477:	sbc	$0,&H1A
547A:	jp	z,&H2BBC	;DA error, no data for READ
547D:	pre	ix,&H167F
5481:	adc	(ix+$sx),$31
5483:	jr	lz,&H54BD
5485:	sbc	$0,&H0D
5488:	jr	z,&H54B8
548A:	sbc	$0,&H2C
548D:	jr	z,&H54B8
548F:	cal	&H128A
5492:	jp	nc,&H2BB0
5495:	sbc	$0,&H0D
5498:	jr	z,&H549F
549A:	cal	&H00DB
549D:	ldd	$0,(iz-$sy)
549F:	cal	&H31AD
54A2:	cal	&H0049
54A5:	sbc	$0,&H1A
54A8:	rtn	z
54A9:	sbc	$0,&H0D
54AC:	jp	nz,&H00DB
54AF:	ldd	$0,(iz+$sy)
54B1:	sbc	$0,&H0A
54B4:	rtn	nz
54B5:	ldd	$0,(iz+$sy)
54B7:	rtn
54B8:	cal	&H0636
54BB:	jr	&H549F
54BD:	cal	&H54DC
54C0:	jr	&H549F
54C2:	ldd	$0,(iz+$sx)
54C4:	gre	iz,$15
54C6:	ld	$17,$sx
54C8:	sbc	$0,&H1A
54CB:	rtn	z
54CC:	sbc	$0,&H0D
54CF:	rtn	z
54D0:	sbc	$1,$sz
54D2:	ldd	$0,(iz+$sy)
54D4:	rtn	z
54D5:	ad	$17,$sy
54D7:	jp	c,&H2B74	;ST Error, string too long
54DA:	jr	&H54C8
54DC:	ld	$1,&H22
54DF:	cal	&H00D1
54E2:	jr	z,&H54C2
54E4:	gre	iz,$15
54E6:	ld	$17,$sx
54E8:	ldd	$0,(iz+$sx)
54EA:	sbc	$0,&H1A
54ED:	rtn	z
54EE:	sbc	$0,&H0D
54F1:	rtn	z
54F2:	sbc	$0,&H2C
54F5:	rtn	z
54F6:	sbc	$0,&H20
54F9:	jp	c,&H2B70	;SN Error, syntax
54FC:	ldd	$0,(iz+$sy)
54FE:	ad	$17,$sy
5500:	jp	c,&H2B74	;ST Error, string too long
5503:	jr	&H54EA
5505:	ld	$1,$17
5508:	pre	ix,$15
550A:	sb	$1,$sy
550C:	rtn	c
550D:	ldi	$0,(ix+$sx)
550F:	sbc	$0,&H20
5512:	jr	nc,&H550A
5514:	jp	&H2BA8		;FC Error, unrecognized command

; command WRITE#, prefix 4, code &H4E
5517:	cal	&H5044		;FC Error if BASIC interpreter not in RUN mode
551A:	cal	&H5460
551D:	cal	&H003C		;ENDSC, test for an end of a BASIC line
5520:	jp	c,&H5653
5523:	cal	&H1088
5526:	gre	iz,$0
5528:	phsw	$1
552A:	cal	c,&H5505
552D:	cal	nc,&H13A7
5530:	ld	$18,$sx
5532:	pre	ix,&H16D9
5536:	ldw	$4,(ix+$sx)
5538:	pre	iz,$4
553A:	ldi	$0,(iz+$sx)
553C:	sbc	$0,&H1A
553F:	jr	z,&H554B
5541:	sbc	$0,&H0D
5544:	jr	z,&H554B
5546:	sbc	$0,&H2C
5549:	jr	nz,&H553A
554B:	ldd	$0,(iz-$sy)
554D:	gre	iz,$0
554F:	sbw	$0,$4
5552:	phsw	$1
5554:	cal	&H5680
5557:	gre	iz,$0
5559:	pre	ix,&H168E
555D:	stm	$30,(ix+$sx),4
5560:	ldi	$2,(iz+$sx)
5562:	sbc	$2,&H1A
5565:	jr	z,&H556C
5567:	sbc	$2,&H0D
556A:	jr	nz,&H5560
556C:	ldd	$2,(iz-$sy)
556E:	gre	iz,$2
5570:	sbw	$2,$sz
5572:	ppsw	$0
5574:	sbw	$2,$sz
5576:	adw	$2,$17
5579:	sbc	$3,$sx
557B:	jp	nz,&H2B74	;ST Error, string too long
557E:	sbcw	$17,$sz
5580:	jr	z,&H55EA
5582:	phsm	$18,4
5585:	jr	c,&H55AB
5587:	sbw	$17,$sz
5589:	ldw	$0,$17
558C:	pre	ix,&H16D9
5590:	ldw	$2,(ix+$sx)
5592:	ld	$4,($2)
5595:	sbc	$4,&H1A
5598:	jr	nz,&H55A4
559A:	pre	ix,&H168E
559E:	std	$31,(ix+$sx)
55A0:	adw	$0,$sy
55A2:	adw	$0,$sy
55A4:	phsw	$3
55A6:	cal	&H34B1		;expand a memory block in a RAM file
55A9:	jr	&H55E3
55AB:	ldw	$2,$sz
55AD:	sbw	$2,$17
55B0:	pre	ix,&H16D9
55B4:	ldw	$0,(ix+$sx)
55B6:	sbc	$17,$sx
55B8:	jr	nz,&H55DE
55BA:	pre	ix,&H1690
55BE:	sbcw	(ix+$sx),$0
55C0:	jr	nz,&H55DE
55C2:	ldw	$4,$sz
55C4:	adw	$4,$2
55C7:	ldw	$4,($4)
55CA:	sbc	$4,&H0D
55CD:	jr	nz,&H55DE
55CF:	pre	ix,&H168F
55D3:	std	$30,(ix+$sx)
55D5:	adw	$2,$sy
55D7:	sbc	$5,&H0A
55DA:	jr	nz,&H55DE
55DC:	adw	$2,$sy
55DE:	phsw	$1
55E0:	cal	&H34EA		;shrink a memory block in a RAM file
55E3:	ppsw	$0
55E5:	ppsm	$15,4
55E8:	jr	&H55F0
55EA:	pre	ix,&H16D9
55EE:	ldw	$0,(ix+$sx)
55F0:	sbc	$17,$sx
55F2:	ldw	$6,$sz
55F4:	jr	z,&H5618
55F6:	ldm	$2,$15,4
55F9:	phsm	$5,6
55FC:	cal	&H00F9
55FF:	ppsm	$0,6
5602:	ldw	$6,$sz
5604:	adw	$6,$4
5607:	pre	ix,&H168E
560B:	sbc	(ix+$sx),$31
560D:	jr	nz,&H5618
560F:	adw	$4,$sz
5611:	ldw	$2,&H0A0D
5615:	stw	$2,($4)
5618:	pre	iz,$6
561A:	pre	ix,&H168F
561E:	sbc	(ix+$sx),$31
5620:	jr	nz,&H5633
5622:	ldi	$0,(iz+$sx)
5624:	sbc	$0,&H1A
5627:	jr	z,&H564F
5629:	sbc	$0,&H0D
562C:	jr	z,&H5648
562E:	sbc	$0,&H2C
5631:	jr	nz,&H5622
5633:	gre	iz,$15
5635:	pre	ix,&H16D9
5639:	stw	$15,(ix+$sx)
563B:	ppsw	$0
563D:	pre	iz,$0
563F:	cal	&H00C3
5642:	jp	z,&H5523
5645:	jp	&H0093		;SN Error if not an end of a BASIC line

5648:	ldi	$0,(iz+$sx)
564A:	sbc	$0,&H0A
564D:	jr	z,&H5633
564F:	ldd	$0,(iz-$sy)
5651:	jr	&H5633
5653:	gre	iz,$0
5655:	phsw	$1
5657:	pre	ix,&H16D9
565B:	ldw	$0,(ix+$sx)
565D:	pre	iz,$0
565F:	cal	&H5680
5662:	gre	iz,$4
5664:	cal	&H0B7E		;move pointer IZ to the next line
5667:	ldw	$0,$4
566A:	gre	iz,$2
566C:	sbw	$2,$sz
566E:	phsw	$1
5670:	cal	&H34EA		;shrink a memory block in a RAM file
5673:	ppsw	$15
5675:	pre	ix,&H16D9
5679:	stw	$15,(ix+$sx)
567B:	ppsw	$0
567D:	pre	iz,$0
567F:	rtn
5680:	pre	ix,&H16D5
5684:	ldm	$25,(ix+$sx),4
5687:	gre	iz,$0
5689:	sbcw	$25,$sz
568B:	rtn	z
568C:	ldd	$0,(iz-$sy)
568E:	sbc	$0,&H0D
5691:	jr	nz,&H5687
5693:	ldd	$0,(iz+$sy)
5695:	sbc	$0,&H0A
5698:	rtn	nz
5699:	ldd	$0,(iz+$sy)
569B:	rtn
569C:	cal	&H00C5
569F:	ld	$14,$sx
56A1:	jr	nz,&H56E1
56A3:	cal	&H11D2		;evaluate a string expression
56A6:	cal	&H00C7
56A9:	jr	nz,&H56C4
56AB:	sbc	$17,&H02
56AE:	jr	nz,&H56C4
56B0:	ldw	$0,($15)
56B3:	sbc	$0,&H46
56B6:	jr	z,&H56BD
56B8:	sbc	$0,&H66
56BB:	jr	nz,&H56C4
56BD:	bydw	$1
56BF:	cal	&H002B		;OKNM1, is $0 a digit?
56C2:	jr	c,&H56C7
56C4:	jp	&H2B88		;BF Error, improper filename
56C7:	ld	$14,$sz
56C9:	sb	$14,&H30
56CC:	gre	iz,$3
56CE:	cal	&H3425
56D1:	pre	iz,$3
56D3:	pre	ix,&H16D9
56D7:	stw	$25,(ix+$sx)
56D9:	pre	ix,&H16D5
56DD:	stm	$25,(ix+$sx),4
56E0:	rtn
56E1:	pre	ix,&H16D9
56E5:	sbcw	(ix+$sx),$30
56E7:	rtn	nc
56E8:	jr	&H56CC
56EA:	cal	&H569C
56ED:	cal	&H003C		;ENDSC, test for an end of a BASIC line
56F0:	jp	c,&H576A
56F3:	cal	&H11D2		;evaluate a string expression
56F6:	cal	&H5778
56F9:	jr	nc,&H5740
56FB:	cal	&H00C3
56FE:	jr	nz,&H573D
5700:	cal	&H00C3
5703:	jr	z,&H573A
5705:	cal	&H0049
5708:	ldd	$1,(iz+$sy)
570A:	sbc	$0,&H30
570D:	jr	z,&H5735
570F:	sbc	$0,&H31
5712:	jp	nz,&H2B70	;SN Error, syntax
5715:	pre	ix,$23
5717:	gre	ix,$0
5719:	sbcw	$25,$sz
571B:	jr	z,&H572D
571D:	ldd	$0,(ix-$sy)
571F:	sbc	$0,&H0D
5722:	jr	nz,&H5717
5724:	ldd	$0,(ix+$sy)
5726:	sbc	$0,&H0A
5729:	jr	nz,&H572D
572B:	ldd	$0,(ix+$sy)
572D:	gre	ix,$23
572F:	pre	ix,&H16D9
5733:	stw	$23,(ix+$sx)
5735:	cal	&H00C3
5738:	jr	nz,&H573D
573A:	cal	&H0B99
573D:	jp	&H0093		;SN Error if not an end of a BASIC line

5740:	cal	&H00C3
5743:	jp	nz,&H2BBC	;DA error, no data for READ
5746:	cal	&H00C3
5749:	jr	z,&H5761
574B:	cal	&H0049
574E:	ldd	$1,(iz+$sy)
5750:	sbc	$0,&H30
5753:	jr	z,&H575B
5755:	sbc	$0,&H31
5758:	jp	nz,&H2B70	;SN Error, syntax
575B:	cal	&H00C3
575E:	jp	nz,&H2BBC	;DA error, no data for READ
5761:	ld	$2,&H49
5764:	cal	&H00EF
5767:	jp	&H368A
576A:	pre	ix,&H16D5
576E:	ldim	$0,(ix+$sx),4
5771:	pre	ix,&H16D9
5775:	stw	$0,(ix+$sx)
5777:	rtn
5778:	gre	iz,$0
577A:	phsw	$1
577C:	pre	ix,&H16D5
5780:	ldim	$25,(ix+$sx),4
5783:	pre	ix,&H16D9
5787:	ldw	$23,(ix+$sx)
5789:	sbc	$17,$sy
578B:	jr	c,&H57D4
578D:	pre	ix,$23
578F:	gre	ix,$23
5791:	pre	iz,$15
5793:	ld	$2,$17
5796:	ldi	$0,(ix+$sx)
5798:	sbc	$0,&H1A
579B:	jr	z,&H57A9
579D:	ldi	$1,(iz+$sx)
579F:	sbc	$1,$sz
57A1:	jr	nz,&H57B4
57A3:	sb	$2,$sy
57A5:	jr	nz,&H5796
57A7:	sbc	$31,$sy
57A9:	pre	ix,&H16D9
57AD:	stw	$23,(ix+$sx)
57AF:	ppsw	$0
57B1:	pre	iz,$0
57B3:	rtn
57B4:	pre	ix,$23
57B6:	ldi	$0,(ix+$sx)
57B8:	sbc	$0,&H1A
57BB:	jr	z,&H57A9
57BD:	sbc	$0,&H0D
57C0:	jr	z,&H57C9
57C2:	sbc	$0,&H2C
57C5:	jr	nz,&H57B6
57C7:	jr	&H578F
57C9:	ldi	$0,(ix+$sx)
57CB:	sbc	$0,&H0A
57CE:	jr	z,&H578F
57D0:	ldd	$0,(ix-$sy)
57D2:	jr	&H578F
57D4:	ld	$0,($23)
57D7:	sbc	$0,&H1A
57DA:	jr	z,&H57AF
57DC:	jr	&H57A7

; table of the "prefix 4" command addresses, keyword codes &H49-&HB5
57DE:	368A, 3620, 3663, 3ACB	;49:GOTO, 4A:GOSUB, 4B:RETURN, 4C:RESUME
57E6:	42EB, 5517, 393E, 35AD	;4D:RESTORE, 4E:WRITE#, 4F:???, 50:CONT
57EE:	2BA8, 51BA, 525C, 2BA8	;51:none, 52:SYSTEM, 53:PASS, 54:none
57F6:	3CDD, 2BA8, 3D26, 3D21	;55:DELETE, 56:none, 57:LIST, 58:LLIST
57FE:	4753, 474B, 2BA8, 43DA	;59:LOAD, 5A:MERGE, 5B:none, 5C:RENUM
5806:	3617, 2BA8, 3614, 474F	;5D:TRON, 5E:none, 5F:TROFF, 60:VERIFY
580E:	2BA8, 2BA8, 3A23, 2BA8	;61:none, 62:none, 63:POKE, 64:none
5816:	2BA8, 2BA8, 2BA8, 2BA8	;65:none, 66:none, 67:none, 68:none
581E:	4762, 53A8, 4594, 4736	;69:CHAIN, 6A:CLEAR, 6B:NEW, 6C:SAVE
5826:	352C, 3929, 58B8, 43C7	;6D:RUN, 6E:ANGLE, 6F:EDIT, 70:BEEP
582E:	2ADF, 46B0, 2BA8, 2BA8	;71:CLS, 72:CLOSE, 73:none, 74:none
5836:	2BA8, 397D, 2BA8, 3A3A	;75:none, 76:DEF, 77:none, 78:DEFSEG
583E:	2BA8, 2BA8, 2BA8, 3A4A	;79:none, 7A:none, 7B:none, 7C:DIM
5846:	2BA8, 2BA8, 2BA8, 0B9B	;7D:none, 7E:none, 7F:none, 80:DATA
584E:	36F9, 383B, 2BA8, 2BA8	;81:FOR, 82:NEXT, 83:none, 84:none
5856:	3A81, 2BA8, 3520, 2BA8	;85:ERASE, 86:ERROR, 87:END, 88:none
585E:	2BA8, 2BA8, 7F0F, 2BA8	;89:none, 8A:none, 8B:FORMAT, 8C:none
5866:	38BB, 7F1E, 2EA2, 3E26	;8D:IF, 8E:KILL, 8F:LET, 90:LINE
586E:	39FA, 2BA8, 2BA8, 2BA8	;91:LOCATE, 92:none, 93:none, 94:none
5876:	2BA8, 7F35, 45DF, 2BA8	;95:none, 96:NAME, 97:OPEN, 98:none
587E:	2BA8, 3B71, 2BA8, 2BA8	;99:OUT, 9A:ON, 9B:none, 9C:none
5886:	2BA8, 2BA8, 542C, 2BA8	;9D:none, 9E:none, 9F:CALCJMP, A0:none
588E:	2BA8, 2BA8, 3EF1, 3EEC	;A1:none, A2:none, A3:PRINT, A4:LPRINT
5896:	2BA8, 2BA8, 2BA8, 42A0	;A5:PUT, A6:none, A7:none, A8:READ
589E:	0B9B, 2BA8, 2BA8, 532A	;A9:REM, AA:none, AB:none, AC:SET
58A6:	4322, 3500, 2BA8, 52A2	;AD:STAT, AE:STOP, AF:none, B0:MODE
58AE:	2BA8, 3BEB, 2BA8, 2BA8	;B1:none, B2:VAR, B3:none, B4:none
58B6:	7F87			;B5:FILES

; command EDIT, prefix 4, code &H6F
58B8:	cal	&H5053		;check if BASIC and not RUN mode, no password
58BB:	cal	&H278D
58BE:	cal	&H003C		;ENDSC, test for an end of a BASIC line
58C1:	jr	c,&H58E9
58C3:	cal	&H00CF
58C6:	jr	z,&H58FA
58C8:	cal	&H1EDF
58CB:	ldw	$15,$17
58CE:	cal	&H0093		;SN Error if not an end of a BASIC line
58D1:	cal	&H5176		;LNSCH, search for a BASIC line $4,$5
58D4:	adc	(iz+$sx),$31
58D6:	jp	z,&H1FB9
58D9:	cal	&H529B		;PR Error if password set
58DC:	ld	$29,&H03
58DF:	ldw	$2,&H5BF1
58E3:	cal	&H5AB7
58E6:	jp	&H5B88
58E9:	cal	&H33EE		;get starting/ending address of current file
58EC:	ldw	$6,$1
58EF:	ldw	$19,$25
58F2:	cal	&H33FA		;$2,$3 <- file size
58F5:	jp	z,&H1FB9
58F8:	jr	&H58D9
58FA:	ldw	$0,&H16CB
58FE:	ldw	$15,($sz),jr &H58CE
5901:	phsw	$1
5903:	jr	&H590C
5905:	phsw	$1
5907:	pre	iz,$19
5909:	cal	&H0B7E		;move pointer IZ to the next line
590C:	gre	iz,$2
590E:	sbw	$2,$19
5911:	ppsw	$0
5913:	sbcw	$2,$sz
5915:	jr	z,&H593A
5917:	phsw	$1
5919:	jr	c,&H592F
591B:	sbw	$2,$sz
591D:	ldw	$0,$19
5920:	cal	&H34EA		;shrink a memory block in a RAM file
5923:	ppsw	$4
5925:	ldw	$0,$19
5928:	ldw	$2,&H19D5
592C:	jp	&H00F9
592F:	sbw	$0,$2
5932:	ldw	$2,$19
5935:	cal	&H34B1		;expand a memory block in a RAM file
5938:	jr	&H5923
593A:	ldw	$4,$sz,jr &H5925
593D:	pre	iz,$19
593F:	anc	$29,$sy
5941:	jr	nz,&H5952
5943:	cal	&H5A18
5946:	jr	z,&H5959
5948:	cal	&H0B7E		;move pointer IZ to the next line
594B:	sbc	(iz+$sx),$4
594D:	jr	z,&H5959
594F:	adc	$30,$sx		;Not Zero flag
5951:	rtn
5952:	ldi	$0,(iz+$sx)
5954:	ldd	$1,(iz+$sz)
5956:	sbc	$1,$sx
5958:	rtn	nz
5959:	sbc	$31,$sy
595B:	rtn
595C:	sbcw	$19,$25
595F:	jr	z,&H5959
5961:	pre	iz,$25
5963:	anc	$29,$sy
5965:	jr	nz,&H5989
5967:	ldw	$0,&H0002
596B:	sbcw	$17,$sz
596D:	rtn	z
596E:	pre	ix,$19
5970:	ldw	$0,&H0A0D
5974:	pre	iy,$25
5976:	ldd	$2,(ix-$sy)
5978:	sdn	$0
597A:	ldd	$2,(ix-$sy)
597C:	sdn	$0
597E:	ldd	$2,(ix+$sy)
5980:	gre	ix,$2
5982:	pre	iz,$2
5984:	cal	&H0B88
5987:	jr	&H594F
5989:	ldi	$0,(iz+$sx)
598B:	ldd	$1,(iz+$sz)
598D:	gre	iz,$2
598F:	sbcw	$19,$2
5992:	jr	nz,&H5989
5994:	ldd	$1,(iz-$sz)
5996:	ldd	$0,(iz-$sy)
5998:	rtn
5999:	sbcw	$17,$sy
599B:	jr	nc,&H599F
599D:	ldw	$17,$sy
599F:	sbw	$3,$3
59A2:	pre	iz,$25
59A4:	adw	$3,$sy
59A6:	sbcw	$17,$3
59A9:	jr	z,&H59BD
59AB:	ld	$0,&H1A
59AE:	sbc	(iz+$sx),$0
59B0:	jr	z,&H59BD
59B2:	cal	&H0B7E		;move pointer IZ to the next line
59B5:	gre	iz,$0
59B7:	adw	$0,$sy
59B9:	sbcw	$27,$sz
59BB:	jr	nz,&H59A4
59BD:	gre	iz,$19
59BF:	rtn
59C0:	ldw	$19,$27
59C3:	sbw	$19,$sy
59C5:	cal	&H59CA
59C8:	jr	&H59BD
59CA:	ldw	$15,$sy
59CC:	pre	iz,$25
59CE:	gre	iz,$2
59D0:	sbcw	$19,$2
59D3:	rtn	z
59D4:	cal	&H5A18
59D7:	jr	z,&H59BD
59D9:	cal	&H0B7E		;move pointer IZ to the next line
59DC:	adw	$15,$sy,jr &H59CE

59DF:	ld	$4,$21
59E2:	ld	$0,$23
59E5:	sb	$0,$22
59E8:	pre	ix,&H1BE0
59EC:	stw	$23,(ix-$sy)
59EE:	cal	&H01F7
59F1:	pre	ix,$2
59F3:	adc	$4,$sx
59F5:	jr	nz,&H59F9
59F7:	ld	$4,$sy
59F9:	ld	$0,$4
59FC:	cal	&H6E79
59FF:	jp	&H930F
5A02:	cal	&H01F7
5A05:	ld	$0,&H0F
5A08:	jp	&H6E77
5A0B:	ld	$0,&H02
5A0E:	ldw	$1,&H0A0D
5A12:	sbcw	(iz-$sz),$1
5A14:	rtn	z
5A15:	sbc	(iz-$sy),$1
5A17:	rtn
5A18:	ld	$4,&H1A
5A1B:	sbc	(iz+$sx),$4
5A1D:	rtn

5A1E:	EE, 6124
5A21:	EF, 6124
5A24:	E9, 5F9E
5A27:	E2, 5FA9
5A2A:	E7, 5F93
5A2D:	E6, 5F3A
5A30:	E0, 5FB4
5A33:	E1, 5FB4
5A36:	FD, 5FCD
5A39:	00, 5BA3

5A3C:	EE, 6124
5A3F:	EF, 6124
5A42:	E9, 5FA1
5A45:	E2, 5FAC
5A48:	E0, 5FB7
5A4B:	E1, 5FB7
5A4E:	E7, 5F96
5A51:	E6, 5F65
5A54:	FD, 5FCD
5A57:	00, 5BA3

5A5A:	ld	$16,$sz
5A5C:	sbc	$16,&HE8
5A5F:	jp	z,&H2DB8
5A62:	sbc	$16,&H80
5A65:	jr	c,&H5A6D
5A67:	sbc	$16,&HA6
5A6A:	jp	c,&H5F7A
5A6D:	sbc	$16,&HFD
5A70:	jp	z,&H5DA6
5A73:	sbc	$16,&H20
5A76:	jp	nc,&H5EF9
5A79:	pre	ix,&H5A80
5A7D:	jp	&H0166		;execute a procedure from the table

; MEMO editor key codes and addresses of handler procedures
5A80:	01, 5E2A	;[S]+down
5A83:	02, 5E7C	;line top
5A86:	05, 5EDD	;line del
5A89:	06, 5E7C	;line end
5A8C:	0C, 5EDD	;CLS
5A8F:	0D, 5D62	;EXE
5A92:	10, 5E1C	;[S]+up
5A95:	1C, 5E7C	;right
5A98:	1D, 5E7C	;left
5A9B:	1E, 5DF0	;up
5A9E:	1F, 5DC7	;down
5AA1:	00, 5DDB	;no matching code found

5AA4:	ld	$14,$sx
5AA6:	cal	&H3425
5AA9:	ldw	$17,$sy
5AAB:	ldw	$19,$25
5AAE:	sbw	$22,$22
5AB1:	rtn

5AB2:	cal	&H5B5D
5AB5:	jr	&H5ABA
5AB7:	cal	&H5B57
5ABA:	sbbm	$21,$21,3
5ABD:	cal	&H5C30
5AC0:	anc	$29,$sy
5AC2:	jp	z,&H976E
5AC5:	jp	&H9774
5AC8:	cal	&H3419
5ACB:	jp	&H97FE

; MEMO-IN
5ACE:	cal	&H296A
5AD1:	jr	z,&H5B04
5AD3:	sbc	(ix+$sy),$31
5AD5:	jr	nz,&H5B04
5AD7:	ld	$29,&H06
5ADA:	ldw	$2,&H5B23
5ADE:	cal	&H5B57
5AE1:	cal	&H976E
5AE4:	anc	$24,$sy
5AE6:	jr	nz,&H5B01
5AE8:	anc	$24,&H02
5AEB:	jr	nz,&H5AFB
5AED:	sbcw	$19,$25
5AF0:	jr	z,&H5B44
5AF2:	ldw	$0,$27
5AF5:	sbw	$0,$sy
5AF7:	sbcw	$19,$sz
5AF9:	jr	z,&H5B23
5AFB:	cal	&H5C37
5AFE:	cal	&H5C70
5B01:	jp	&H5B9E
5B04:	cal	&H277E
5B07:	cal	&H2771
5B0A:	cal	&H5294		;IX <- password buffer
5B0D:	jp	nz,&H6CC6	;branch if password set
5B10:	cal	&H246E
5B13:	cal	&H5AA4
5B16:	ld	$29,&H06
5B19:	ldw	$2,&H5B23
5B1D:	ld	$24,&H02
5B20:	cal	&H5AB7
5B23:	cal	&H0323
5B26:	cal	&H5AC0
5B29:	anc	$29,$sy
5B2B:	jr	nz,&H5B49
5B2D:	cal	&H59C0
5B30:	ldw	$17,$15
5B33:	sbcw	$17,$sy
5B35:	jr	z,&H5B49
5B37:	cal	&H5A0B
5B3A:	jr	z,&H5B49
5B3C:	sbw	$17,$sy
5B3E:	cal	&H5999
5B41:	jp	&H5E71
5B44:	ldw	$17,$sy
5B46:	ldw	$19,$25
5B49:	cal	&H5C26
5B4C:	sbw	$22,$22
5B4F:	ld	$24,&H08
5B52:	cal	&H031B		;cursor display enable
5B55:	jr	&H5B9E
5B57:	pre	ix,&H16C5
5B5B:	std	$31,(ix+$sx)
5B5D:	pre	ix,&H16C4
5B61:	std	$29,(ix+$sx)
5B63:	cal	&H297A		;BRSTR, set ACJMP
5B66:	pre	us,&H1CD0
5B6A:	phum	$29,8
5B6D:	phum	$21,5
5B70:	rtn
5B71:	sbc	$24,&H08
5B74:	jr	nz,&H5B88
5B76:	anc	$29,$sy
5B78:	jr	nz,&H5B88
5B7A:	sbcw	$19,$25
5B7D:	jr	z,&H5B44
5B7F:	ldw	$0,$27
5B82:	sbw	$0,$sy
5B84:	sbcw	$19,$sz
5B86:	jr	z,&H5B23
5B88:	anc	$29,$sy
5B8A:	jr	nz,&H5B93
5B8C:	pre	iz,$19
5B8E:	cal	&H5A18
5B91:	jr	z,&H5B23
5B93:	cal	&H33FA		;$2,$3 <- file size
5B96:	jr	z,&H5BEC
5B98:	cal	&H5C37
5B9B:	cal	&H5C70
5B9E:	anc	$29,$sy
5BA0:	cal	z,&H5D18
5BA3:	pre	ss,&H1BD7
5BA7:	cal	&H5B66
5BAA:	cal	&H23C8
5BAD:	sbc	$0,&HF0
5BB0:	jr	c,&H5BC3
5BB2:	sbc	$0,&HFA
5BB5:	jr	nc,&H5BC3
5BB7:	cal	&H2972
5BBA:	ld	$0,$16
5BBD:	jp	nz,&H24BE
5BC0:	an	$0,&H3F
5BC3:	pre	ix,&H5A80
5BC7:	ld	$16,$sz
5BC9:	sbc	$24,$sy
5BCB:	jr	z,&H5C0E
5BCD:	pre	ix,&H5A3C
5BD1:	sbc	$16,&HE0
5BD4:	jr	nc,&H5C0B
5BD6:	sbc	$16,&H0D
5BD9:	jp	z,&H5FDB
5BDC:	sbc	$16,&H80
5BDF:	jr	c,&H5BE7
5BE1:	sbc	$16,&HA6
5BE4:	jp	c,&H5F7D
5BE7:	cal	&H2AE3		;display character $16
5BEA:	jr	&H5BA3
5BEC:	anc	$29,$sy
5BEE:	jp	z,&H5B44
5BF1:	pre	iz,$19
5BF3:	ldw	$5,(iz+$sy)
5BF5:	cal	&H3412
5BF8:	cal	&H0323
5BFB:	cal	&H2771
5BFE:	pre	ix,&H16C4
5C02:	stw	$30,(ix+$sx)
5C04:	jp	&H1FB9
5C07:	pre	ix,&H5A1E
5C0B:	jp	&H0166		;execute a procedure from the table

5C0E:	sbc	$16,&H80
5C11:	jr	c,&H5C19
5C13:	sbc	$16,&HA6
5C16:	jp	c,&H5F7A
5C19:	sbc	$16,&HE0
5C1C:	jr	nc,&H5C07
5C1E:	sbc	$16,&H20
5C21:	jr	c,&H5C0B
5C23:	jp	&H5EDD
5C26:	phs	$16
5C28:	cal	&H9753		;INCLR, clear the INTOP input buffer
5C2B:	cal	&H2ADF
5C2E:	pps	$16
5C30:	pre	ix,&H1BE0
5C34:	std	$31,(ix+$sx)
5C36:	rtn
5C37:	sbw	$22,$22
5C3A:	cal	&H9753		;INCLR, clear the INTOP input buffer
5C3D:	pre	iz,$19
5C3F:	anc	$29,$sy
5C41:	jr	z,&H5C46
5C43:	jp	&H508B		;ENLST
5C46:	pre	ix,&H1000
5C4A:	ldw	$0,&H000D
5C4E:	ldi	$2,(iz+$sx)
5C50:	sbc	$2,$sz
5C52:	rtn	z
5C53:	sbc	$2,&H1A
5C56:	rtn	z
5C57:	ad	$1,$sy
5C59:	jr	c,&H5C67
5C5B:	sbc	$2,&H20
5C5E:	jr	nc,&H5C63
5C60:	ld	$2,&H20
5C63:	sti	$2,(ix+$sx)
5C65:	jr	&H5C4E
5C67:	sbc	$29,&H04
5C6A:	cal	z,&H2ADF
5C6D:	jp	&H2B7C
5C70:	cal	&H9338
5C73:	anc	$29,$sy
5C75:	jp	z,&H6259
5C78:	ld	$0,$22
5C7B:	cal	&H5CC9
5C7E:	sb	$13,$sz
5C80:	ld	$12,&H80
5C83:	ad	$13,$12
5C86:	jr	c,&H5C9F
5C88:	cal	&H593D
5C8B:	jr	c,&H5C9F
5C8D:	cal	&H5CB4
5C90:	jr	c,&H5C9F
5C92:	phs	$12
5C94:	cal	&H5091
5C97:	pps	$12
5C99:	jr	c,&H5C9F
5C9B:	adc	(iz+$sx),$31
5C9D:	jr	nz,&H5C8D
5C9F:	ldw	$10,&H5F00
5CA3:	cal	&H9343
5CA6:	cal	&H032E		;cursor display disable
5CA9:	cal	&H5C30
5CAC:	ld	$24,$sy
5CAE:	cal	&H977F
5CB1:	jp	&H92F5
5CB4:	an	$13,&HE0
5CB7:	ad	$13,&H20
5CBA:	rtn	c
5CBB:	pre	ix,&H113B
5CBF:	ld	$2,$13
5CC2:	sb	$2,$12
5CC5:	ldd	$3,(ix+$2)
5CC8:	rtn
5CC9:	pre	ix,&H1000
5CCD:	ldd	$0,(ix+$sz)
5CCF:	gre	ix,$0
5CD1:	pre	iy,&H10FF
5CD5:	sup	$31
5CD7:	gre	ix,$13
5CD9:	pre	iy,$13
5CDB:	pre	ix,$0
5CDD:	pre	iz,&H113B
5CE1:	bup
5CE2:	rtn
5CE3:	pre	ix,&H1534
5CE7:	ldw	$14,&H3C00
5CEB:	stiw	$14,(ix+$sx)
5CED:	sbw	$15,$15
5CF0:	ldw	$3,$17
5CF3:	cal	&H0AB4
5CF6:	ldw	$0,&H0005
5CFA:	an	$16,&H0F
5CFD:	jr	nz,&H5D12
5CFF:	sbc	$1,$sx
5D01:	jr	nz,&H5D14
5D03:	sti	$16,(ix+$sx)
5D05:	dium	$14,3
5D08:	sb	$0,$sy
5D0A:	jr	nz,&H5CFA
5D0C:	ld	$16,&H3E
5D0F:	std	$16,(ix+$sx)
5D11:	rtn
5D12:	ld	$1,$sy
5D14:	ad	$16,&H30,jr &H5D03
5D18:	cal	&H5D57
5D1B:	cal	&H5CE3
5D1E:	pre	ix,&H151C
5D22:	gst	ua,$11
5D24:	gre	ix,$12
5D26:	ldw	$2,&H147C
5D2A:	ld	$10,&H20
5D2D:	ld	$16,($12)
5D30:	adw	$12,$sy
5D32:	cal	&H033A
5D35:	ldm	$4,(ix+$sx),6
5D38:	pst	ua,$0
5D3A:	pre	ix,$2
5D3C:	stim	$4,(ix+$sx),6
5D3F:	gre	ix,$2
5D41:	sb	$10,$sy
5D43:	jr	nz,&H5D2D
5D45:	pst	ua,$11
5D47:	pre	ix,&H147C
5D4B:	ld	$4,&H03
5D4E:	jp	&H0205
5D51:	pre	iz,&H16C6
5D55:	std	$30,(iz+$sx)
5D57:	ldw	$0,&H151C
5D5B:	ldw	$2,&H0020
5D5F:	jp	&H0157		;CLRME, clear memory block

; MEMO editor, key code &H0D (EXE)
5D62:	cal	&H593D
5D65:	jr	c,&H5D84
5D67:	sbc	$24,&H08
5D6A:	jr	z,&H5D72
5D6C:	adw	$17,$sy
5D6E:	gre	iz,$19
5D70:	ld	$22,$sx
5D72:	sbc	$29,&H04
5D75:	jp	nz,&H5B88
5D78:	ld	$23,$22
5D7B:	cal	&H5C3A
5D7E:	cal	&H6220
5D81:	jp	&H2002
5D84:	sbc	$29,&H04
5D87:	jr	z,&H5D81
5D89:	anc	$29,$sy
5D8B:	jr	nz,&H5D9F
5D8D:	sbc	$24,&H08
5D90:	jp	nz,&H5B23
5D93:	ldw	$0,$27
5D96:	sbw	$0,$sy
5D98:	sbcw	$19,$sz
5D9A:	jr	nz,&H5D72
5D9C:	jp	&H5BA3
5D9F:	sbc	$24,&H08
5DA2:	jr	nz,&H5D9C
5DA4:	jr	&H5D72
5DA6:	adc	$22,$sx
5DA8:	jr	nz,&H5D70
5DAA:	cal	&H595C
5DAD:	jr	c,&H5DB6
5DAF:	anc	$29,$sy
5DB1:	jr	nz,&H5D67
5DB3:	sbw	$17,$sy,jr &H5D6E
5DB6:	sbc	$29,&H04
5DB9:	jr	z,&H5D81
5DBB:	anc	$29,$sy
5DBD:	jr	nz,&H5D9F
5DBF:	sbc	$24,&H08
5DC2:	jr	z,&H5D9C
5DC4:	jp	&H5B44

; MEMO editor, key code &H1F (down)
5DC7:	cal	&H0397		;conditionally set the key repeat flag
5DCA:	pre	ix,&H1000
5DCE:	ldd	$0,(ix+$22)
5DD1:	adc	(ix+&H1F),$31
5DD4:	jr	nz,&H5DE2
5DD6:	cal	&H593D
5DD9:	jr	nc,&H5D67
5DDB:	sbc	$29,&H04
5DDE:	jr	z,&H5D81
5DE0:	jr	&H5D9C
5DE2:	ad	$22,&H20
5DE5:	sbc	$29,&H04
5DE8:	jr	z,&H5D72
5DEA:	ld	$23,$22
5DED:	jp	&H5B9B

; MEMO editor, key code &H1E (up)
5DF0:	cal	&H0397		;conditionally set the key repeat flag
5DF3:	adc	$22,$sx
5DF5:	jr	nz,&H5E18
5DF7:	cal	&H595C
5DFA:	jr	c,&H5DDB
5DFC:	gre	iz,$19
5DFE:	cal	&H5C37
5E01:	pre	ix,&H1000
5E05:	ld	$22,&HDF
5E08:	adc	(ix+$22),$31
5E0B:	jr	nz,&H5E12
5E0D:	sb	$22,&H20
5E10:	jr	nc,&H5E08
5E12:	an	$22,&HE0
5E15:	sbw	$17,$sy,jr &H5DE2
5E18:	sb	$22,&H20,jr &H5DE5

; MEMO editor, key code &H10 ([S]+up)
5E1C:	sbw	$22,$22
5E1F:	pre	iz,$25
5E21:	gre	iz,$19
5E23:	ldw	$17,$sy
5E25:	cal	&H5C37
5E28:	jr	&H5DE5

; MEMO editor, key code &H01 ([S]+down)
5E2A:	anc	$29,$sy
5E2C:	jr	nz,&H5E44
5E2E:	cal	&H59C0
5E31:	ldw	$17,$15
5E34:	sbcw	$17,$sy
5E36:	jr	z,&H5E54
5E38:	cal	&H5A0B
5E3B:	jr	z,&H5E4B
5E3D:	sbw	$17,$sy
5E3F:	cal	&H5999
5E42:	jr	&H5E54
5E44:	cal	&H593D
5E47:	gre	iz,$19
5E49:	jr	nc,&H5E44
5E4B:	cal	&H595C
5E4E:	anc	$29,$sy
5E50:	jr	nz,&H5E54
5E52:	sbw	$17,$sy
5E54:	sbw	$22,$22
5E57:	gre	iz,$19
5E59:	jr	&H5E25

5E5B:	anc	$29,$sy
5E5D:	rtn	nz
5E5E:	sbc	$29,&H04
5E61:	rtn	z
5E62:	sbc	$24,$sy
5E64:	rtn	nz
5E65:	cal	&H593D
5E68:	cal	&H5A0B
5E6B:	rtn	z
5E6C:	ppsw	$0
5E6E:	cal	&H036A		;get a character from keyboard buffer to $0
5E71:	cal	&H5C30
5E74:	cal	&H5C37
5E77:	cal	&H5D18
5E7A:	jr	&H5E85

; MEMO editor,
; key codes &H02 (line top), &H06 (line end), &H1C (right), &H1D (left)
5E7C:	sbc	$29,&H04
5E7F:	jp	z,&H2002
5E82:	cal	&H0397		;conditionally set the key repeat flag
5E85:	cal	&H9338
5E88:	ld	$0,$sx
5E8A:	cal	&H5CC9
5E8D:	ld	$10,$sx
5E8F:	ld	$11,$13
5E92:	sbc	$11,&H7F
5E95:	jr	c,&H5E9A
5E97:	ld	$11,&H7F
5E9A:	cal	&H977F
5E9D:	ld	$0,$22
5EA0:	pre	ix,&H1BE0
5EA4:	adc	(ix+$sx),$31
5EA6:	jr	z,&H5EAC
5EA8:	std	$31,(ix+$sx)
5EAA:	ld	$0,(ix-$sy)
5EAC:	ld	$1,$22
5EAF:	anc	$29,$sy
5EB1:	jr	nz,&H5ED4
5EB3:	sbc	$1,&HC0
5EB6:	jr	c,&H5EBB
5EB8:	ld	$1,&HA0
5EBB:	pre	ix,&H1101
5EBF:	stw	$0,(ix+$sx)
5EC1:	cal	&H031B		;cursor display enable
5EC4:	ld	$24,&H08
5EC7:	anc	$29,$sy
5EC9:	jr	nz,&H5ECE
5ECB:	ld	$24,&H02
5ECE:	cal	&H9614
5ED1:	jp	&H5BA3
5ED4:	sbc	$1,&HA0
5ED7:	jr	c,&H5EBB
5ED9:	ld	$1,&H80,jr &H5EBB

; MEMO editor, key codes &H05 (line del), &H0C (CLS)
5EDD:	cal	&H5C26
5EE0:	sbc	$29,&H04
5EE3:	jr	z,&H5F2C
5EE5:	cal	&H5E5B
5EE8:	cal	&H2AE3		;display character $16
5EEB:	anc	$29,$sy
5EED:	jr	nz,&H5EF6
5EEF:	cal	&H593D
5EF2:	adw	$17,$sy
5EF4:	gre	iz,$19
5EF6:	jp	&H5B4C
5EF9:	sbc	$16,&HE0
5EFC:	jr	c,&H5F26
5EFE:	sbc	$16,&HEE
5F01:	jp	z,&H605C
5F04:	sbc	$16,&HEF
5F07:	jp	z,&H605C
5F0A:	jp	nc,&H249D
5F0D:	sbc	$16,&HE9
5F10:	jp	z,&H5F9E
5F13:	sbc	$16,&HE2
5F16:	jp	z,&H5FA9
5F19:	sbc	$16,&HE7
5F1C:	jr	z,&H5F93
5F1E:	sbc	$16,&HE6
5F21:	jr	z,&H5F3A
5F23:	jp	&H2002
5F26:	cal	&H5C26
5F29:	cal	&H2AE3		;display character $16
5F2C:	cal	&H031B		;cursor display enable
5F2F:	cal	&H9774
5F32:	jp	&H2449
5F35:	cal	&H5C26
5F38:	jr	&H5F2C
5F3A:	pre	ix,&H1000
5F3E:	pre	iy,&H10FF
5F42:	pre	iz,&H18D3
5F46:	bup
5F47:	cal	&H593D
5F4A:	jr	nc,&H5F56
5F4C:	anc	$29,$sy
5F4E:	jp	nz,&H5B23
5F51:	sbc	$29,&H04
5F54:	jr	z,&H5F35
5F56:	adw	$17,$sy
5F58:	gre	iz,$19
5F5A:	sbc	$29,&H04
5F5D:	jp	nz,&H5B7F
5F60:	ld	$22,$sx
5F62:	jp	&H5D78
5F65:	cal	&H5FBF
5F68:	cal	&H22F2
5F6B:	sbc	$24,&H04
5F6E:	jr	nz,&H5F75
5F70:	cal	&H2ADB
5F73:	jr	&H5F90
5F75:	cal	&H95D3
5F78:	jr	&H5F90
5F7A:	cal	&H5C26
5F7D:	cal	&H5E5B
5F80:	ld	$0,$16
5F83:	cal	&H2143
5F86:	sbc	$29,&H04
5F89:	jr	z,&H5F2C
5F8B:	sbc	$24,$sy
5F8D:	jp	z,&H5EEB
5F90:	jp	&H5BA3
5F93:	cal	&H5C26
5F96:	cal	&H5E5B
5F99:	cal	&H2354
5F9C:	jr	&H5F86
5F9E:	cal	&H5C26
5FA1:	cal	&H5E5B
5FA4:	cal	&H21AA
5FA7:	jr	&H5F86
5FA9:	cal	&H5C26
5FAC:	cal	&H5E5B
5FAF:	cal	&H21A7
5FB2:	jr	&H5F86
5FB4:	cal	&H5C26
5FB7:	cal	&H5E5B
5FBA:	cal	&H7BDD
5FBD:	jr	&H5F86
5FBF:	pre	ix,&H1103
5FC3:	ldw	$0,&H00FF
5FC7:	stm	$31,(ix+$sx),3
5FCA:	jp	&H975E
5FCD:	anc	$24,$sy
5FCF:	jr	nz,&H5FD8
5FD1:	cal	&H5FBF
5FD4:	sbc	$1,$sy
5FD6:	jr	nc,&H5FDE
5FD8:	jp	&H5DA6
5FDB:	cal	&H5FBF
5FDE:	anc	$29,$sy
5FE0:	jr	nz,&H601E
5FE2:	pre	ix,&H19D5
5FE6:	sbw	$0,$sz
5FE8:	ldi	$2,(iz+$sx)
5FEA:	adc	$2,$sx
5FEC:	jr	z,&H5FF7
5FEE:	sti	$2,(ix+$sx)
5FF0:	ad	$0,$sy
5FF2:	jr	nc,&H5FE8
5FF4:	jp	&H2B7C
5FF7:	adc	$0,$sx
5FF9:	jr	z,&H603D
5FFB:	ldw	$2,&H0A0D
5FFF:	stw	$2,(ix+$sx)
6001:	adw	$0,$sy
6003:	adw	$0,$sy
6005:	sbc	$24,&H08
6008:	jr	nz,&H6043
600A:	ldw	$2,$19
600D:	cal	&H34B1		;expand a memory block in a RAM file
6010:	ldw	$4,$sz
6012:	ldw	$0,$2
6015:	ldw	$2,&H19D5
6019:	cal	&H00F9
601C:	jr	&H6046
601E:	adc	(iz+$sx),$31
6020:	jr	z,&H6056
6022:	phs	$23
6024:	cal	&H1D07
6027:	pps	$23
6029:	adc	$15,$sx
602B:	jp	z,&H2BAC
602E:	cal	&H3441
6031:	pre	iz,$19
6033:	adc	(iz+$sx),$31
6035:	jr	nz,&H6056
6037:	cal	&H595C
603A:	gre	iz,$19,jr &H6056
603D:	sbc	$24,&H08
6040:	jp	z,&H5B7F
6043:	cal	&H5905
6046:	pre	iz,$19
6048:	cal	&H5A18
604B:	jr	nz,&H6056
604D:	cal	&H595C
6050:	jr	c,&H6056
6052:	sbw	$17,$sy
6054:	gre	iz,$19
6056:	jp	&H5B88
6059:	ad	$23,$sy,jr &H6072
605C:	anc	$29,$sy
605E:	cal	z,&H5C3A
6061:	pre	ix,&H1BE2
6065:	ldm	$0,(ix+$sx),8
6068:	pre	iz,$19
606A:	ldw	$9,&H2C20
606E:	ldw	$11,&H0D1A
6072:	sbc	(iz+$23),$11
6075:	jr	z,&H60D3
6077:	pre	ix,&H168E
607B:	sbcw	(ix+$sx),$30
607D:	jr	c,&H6087
607F:	sbcw	(ix+$sx),$17
6081:	jr	z,&H60F6
6083:	jr	c,&H60F6
6085:	jr	&H60D3
6087:	sbc	(iz+$23),$9
608A:	jr	z,&H6059
608C:	sbc	(iz+$23),$10
608F:	jr	z,&H6059
6091:	sbc	(iz+$23),$12
6094:	jr	z,&H60D3
6096:	ldm	$9,(iz+$23),8
6099:	ld	$8,$21
609C:	sbc	$8,$sy
609E:	jr	c,&H60E5
60A0:	cal	&H9F25
60A3:	jr	nz,&H60CC
60A5:	sbc	$21,&H09
60A8:	jr	c,&H60E5
60AA:	phs	$23
60AC:	ad	$23,&H08
60AF:	ldm	$9,(iz+$23),8
60B2:	phsm	$7,8
60B5:	pre	ix,&H1BEA
60B9:	ldm	$0,(ix+$sx),8
60BC:	ld	$8,$21
60BF:	sb	$8,&H08
60C2:	cal	&H9F25
60C5:	ppsm	$0,8
60C8:	pps	$23
60CA:	jr	z,&H60E5
60CC:	ad	$23,$sy
60CE:	cal	&H6203
60D1:	jr	&H6072
60D3:	cal	&H29C5		;test the power switch and BRK key
60D6:	cal	&H593D
60D9:	jr	c,&H610B
60DB:	gre	iz,$19
60DD:	sbw	$22,$22
60E0:	adw	$17,$sy
60E2:	jp	&H605C
60E5:	ld	$22,$23
60E8:	an	$22,&HE0
60EB:	cal	&H6220
60EE:	cal	&H59DF
60F1:	ad	$23,$sy
60F3:	cal	&H6203
60F6:	sbc	$29,&H04
60F9:	jp	z,&H2002
60FC:	cal	&H5C3A
60FF:	pre	ix,&H168E
6103:	sbcw	(ix+$sx),$30
6105:	jp	nc,&H5B9B
6108:	jp	&H5B9E
610B:	sbc	$29,&H04
610E:	jp	z,&H5F35
6111:	jp	&H5B23
6114:	anc	$1,&H08
6117:	rtn	z
6118:	ldw	$0,&H175C
611C:	ld	$1,($sz)
611E:	anc	$1,$sy
6120:	rtn	nz
6121:	st	$1,(ix+$sx)
6123:	rtn
6124:	sbc	$29,&H06
6127:	jp	nz,&H5BA3
612A:	ld	$0,$sx
612C:	pre	ix,&H168E
6130:	stw	$31,(ix+$sx)
6132:	cal	&H0310
6135:	jr	z,&H619A
6137:	cal	&H5AA9
613A:	cal	&H975E
613D:	pre	ix,&H123A
6141:	sbc	(ix+$sx),$31
6143:	jp	nz,&H2B7C
6146:	cal	&H61A0
6149:	jr	&H619A
614B:	pst	ua,&H54
614E:	cal	&H296A
6151:	jr	nz,&H6175
6153:	cal	&H2972
6156:	jr	nz,&H619D
6158:	cal	&H6114
615B:	jr	nz,&H619D
615D:	sbc	(ix+$sy),$31
615F:	jr	nz,&H619D
6161:	cal	&H28BC
6164:	cal	&H277E
6167:	cal	&H529B		;PR Error if password set
616A:	pre	ix,&H168E
616E:	sbw	$0,$sz
6170:	stw	$0,(ix+$sx)
6172:	cal	&H29AA
6175:	ld	$4,&H24
6178:	cal	&H5AA4
617B:	cal	&H0323
617E:	ldw	$2,&H5F35
6182:	cal	&H297A		;BRSTR, set ACJMP
6185:	pre	ix,&H16C4
6189:	ld	$29,&H04
618C:	sti	$29,(ix+$sx)
618E:	st	$31,(ix+$sy)
6190:	cal	&H9774
6193:	cal	&H0310
6196:	jr	nz,&H613A
6198:	ld	$21,$sx
619A:	jp	&H605C
619D:	jp	&H2002
61A0:	pre	ix,&H168E
61A4:	sbw	$0,$sz
61A6:	stw	$0,(ix+$sx)
61A8:	ldd	$0,(iz+$sx)
61AA:	sbc	$0,&H2A
61AD:	jr	nz,&H61DF
61AF:	ldw	$0,&H16C5
61B3:	ld	$0,($sz)
61B5:	anc	$0,&H0C
61B8:	jr	z,&H61DF
61BA:	ldd	$0,(iz+$sy)
61BC:	phsw	$18
61BE:	cal	&H1EE6
61C1:	jr	c,&H61CA
61C3:	sbc	$0,$sx
61C5:	jp	nz,&H2B70	;SN Error, syntax
61C8:	sbc	$17,$sy
61CA:	jp	c,&H2BA4	;BS Error, subscript out of range
61CD:	stw	$17,(ix+$sx)
61CF:	pre	ix,&H1BE2
61D3:	sbbm	$0,$sz,8
61D6:	stim	$0,(ix+$sx),8
61D9:	stm	$0,(ix+$sx),8
61DC:	ppsw	$17
61DE:	rtn
61DF:	pre	ix,&H1BE2
61E3:	ldim	$0,(iz+$sx),8
61E6:	stim	$0,(ix+$sx),8
61E9:	ldm	$0,(iz+$sx),8
61EC:	stm	$0,(ix+$sx),8
61EF:	ldd	$21,(iz-&H08)
61F2:	ld	$21,$sx
61F4:	ld	$1,&H10
61F7:	ldi	$0,(iz+$sx)
61F9:	adc	$0,$sx
61FB:	rtn	z
61FC:	ad	$21,$sy
61FE:	sb	$1,$sy
6200:	jr	nz,&H61F7
6202:	rtn
6203:	pre	iz,$19
6205:	ldw	$9,&H2C20
6209:	ldw	$11,&H0D1A
620D:	sbc	(iz+$23),$9
6210:	rtn	z
6211:	sbc	(iz+$23),$10
6214:	rtn	z
6215:	sbc	(iz+$23),$11
6218:	rtn	z
6219:	sbc	(iz+$23),$12
621C:	rtn	z
621D:	ad	$23,$sy,jr &H620D
6220:	cal	&H9338
6223:	pre	ix,&H1109
6227:	ldd	$0,(ix+$sx)
6229:	bid	$0
622B:	jr	c,&H6259
622D:	ldw	$12,&H8080
6231:	ld	$11,&H7F
6234:	ld	$10,$sx
6236:	pre	iz,$19
6238:	ldd	$0,(iz+$22)
623B:	pre	ix,&H113B
623F:	ldw	$0,&H0A0D
6243:	ldi	$5,(iz+$sx)
6245:	sbc	$5,$sz
6247:	jr	nz,&H6261
6249:	cal	&H0B88
624C:	cal	&H5A18
624F:	jr	z,&H6256
6251:	cal	&H5CB4
6254:	jr	nc,&H6243
6256:	jp	&H5CA3
6259:	ldw	$12,&HA0A0
625D:	ld	$11,&H5F,jr &H6234
6261:	sbc	$5,&H1A
6264:	jr	z,&H6256
6266:	sti	$5,(ix+$sx)
6268:	ad	$13,$sy,jr &H6254
626B:	pre	ss,&H1BD7
626F:	ld	$2,$sx
6271:	cal	&H6686
6274:	pre	ix,&H16B4
6278:	std	$31,(ix+$sx)
627A:	ldw	$17,&H181E
627E:	cal	&H8314		;is the size of the internal RAM 8kB or 32kB?
6281:	jr	c,&H6287	;skip if 8kB
6283:	ldw	$17,&H185B
6287:	cal	&H653D
628A:	cal	&H655F		;wait for a key, convert to upper case
628D:	sbc	$0,&H31
6290:	jr	c,&H628A
6292:	jp	z,&H6426
6295:	sbc	$0,&H33
6298:	jp	c,&H6426
629B:	jr	nz,&H628A
629D:	cal	&H8314		;is the size of the internal RAM 8kB or 32kB?
62A0:	jr	nc,&H628A	;branch if 32kB
62A2:	ldw	$17,&H2645
62A6:	cal	&H653D
62A9:	cal	&H2930
62AC:	ld	$1,&H10
62AF:	std	$1,(ix+$sx)
62B1:	cal	&H8B2E
62B4:	pre	ix,&H1558
62B8:	sbc	(ix-$sy),$31
62BA:	jr	z,&H62C0
62BC:	std	$31,(ix-$sy)
62BE:	jr	&H62B4
62C0:	sbc	(ix+$sy),$31
62C2:	cal	nz,&H8593
62C5:	pre	ix,&H1558
62C9:	sbc	(ix-$sy),$31
62CB:	jr	nz,&H62BC
62CD:	sbc	(ix+$sy),$31
62CF:	jr	z,&H62DC
62D1:	cal	&H8593
62D4:	cal	&H8590
62D7:	cal	&H8590
62DA:	jr	&H62B4
62DC:	ld	$16,&H0D
62DF:	cal	&H85C8
62E2:	cal	&H017C		;one-minute timer and ON interrupt disable
62E5:	cal	&H8590
62E8:	sbc	$0,&H0D
62EB:	jr	nz,&H62F2
62ED:	cal	&H2AE8		;OUTCR, display CR-LF
62F0:	jr	&H62E2
62F2:	sbc	$0,&H1A
62F5:	jp	z,&H6398
62F8:	sbc	$0,&H1B
62FB:	jr	z,&H636E
62FD:	sbc	$0,&H20
6300:	jr	nc,&H6361
6302:	pre	ix,&H110F
6306:	ld	$0,(ix+$sy)
6308:	std	$0,(ix+$sx)
630A:	cal	&H0171		;one-minute timer and ON interrupt enable
630D:	cal	&H03F3
6310:	ld	$3,&H03		;counter
6313:	ld	$0,&H41		;data for the IA register
6316:	cal	&H0381		;select KO column $0, read KI to $1,$2
6319:	sbc	$1,$sx
631B:	jr	z,&H632A
631D:	sb	$3,$sy
631F:	jr	nz,&H6313
6321:	cal	&H017C		;one-minute timer and ON interrupt disable
6324:	ld	$1,&H80
6327:	jp	&H29E3
632A:	pre	ix,&H1558
632E:	sbc	(ix-$sy),$31
6330:	jr	nz,&H6368
6332:	sbc	(ix+$sy),$31
6334:	jr	nz,&H62E2
6336:	pre	ix,&H111B
633A:	sbc	(ix+$sx),$31
633C:	jr	z,&H630A
633E:	cal	&H017C		;one-minute timer and ON interrupt disable
6341:	cal	&H036C
6344:	ld	$16,$sz
6346:	sbc	$16,&HE0
6349:	jr	nc,&H6302
634B:	cal	&H198F
634E:	jr	c,&H6302
6350:	cal	&H85C8
6353:	ld	$16,&H0D
6356:	cal	&H85C8
6359:	ld	$16,&H0A
635C:	cal	&H85C8
635F:	jr	&H62E2
6361:	ld	$16,$sz
6363:	cal	&H2AF1		;display character $16
6366:	jr	&H635F
6368:	cal	&H017C		;one-minute timer and ON interrupt disable
636B:	jp	&H85E7
636E:	pre	ix,&H1101
6372:	ld	$0,(ix+$sx)
6374:	ld	$1,$sz
6376:	cal	&H6851
6379:	cal	&H0317		;respect the cursor movement range setting
637C:	cal	&H2002
637F:	cal	&H0328		;ignore the cursor movement range setting
6382:	cal	&H63FC
6385:	cal	&H640F
6388:	ldi	$16,(iz+$sx)
638A:	sbc	$16,$sx
638C:	jr	z,&H6393
638E:	cal	&H85C8
6391:	jr	&H6388
6393:	cal	&H95D3
6396:	jr	&H6353
6398:	ldw	$17,&H2655
639C:	cal	&H6520		;display a string from bank 2
639F:	pre	ix,&H1101
63A3:	ld	$0,(ix+$sx)
63A5:	ld	$1,$sz
63A7:	cal	&H6851
63AA:	cal	&H0317		;respect the cursor movement range setting
63AD:	cal	&H2002
63B0:	cal	&H63FC
63B3:	cal	&H640F
63B6:	cal	&H0328		;ignore the cursor movement range setting
63B9:	ldi	$0,(iz+$sx)
63BB:	cal	&H002B		;OKNM1, is $0 a digit?
63BE:	ld	$17,$sz
63C0:	jr	nc,&H63F1
63C2:	cal	&H003C		;ENDSC, test for an end of a BASIC line
63C5:	jr	nc,&H63F1
63C7:	cal	&H95D3
63CA:	cal	&H529B		;PR Error if password set
63CD:	ld	$14,$17
63D0:	an	$14,&H0F
63D3:	cal	&H3425
63D6:	sbw	$27,$25
63D9:	pre	iz,$25,jr &H63DF
63DC:	cal	&H85C8
63DF:	ldi	$16,(iz+$sx)
63E1:	sbw	$27,$sy
63E3:	jr	nz,&H63DC
63E5:	ld	$16,&H0D
63E8:	cal	&H85C8
63EB:	cal	&H8590
63EE:	jp	&H62DC
63F1:	cal	&H95D3
63F4:	ld	$16,&H0D
63F7:	cal	&H85C8
63FA:	jr	&H63EE
63FC:	cal	&H974D
63FF:	pre	iz,&H1106
6403:	ldd	$0,(iz+$sx)
6405:	pre	iz,&H113B
6409:	ldd	$1,(iz+$sz)
640B:	rtn
640C:	cal	&H8593
640F:	pre	ix,&H1558
6413:	sbc	(ix-$sy),$31
6415:	jp	nz,&H85E7
6418:	sbc	(ix+$sy),$31
641A:	jr	nz,&H640C
641C:	rtn
641D:	pre	ix,&H16D1
6421:	ldd	$1,(ix+$sx)
6423:	anc	$1,$sy
6425:	rtn
6426:	pre	ix,&H16D1
642A:	std	$0,(ix+$sx)
642C:	jr	&H644A
642E:	cal	&H6570
6431:	jr	&H644A
6433:	ldw	$17,&H1A0C
6437:	anc	$2,$sy
6439:	jr	z,&H643F
643B:	ldw	$17,&H1C7B
643F:	cal	&H6500
6442:	jr	&H644A
6444:	pre	ix,&H16B4
6448:	ad	(ix+$sx),$30
644A:	pre	ss,&H1BD7
644E:	cal	&H6680
6451:	ldw	$2,&H644A
6455:	cal	&H66B3
6458:	ldw	$17,&H18E1
645C:	cal	&H641D
645F:	jr	nz,&H6465
6461:	ldw	$17,&H1B4B
6465:	pre	ix,&H16B4
6469:	ldd	$0,(ix+$sx)
646B:	anc	$0,$sy
646D:	jr	z,&H647B
646F:	ldw	$17,&H1888
6473:	anc	$1,$sy
6475:	jr	nz,&H647B
6477:	ldw	$17,&H1AEF
647B:	cal	&H653D
647E:	pre	ss,&H1BD7
6482:	cal	&H655F		;wait for a key, convert to upper case
6485:	ldw	$20,&H69BB
6489:	ldw	$25,&H1ED8
648D:	ld	$22,&H06
6490:	ldw	$17,&H1A39
6494:	cal	&H641D
6497:	jr	nz,&H64A8
6499:	ldw	$20,&H69C7
649D:	ldw	$25,&H1F20
64A1:	ld	$22,&H0F
64A4:	ldw	$17,&H1CA9
64A8:	anc	$1,$sy
64AA:	jr	z,&H64B2
64AC:	sbc	$0,&H54
64AF:	jp	z,&H6874
64B2:	sbc	$0,&H50
64B5:	jp	z,&H642E
64B8:	ldw	$25,&H1FD4
64BC:	anc	$1,$sy
64BE:	jr	nz,&H64C4
64C0:	ldw	$25,&H1FE0
64C4:	sbc	$0,&H4C
64C7:	jr	z,&H64B5
64C9:	anc	$1,$sy
64CB:	ldw	$1,$sy
64CD:	jr	nz,&H64D3
64CF:	ldw	$1,&H0101
64D3:	sbc	$0,&H49
64D6:	jr	z,&H64FA
64D8:	sbc	$0,&H46
64DB:	jp	z,&H6444
64DE:	anc	$2,$sy
64E0:	jr	z,&H64EE
64E2:	sbc	$0,&H58
64E5:	jp	z,&H6914
64E8:	sbc	$0,&H59
64EB:	jp	z,&H6959
64EE:	sb	$0,&H43
64F1:	jp	z,&H6433
64F4:	ld	$1,$sx
64F6:	sbc	$0,$sy
64F8:	jr	nz,&H647E
64FA:	cal	&H66C8
64FD:	jp	&H644A
6500:	cal	&H653D
6503:	cal	&H655F		;wait for a key, convert to upper case
6506:	sbc	$0,&H0D
6509:	jr	z,&H650F
650B:	sbc	$0,&H59		;'Y'
650E:	rtn	nz
650F:	jp	&H432F
6512:	anc	$1,$sy
6514:	jr	z,&H6519
6516:	or	$0,&H02
6519:	ad	$0,$sz
651B:	pst	ua,&HA4
651E:	ldw	$17,(ix+$sz)
; display a string from bank 2, pointed to by $17,$18, terminated by &H01
6520:	gre	iz,$0
6522:	pre	iz,$17,jr &H652C
6525:	phsw	$1
6527:	cal	&H2AF1		;display character $16
652A:	ppsw	$0
652C:	pst	ua,&HA4
652F:	ldi	$16,(iz+$sx)
6531:	pst	ua,&H54
6534:	sbc	$16,$sy
6536:	jr	nz,&H6525
6538:	gre	iz,$17
653A:	pre	iz,$0
653C:	rtn

653D:	cal	&H6549
6540:	cal	&H6520		;display a string from bank 2
6543:	cal	&H2991		;select the LCD as the output device
6546:	jp	&H92F5

6549:	cal	&H298D
654C:	jp	&H2ADF

654F:	cal	&H6549
6552:	ldw	$17,&H16DD	;string "Break point"
6556:	cal	&H6520		;display a string from bank 2
6559:	cal	&H7B94		;display the PC value and an optional label
655C:	cal	&H6543
655F:	cal	&H032E		;cursor display disable
6562:	cal	&H23C8
6565:	cal	&H00B6		;TCAPS, lower to upper case conversion
6568:	phs	$0
656A:	cal	&H031B		;cursor display enable
656D:	pps	$0
656F:	rtn

6570:	sbw	$23,$23
6573:	sbc	$0,&H4C
6576:	jr	z,&H6597
6578:	cal	&H653D
657B:	cal	&H2989		;select the printer as the output device
657E:	cal	&H2AE8		;OUTCR, display CR-LF
6581:	ldw	$17,$25
6584:	cal	&H6520		;display a string from bank 2
6587:	cal	&H664E
658A:	cal	&H2AE8		;OUTCR, display CR-LF
658D:	ad	$24,$sy
658F:	sbc	$24,$22
6592:	jr	nz,&H6584
6594:	jp	&H2991		;select the LCD as the output device

6597:	sbw	$23,$23
659A:	sb	$22,&H04
659D:	ld	$24,$23
65A0:	cal	&H6549
65A3:	pre	ix,$25
65A5:	pst	ua,&HA4
65A8:	cal	&H6625
65AB:	ldw	$17,$2
65AE:	cal	&H9238		;English or Japanese version?
65B1:	jr	nz,&H65BA	;skip if Japanese
65B3:	ldw	$2,&H000F
65B7:	adw	$17,$2
65BA:	cal	&H6520		;display a string from bank 2
65BD:	cal	&H664E
65C0:	ld	$0,$24
65C3:	sb	$0,$23
65C6:	sbc	$0,&H03
65C9:	jr	z,&H65D1
65CB:	cal	&H2AE8		;OUTCR, display CR-LF
65CE:	ad	$24,$sy,jr &H65A3
65D1:	pre	iz,&H154E
65D5:	ldm	$6,(iz+$sx),6
65D8:	sbbm	$0,$sz,6
65DB:	ldw	$0,&H0808
65DF:	ld	$3,&H3E
65E2:	stm	$0,(iz+$sx),6
65E5:	phsm	$11,6
65E8:	cal	&H6543
65EB:	ppsm	$0,6
65EE:	stm	$0,(iz+$sx),6
65F1:	cal	&H655F		;wait for a key, convert to upper case
65F4:	sbc	$0,&H0D
65F7:	jr	z,&H6616
65F9:	sbc	$0,&H1C
65FC:	jr	c,&H65F1
65FE:	sbc	$0,&H1E
6601:	rtn	c
6602:	jr	z,&H661E
6604:	sbc	$0,&H1F
6607:	jr	nz,&H65F1
6609:	sbc	$23,$22
660C:	jr	z,&H65F1
660E:	ad	$23,$sy
6610:	cal	&H0397		;conditionally set the key repeat flag
6613:	jp	&H659D
6616:	ad	$23,$sy
6618:	sbc	$22,$23
661B:	jr	nc,&H6613
661D:	rtn
661E:	sbc	$23,$sy
6620:	jr	c,&H65F1
6622:	sb	$23,$sy,jr &H6610
6625:	ld	$0,$24
6628:	ad	$0,$sz
662A:	ldw	$2,(ix+$sz)
662C:	pst	ua,&H54
662F:	rtn
6630:	cal	&H2CEF
6633:	ldw	$16,$8
6636:	cal	&H2AF1		;display character $16
6639:	bydw	$17
663B:	cal	&H2AF1		;display character $16
663E:	jp	&H2D2C
6641:	pre	ss,$2
6643:	cal	&H66BA		;US<-&H1CD0, UA<-&H54
6646:	cal	&H2AD7		;display a space
6649:	cal	&H6630
664C:	jr	&H666D
664E:	phsw	$18
6650:	phsm	$26,8
6653:	gre	ss,$4
6655:	ldw	$2,&H6641
6659:	cal	&H66B3
665C:	pre	ix,$20
665E:	pst	ua,&H04
6661:	cal	&H6625
6664:	cal	&H7D81
6667:	cal	&H131F
666A:	cal	&H97D5
666D:	ppsm	$19,8
6670:	ppsw	$17
6672:	rtn
6673:	ld	$2,&H08
6676:	ld	$1,&H40,jr &H668F
667A:	ld	$2,&H04
667D:	ld	$1,$sx,jr &H668F
6680:	ld	$2,$sy,jr &H6695
6683:	ld	$2,&H02
6686:	pre	ix,&H1113
668A:	ldd	$1,(ix+$sx)
668C:	an	$1,&H40
668F:	pre	ix,&H1113
6693:	std	$1,(ix+$sx)
6695:	pst	ua,&H54
6698:	phs	$2
669A:	cal	&H277E
669D:	pps	$2
669F:	ld	$3,$sx
66A1:	ld	$1,$sx
66A3:	cal	&H2471
66A6:	cal	&H9774
66A9:	cal	&H0323
66AC:	ldw	$2,&H66C2
66B0:	cal	&H297A		;BRSTR, set ACJMP
66B3:	pre	ix,&H16BA
66B7:	stm	$2,(ix+$sx),4
66BA:	pre	us,&H1CD0
66BE:	pst	ua,&H54
66C1:	rtn
66C2:	cal	&H2991		;select the LCD as the output device
66C5:	jp	&H2446		;mode CAL

66C8:	pre	ix,&H16B5
66CC:	stw	$1,(ix+$sx)
66CE:	cal	&H6549
66D1:	pre	ix,&H16B5
66D5:	ldw	$0,(ix+$sx)
66D7:	pre	ix,&H16B4
66DB:	ldd	$2,(ix+$sx)
66DD:	anc	$2,$sy
66DF:	jr	z,&H66E4
66E1:	or	$0,&H04
66E4:	pre	ix,&H1FFE
66E8:	cal	&H6512
66EB:	phsw	$18
66ED:	ldw	$17,&H200E
66F1:	cal	&H6520		;display a string from bank 2
66F4:	ld	$16,$sx
66F6:	cal	&H67A9
66F9:	ldw	$17,&H2013
66FD:	pre	ix,&H16B4
6701:	ldd	$0,(ix+$sx)
6703:	anc	$0,$sy
6705:	jr	nz,&H670B
6707:	ldw	$17,&H201E
670B:	cal	&H6520		;display a string from bank 2
670E:	ppsw	$17
6710:	cal	&H6520		;display a string from bank 2
6713:	cal	&H6543
6716:	ldw	$0,&H4D42
671A:	cal	&H67E0
671D:	rtn	z
671E:	pre	ix,&H16F1
6722:	stim	$10,(ix+$sx),8
6725:	std	$18,(ix+$sx)
6727:	sbbm	$10,$10,8
672A:	ld	$18,$sx
672C:	ldw	$0,&H5D52
6730:	pre	ix,&H16B5
6734:	sbc	(ix+$sy),$30
6736:	cal	z,&H67E0
6739:	rtn	z
673A:	pre	ix,&H16FA
673E:	stim	$10,(ix+$sx),8
6741:	std	$18,(ix+$sx)
6743:	cal	&H0669
6746:	cal	&H06B8
6749:	pre	ix,&H16B4
674D:	ldd	$0,(ix+$sx)
674F:	anc	$0,$sy
6751:	jr	z,&H6769
6753:	ldw	$0,&H6D62
6757:	cal	&H6851
675A:	ld	$16,&H31
675D:	cal	&H2AF1		;display character $16
6760:	ldw	$0,&H6D62
6764:	cal	&H67E0
6767:	jr	z,&H6753
6769:	pre	ix,&H16B5
676D:	sbc	(ix+$sx),$31
676F:	cal	z,&H05B2
6772:	gre	ss,$4
6774:	ldw	$2,&H6781
6778:	cal	&H66B3
677B:	cal	&H435D
677E:	jp	&H66CE
6781:	pre	ss,$2
6783:	cal	&H66BA		;US<-&H1CD0, UA<-&H54
6786:	ldw	$0,&H1101
678A:	st	&H40,($sz)
678D:	ldw	$17,&H2029
6791:	cal	&H6520		;display a string from bank 2
6794:	cal	&H6908
6797:	jr	&H677E
6799:	pre	ss,$2
679B:	cal	&H66BA		;US<-&H1CD0, UA<-&H54
679E:	cal	&H298D
67A1:	cal	&H2AD7		;display a space
67A4:	cal	&H6630
67A7:	jr	&H67C4
67A9:	phsw	$18
67AB:	phsm	$26,8
67AE:	gre	ss,$4
67B0:	ldw	$2,&H6799
67B4:	cal	&H66B3
67B7:	sbc	$16,$sx
67B9:	jr	z,&H67D1
67BB:	cal	&H1CAB
67BE:	cal	&H13A7
67C1:	cal	&H97D5
67C4:	ppsm	$19,8
67C7:	ppsw	$17
67C9:	ldw	$0,&H1101
67CD:	st	&H35,($sz)
67D0:	rtn
67D1:	cal	&H1BF4
67D4:	jr	&H67BE
67D6:	pre	ss,$2
67D8:	ld	$16,&H02
67DB:	cal	&H2AF1		;display character $16
67DE:	jr	&H67E6
67E0:	cal	&H6851
67E3:	cal	&H0317		;respect the cursor movement range setting
67E6:	ldw	$2,&H67D6
67EA:	gre	ss,$4
67EC:	cal	&H66B3
67EF:	cal	&H6817
67F2:	cal	&H9753		;INCLR, clear the INTOP input buffer
67F5:	cal	&H1D07
67F8:	pre	iz,&H1000
67FC:	ld	$2,$sy
67FE:	sbc	(iz+$sx),$31
6800:	jr	z,&H680A
6802:	cal	&H112F
6805:	cal	&H0093		;SN Error if not an end of a BASIC line
6808:	ld	$2,$sx
680A:	cal	&H0323
680D:	sbc	$2,$sy
680F:	rtn
6810:	ld	$0,&H43
6813:	phs	$0
6815:	jr	&H6819
6817:	phs	$31
6819:	cal	&H2002
681C:	pps	$2
681E:	pre	ix,&H1106
6822:	ldw	$0,(ix+$sx)
6824:	sbc	$2,$sx
6826:	jr	z,&H682B
6828:	ld	$0,$2
682B:	pre	ix,&H113B
682F:	pre	iz,&H165E
6833:	sb	$1,$sz
6835:	ldd	$0,(ix+$sz)
6837:	ld	$2,&H21
683A:	ldi	$0,(ix+$sx)
683C:	sbc	$0,$2
683F:	jr	c,&H6846
6841:	ld	$2,&H20
6844:	sti	$0,(iz+$sx)
6846:	sb	$1,$sy
6848:	jr	nc,&H683A
684A:	sti	$31,(iz+$sx)
684C:	pre	iz,&H165E
6850:	rtn
6851:	pre	ix,&H1101
6855:	std	$0,(ix+$sx)
6857:	ldd	$2,(ix+&H05)
685A:	stw	$0,(ix+$sx)
685C:	rtn
685D:	cal	&H6549
6860:	cal	&H6520		;display a string from bank 2
6863:	ld	$16,$sy
6865:	cal	&H67A9
6868:	cal	&H6520		;display a string from bank 2
686B:	cal	&H2991		;select the LCD as the output device
686E:	jp	&H92F5
6871:	cal	&H68E8
6874:	pre	ss,&H1BD7
6878:	ldw	$17,&H19CF
687C:	cal	&H653D
687F:	ldw	$0,&H6B62
6883:	cal	&H67E0
6886:	jp	z,&H644A
6889:	ldw	$2,&H6871
688D:	cal	&H66B3
6890:	cal	&H0054
6893:	cal	&H1C65
6896:	cal	&H006C
6899:	cal	&H05CE
689C:	cal	&H0054
689F:	cal	&H1C59
68A2:	cal	&H006C
68A5:	cal	&H0644
68A8:	cal	&H0669
68AB:	ld	$7,$sy
68AD:	cal	&H0607
68B0:	cal	&H0669
68B3:	ldw	$6,&H0105
68B7:	cal	&H05DA
68BA:	cal	&H0054
68BD:	ldw	$0,&H1101
68C1:	st	&H6C,($sz)
68C4:	ldw	$17,&H2061
68C8:	cal	&H6520		;display a string from bank 2
68CB:	cal	&H005C
68CE:	ldw	$28,&H0598
68D2:	sbc	$18,&H05
68D5:	jr	nc,&H68D9
68D7:	ld	$29,$sx
68D9:	cal	&H091B
68DC:	cal	&H13A7
68DF:	cal	&H97D5
68E2:	cal	&H6908
68E5:	jp	&H6874
68E8:	cal	&H5D57
68EB:	cal	&H2CEF
68EE:	pst	ua,&H04
68F1:	pre	ix,&H2D47
68F5:	ldm	$10,(ix+$sx),6
68F8:	pst	ua,&H54
68FB:	pre	ix,&H151C
68FF:	stm	$8,(ix+$sx),8
6902:	cal	&H5D1E
6905:	cal	&H0379		;clear the keyboard buffer
6908:	cal	&H032E		;cursor display disable
690B:	cal	&H03A4
690E:	jp	&H031B		;cursor display enable
6911:	cal	&H68E8
6914:	pre	ss,&H1BD7
6918:	ldw	$17,&H1E38
691C:	cal	&H685D
691F:	ldw	$0,&H6B62
6923:	cal	&H67E0
6926:	jp	z,&H644A
6929:	ldw	$2,&H6911
692D:	cal	&H66B3
6930:	cal	&H1CC9
6933:	cal	&H0054
6936:	ldw	$0,&H1101
693A:	st	&H6C,($sz)
693D:	ldw	$17,&H1ED0
6941:	pre	ix,&H2065
6945:	cal	&H699B
6948:	cal	&H005C
694B:	cal	&H13A7
694E:	cal	&H97D5
6951:	cal	&H6908
6954:	jr	&H6914
6956:	cal	&H68E8
6959:	pre	ss,&H1BD7
695D:	ldw	$17,&H1E84
6961:	cal	&H685D
6964:	ldw	$0,&H6B62
6968:	cal	&H67E0
696B:	jp	z,&H644A
696E:	ldw	$2,&H6956
6972:	cal	&H66B3
6975:	cal	&H1CE1
6978:	cal	&H0054
697B:	ldw	$0,&H1101
697F:	st	&H6C,($sz)
6982:	ldw	$17,&H1ED4
6986:	pre	ix,&H206B
698A:	cal	&H699B
698D:	cal	&H005C
6990:	cal	&H13A7
6993:	cal	&H97D5
6996:	cal	&H6908
6999:	jr	&H6959
699B:	pre	iz,&H154E
699F:	ldm	$0,(iz+$sx),6
69A2:	phsm	$5,6
69A5:	pst	ua,&HA4
69A8:	ldm	$0,(ix+$sx),6
69AB:	pst	ua,&H54
69AE:	stm	$0,(iz+$sx),6
69B1:	cal	&H6520		;display a string from bank 2
69B4:	ppsm	$0,6
69B7:	stm	$0,(iz+$sx),6
69BA:	rtn

69BB:	1BF4, 1BF8, 1C00, 1C65
69C3:	1C59, 1C3F, 1BF4, 1BF8
69CB:	1BFC, 1C00, 1C04, 1C08
69D3:	1C65, 1C6A, 1C59, 1C5F
69DB:	1C3F, 1C43, 1C9B, 1CA6
69E3:	1CAB

69E5:	43, 8E9E	;"Copy"
69E8:	44, 6A21	;"Device"
69EB:	45, 6C7F	;"Edit"
69EE:	4C, 6BD4	;"Load"
69F1:	4D, 6BE9	;"Merge"
69F4:	4E, 6B34	;"New"
69F7:	50, 6B6D	;"Print"
69FA:	53, 6BDD	;"Save"
69FD:	00, 6A61

6A00:	0D, 6A4F
6A03:	44, 6A43
6A06:	4D, 6A46
6A09:	52, 6A40
6A0C:	53, 6CD7
6A0F:	00, 6A61

6A12:	0D, 6A4F
6A15:	4D, 6A46
6A18:	52, 6A40
6A1B:	53, 6CD7
6A1E:	00, 6A61

; F.COM menu "Device"
6A21:	ldw	$17,&H20AD	;string ">RS232C / MT / Disk / Switch"
6A25:	cal	&H8314		;is the size of the internal RAM 8kB or 32kB?
6A28:	jr	c,&H6A2E	;skip if 8kB
6A2A:	ldw	$17,&H20CA	;string ">RS232C / MT / Switch"
6A2E:	cal	&H6ACB
6A31:	ldw	$17,&H6A00
6A35:	cal	&H8314		;is the size of the internal RAM 8kB or 32kB?
6A38:	jr	c,&H6A61	;skip if 8kB
6A3A:	ldw	$17,&H6A12
6A3E:	jr	&H6A61
6A40:	ld	$1,$sx,jr &H6A49
6A43:	ld	$1,$sy,jr &H6A49
6A46:	ld	$1,&H02
6A49:	pre	ix,&H16B7
6A4D:	std	$1,(ix+$sx)
6A4F:	pre	ss,&H1BD7
6A53:	cal	&H6683
6A56:	ldw	$17,&H2071	;">Save / Load / Merge / Copy", &H0D
				;"   Edit / New  / Print / Device"
6A5A:	cal	&H6ACB
6A5D:	ldw	$17,&H69E5
6A61:	phsw	$18
6A63:	cal	&H655F		;wait for a key, convert to upper case
6A66:	ppsw	$17
6A68:	sbc	$0,&H10
6A6B:	jr	uz,&H6A74
6A6D:	pre	ix,$17
6A6F:	ld	$16,$sz
6A71:	jp	&H0166		;execute a procedure from the table
6A74:	sbc	$0,&H1C
6A77:	jr	c,&H6A61
6A79:	phsw	$18
6A7B:	pre	ix,&H16B8
6A7F:	ldw	$16,(ix+$sx)
6A81:	ldw	$18,$16
6A84:	jr	z,&H6AC2
6A86:	sbc	$0,&H1E
6A89:	jr	nc,&H6A95
6A8B:	sbb	$19,$sy
6A8D:	anc	$19,&HF0
6A90:	jr	z,&H6AA0
6A92:	an	$19,&H0F
6A95:	ld	$18,&H50
6A98:	sbc	$16,&H50
6A9B:	jr	nz,&H6AA0
6A9D:	ld	$18,&H46
6AA0:	stw	$18,(ix+$sx)
6AA2:	cal	&H6AF2
6AA5:	ldw	$16,$18
6AA8:	ld	$0,&H40
6AAB:	cal	&H6AC5
6AAE:	ld	$0,&H41
6AB1:	ld	$16,$17
6AB4:	or	$16,&H30
6AB7:	cal	&H6AC5
6ABA:	cal	&H0397		;conditionally set the key repeat flag
6ABD:	cal	&H6ADC
6AC0:	jr	&H6A63
6AC2:	adb	$19,$sy,jr &H6A8D
6AC5:	cal	&H01F7
6AC8:	jp	&H0336
6ACB:	phsw	$18
6ACD:	cal	&H6B07
6AD0:	ppsw	$17
6AD2:	cal	&H6520		;display a string from bank 2
6AD5:	ldw	$10,&H7F00
6AD9:	cal	&H977F
6ADC:	cal	&H6B5A
6ADF:	pre	ix,&H16B8
6AE3:	ldw	$16,(ix+$sx)
6AE5:	cal	&H6AF2
6AE8:	cal	&H2991		;select the LCD as the output device
6AEB:	jp	&H930F
6AEE:	or	$28,&H20,jr &H6AFD
6AF2:	ld	$28,$17
6AF5:	sbc	$16,&H50
6AF8:	jr	z,&H6AFD
6AFA:	or	$28,&H10
6AFD:	ad	$28,$sy
6AFF:	ad	$28,$28
6B02:	ld	$29,$sy
6B04:	jp	&H6E6B
6B07:	cal	&H6B18
6B0A:	pre	ix,&H16B8
6B0E:	ldw	$16,(ix+$sx)
6B10:	cal	&H2AF1		;display character $16
6B13:	bydw	$17
6B15:	jp	&H7BD7		;display character $16 + '0'
6B18:	cal	&H6549
6B1B:	cal	&H20AC		;display the list of BASIC programs
6B1E:	pre	ix,&H16B7
6B22:	ldd	$0,(ix+$sx)
6B24:	pre	ix,&H2133
6B28:	cal	&H6519
6B2B:	cal	&H20A5		;display the list of data files
6B2E:	cal	&H2AD7		;display a space
6B31:	jp	&H20E2

; F.COM menu "New"
6B34:	cal	&H6B07
6B37:	ldw	$17,&H20F6	;string ">New (Y/N) ?"
6B3B:	cal	&H6520		;display a string from bank 2
6B3E:	cal	&H6543
6B41:	cal	&H655F		;wait for a key, convert to upper case
6B44:	sbc	$0,&H0D		;[EXE]
6B47:	jr	z,&H6B4E
6B49:	sbc	$0,&H59		;'Y'
6B4C:	jr	nz,&H6B54
6B4E:	cal	&H529B		;PR Error if password set
6B51:	cal	&H45D1		;delete the current file
6B54:	jp	&H6A4F

6B57:	sbc	$31,$sx,jr &H6B63 ;file 'P'
6B5A:	pre	ix,&H16B8
6B5E:	ldw	$13,(ix+$sx)	;$13 = F.COM P/F, $14 = F.COM file number
6B60:	sbc	$13,&H50	;'P'
6B63:	cal	&H3423		;get starting/ending address of file $14
6B66:	pre	ix,&H16C9	;NOWFL, currently used file
6B6A:	stw	$1,(ix+$sx)
6B6C:	rtn

; F.COM menu "Print"
6B6D:	cal	&H6B5A
6B70:	cal	&H33FA		;$2,$3 <- file size
6B73:	jr	z,&H6B93
6B75:	cal	&H6B07
6B78:	ldw	$17,&H2103	;string ">Print . . ."
6B7C:	cal	&H6520		;display a string from bank 2
6B7F:	cal	&H6543
6B82:	cal	&H529B		;PR Error if password set
6B85:	cal	&H2989		;select the printer as the output device
6B88:	cal	&H6B5A
6B8B:	sbc	$13,&H50	;'P'
6B8E:	jr	nz,&H6B98
; P file
6B90:	cal	&H3D8C		;list a BASIC program file
6B93:	cal	&H2991		;select the LCD as the output device
6B96:	jr	&H6B54
; F file
6B98:	cal	&H6B9D		;display a text file
6B9B:	jr	&H6B93

; display a text file, $25,$26=starting address, $27,$28=ending address
6B9D:	ldw	$19,$sy		;line number = 1
6B9F:	pre	iz,$25
6BA1:	sbw	$27,$sy
6BA3:	cal	&H2AE8		;OUTCR, display CR-LF
6BA6:	gre	iz,$25
6BA8:	sbcw	$25,$27
6BAB:	rtn	z
6BAC:	cal	&H2AD1		;display the line number followed by space
6BAF:	ldi	$16,(iz+$sx)
6BB1:	sbc	$16,&H0D
6BB4:	jr	nz,&H6BC6
6BB6:	ldd	$0,(iz+$sx)
6BB8:	sbc	$0,&H0A
6BBB:	jr	nz,&H6BBF
6BBD:	ldd	$0,(iz+$sy)	;skip the LF character
6BBF:	cal	&H2AE8		;OUTCR, display CR-LF
6BC2:	adw	$19,$sy		;increment the line number
6BC4:	jr	&H6BA6
6BC6:	sbc	$16,&H1A
6BC9:	jr	z,&H6BD0
6BCB:	cal	&H3DCB
6BCE:	jr	&H6BAF
6BD0:	ldd	$16,(iz-$sy)
6BD2:	jr	&H6BBF

; F.COM menu "Load"
6BD4:	cal	&H6B07
6BD7:	ldw	$17,&H20E0
6BDB:	jr	&H6BE4

; F.COM menu "Save"
6BDD:	cal	&H6B07
6BE0:	ldw	$17,&H20E7
6BE4:	cal	&H6C08
6BE7:	jr	&H6BF7

; F.COM menu "Merge"
6BE9:	cal	&H6B07
6BEC:	ldw	$17,&H20EE
6BF0:	ldw	$22,&H5F49
6BF4:	cal	&H6C0C
6BF7:	cal	&H9753		;INCLR, clear the INTOP input buffer
6BFA:	pre	ix,&H1000
6BFE:	cal	&H1CF9
6C01:	pre	iz,&H1000
6C05:	jp	&H262D

6C08:	ldw	$22,&H5F48
6C0C:	cal	&H6520		;display a string from bank 2
6C0F:	cal	&H6C2A
6C12:	ldw	$0,$22
6C15:	cal	&H6851
6C18:	cal	&H0317		;respect the cursor movement range setting
6C1B:	cal	&H2991		;select the LCD as the output device
6C1E:	ld	$16,&H06
6C21:	cal	&H2AF1		;display character $16
6C24:	cal	&H6810
6C27:	jp	&H0323
6C2A:	pre	ix,&H16B7
6C2E:	ldw	$17,&H2163
6C32:	sbc	(ix+$sx),$30
6C34:	jr	c,&H6C49
6C36:	jp	z,&H6520	;display a string from bank 2
6C39:	pre	ix,&H173D
6C3D:	ldd	$0,(ix+$sx)
6C3F:	an	$0,&H06		;index to the table of string addresses
6C42:	pre	ix,&H212B	;table of string addresses
6C46:	jp	&H651B		;display a string from bank 2
6C49:	ldw	$17,&H2139
6C4D:	cal	&H6520		;display a string from bank 2
6C50:	pre	ix,&H173E
6C54:	ldw	$20,(ix+$sx)
6C56:	ld	$16,$20
6C59:	an	$16,&HE0
6C5C:	inv	$16
6C5E:	did	$16
6C60:	bid	$16
6C62:	cal	&H7BD7		;display character $16 + '0'
6C65:	ld	$0,$20
6C68:	an	$0,&H1E		;index to the table of string addresses
6C6B:	pre	ix,&H21E6	;table of string addresses
6C6F:	cal	&H651B		;display a string from bank 2
6C72:	an	$21,&H1F
6C75:	ld	$0,$21
6C78:	pre	ix,&H2346
6C7C:	jp	&H6519

; F.COM menu "Edit"
6C7F:	pre	ix,&H16B8
6C83:	ldw	$13,(ix+$sx)
6C85:	ldw	$19,$sy
6C87:	sbc	$13,&H50
6C8A:	jr	nz,&H6CB3
6C8C:	ld	$0,$sx
6C8E:	pre	ix,&H16C4
6C92:	stm	$30,(ix+$sx),3
6C95:	cal	&H3404
6C98:	cal	&H2465
6C9B:	cal	&H529B		;PR Error if password set
6C9E:	cal	&H9272
6CA1:	jp	&H58E9

; menu "Source"
6CA4:	ldw	$19,$sy
6CA6:	cal	&H293F
6CA9:	pre	ix,&H168B
6CAD:	jr	nz,&H6CB1
6CAF:	ldd	$14,(ix+$sy)
6CB1:	ldd	$14,(ix+$sx)
6CB3:	cal	&H2465
6CB6:	pre	ix,&H168E
6CBA:	stw	$19,(ix+$sx)
6CBC:	ldw	$2,&H2446
6CC0:	cal	&H5294		;IX <- password buffer
6CC3:	jp	z,&H5AC8	;branch if empty
6CC6:	pre	ix,&H16C5
6CCA:	sbc	(ix+$sx),$31
6CCC:	jr	z,&H6CD4
6CCE:	cal	&H246E
6CD1:	cal	&H2465
6CD4:	jp	&H2BB8		;PR Error, password

6CD7:	pre	ix,&H1101
6CDB:	ld	$0,$sx
6CDD:	stw	$31,(ix+$sx)
6CDF:	cal	&H029C
6CE2:	cal	&H032E		;cursor display disable
6CE5:	ldw	$0,&H113B	;destination address
6CE9:	ldw	$2,&H13F7	;source address
6CED:	ldw	$4,&H0080	;number of transferred bytes
6CF1:	cal	&H0EBB		;block transfer from bank 2 to bank 1
6CF4:	pre	ix,&H173D
6CF8:	ldm	$25,(ix+$sx),3
6CFB:	cal	&H6E87
6CFE:	cal	&H6EB3
6D01:	cal	&H6ECA
6D04:	cal	&H6ED4
6D07:	cal	&H6EF0
6D0A:	cal	&H6EF7
6D0D:	cal	&H6EFE
6D10:	cal	&H6F05
6D13:	cal	&H6F0C
6D16:	cal	&H6F23
6D19:	cal	&H6F29
6D1C:	cal	&H6F37
6D1F:	ldw	$28,&H0405
6D23:	cal	&H6E40
6D26:	jr	c,&H6D4E
6D28:	jp	z,&H6E2C
6D2B:	sbc	$0,&H1E
6D2E:	ld	$0,&H20
6D31:	jr	z,&H6D3F
6D33:	sbc	$26,&HC0
6D36:	ld	$0,&HA0
6D39:	jr	nc,&H6D3F
6D3B:	ad	$26,&H20,jr &H6D49
6D3F:	sb	$26,$sz
6D41:	anc	$26,&HE0
6D44:	jr	nz,&H6D49
6D46:	or	$26,&HC0
6D49:	cal	&H6E87
6D4C:	jr	&H6D1F
6D4E:	ldw	$28,&H0113
6D52:	cal	&H6E40
6D55:	jr	c,&H6D83
6D57:	jr	z,&H6D1F
6D59:	ld	$1,$26
6D5C:	an	$1,&H06
6D5F:	sbc	$0,&H1F
6D62:	jr	c,&H6D6D
6D64:	sb	$1,&H02
6D67:	jr	nc,&H6D78
6D69:	ld	$1,&H04,jr &H6D78
6D6D:	anc	$1,&H04
6D70:	jr	nz,&H6D76
6D72:	ad	$1,&H02,jr &H6D78
6D76:	ld	$1,$sx
6D78:	an	$26,&HF9
6D7B:	or	$26,$1
6D7E:	cal	&H6EB3
6D81:	jr	&H6D4E
6D83:	ldw	$28,&H011E
6D87:	cal	&H6E40
6D8A:	jr	c,&H6D96
6D8C:	jr	z,&H6D4E
6D8E:	xr	$26,&H08
6D91:	cal	&H6ECA
6D94:	jr	&H6D83
6D96:	ldw	$28,&H0128
6D9A:	cal	&H6E40
6D9D:	jr	c,&H6DA9
6D9F:	jr	z,&H6D83
6DA1:	xr	$26,&H10
6DA4:	cal	&H6ED4
6DA7:	jr	&H6D96
6DA9:	ldw	$28,&H0331
6DAD:	cal	&H6E40
6DB0:	jr	c,&H6DBC
6DB2:	jr	z,&H6D96
6DB4:	xr	$27,&H04
6DB7:	cal	&H6EF0
6DBA:	jr	&H6DA9
6DBC:	ldw	$28,&H033C
6DC0:	cal	&H6E40
6DC3:	jr	c,&H6DCF
6DC5:	jr	z,&H6DA9
6DC7:	xr	$27,&H08
6DCA:	cal	&H6EF7
6DCD:	jr	&H6DBC
6DCF:	ldw	$28,&H0346
6DD3:	cal	&H6E40
6DD6:	jr	c,&H6DE2
6DD8:	jr	z,&H6DBC
6DDA:	xr	$27,&H10
6DDD:	cal	&H6EFE
6DE0:	jr	&H6DCF
6DE2:	ldw	$28,&H0351
6DE6:	cal	&H6E40
6DE9:	jr	c,&H6DF5
6DEB:	jr	z,&H6DCF
6DED:	xr	$27,&H02
6DF0:	cal	&H6F05
6DF3:	jr	&H6DE2
6DF5:	ldw	$28,&H035C
6DF9:	cal	&H6E40
6DFC:	jr	c,&H6E07
6DFE:	jr	z,&H6DE2
6E00:	xr	$27,$sy
6E02:	cal	&H6F0C
6E05:	jr	&H6DF5
6E07:	ldw	$28,&H0366
6E0B:	cal	&H6E40
6E0E:	jr	c,&H6E19
6E10:	jr	z,&H6DF5
6E12:	xr	$25,$sy
6E14:	cal	&H6F23
6E17:	jr	&H6E07
6E19:	ldw	$28,&H0173
6E1D:	cal	&H6E40
6E20:	jr	c,&H6E2C
6E22:	jr	z,&H6E07
6E24:	xr	$25,&H02
6E27:	cal	&H6F29
6E2A:	jr	&H6E19
6E2C:	ldw	$28,&H017E
6E30:	cal	&H6E40
6E33:	jp	c,&H6D1F
6E36:	jr	z,&H6E19
6E38:	xr	$25,&H04
6E3B:	cal	&H6F37
6E3E:	jr	&H6E2C
6E40:	ldw	$10,&H7F00
6E44:	cal	&H977F
6E47:	cal	&H6E6B
6E4A:	cal	&H930F
6E4D:	cal	&H23C8
6E50:	sbc	$0,&H0D
6E53:	jp	z,&H6A4F
6E56:	sbc	$0,&H1C
6E59:	jr	c,&H6E4D
6E5B:	sbc	$0,&H20
6E5E:	jr	nc,&H6E4D
6E60:	phs	$0
6E62:	cal	&H0397		;conditionally set the key repeat flag
6E65:	pps	$0
6E67:	sbc	$0,&H1D
6E6A:	rtn
6E6B:	pre	ix,&H1101
6E6F:	std	$28,(ix+$sx)
6E71:	cal	&H01F2
6E74:	ld	$0,$29
6E77:	pre	ix,$2
6E79:	ldm	$1,(ix+$sx),6
6E7C:	invm	$1,6
6E7F:	stim	$1,(ix+$sx),6
6E82:	sb	$0,$sy
6E84:	jr	nz,&H6E79
6E86:	rtn
6E87:	ld	$28,&H05
6E8A:	ld	$0,$26
6E8D:	an	$0,&HE0
6E90:	bid	$0
6E92:	bid	$0
6E94:	bid	$0
6E96:	gst	ua,$4
6E98:	pst	ua,&H94
6E9B:	pre	iz,&H1473
6E9F:	ldm	$0,(iz+$sz),4
6EA2:	pst	ua,$4
6EA4:	pre	ix,&H113B
6EA8:	stm	$0,(ix+$28),4
6EAB:	pre	ix,&H173D
6EAF:	stm	$25,(ix+$sx),3
6EB2:	rtn
6EB3:	ld	$28,&H13
6EB6:	anc	$26,&H04
6EB9:	ld	$0,&H4E
6EBC:	jr	nz,&H6EE1
6EBE:	anc	$26,&H02
6EC1:	ld	$0,&H4F
6EC4:	jr	nz,&H6EE1
6EC6:	ld	$0,&H45,jr &H6EE1
6ECA:	ld	$28,&H1E
6ECD:	anc	$26,&H08
6ED0:	ld	$0,&H37,jr &H6EDD
6ED4:	ld	$28,&H28
6ED7:	anc	$26,&H10
6EDA:	ld	$0,&H31
6EDD:	jr	nz,&H6EE1
6EDF:	ad	$0,$sy
6EE1:	pre	ix,&H113B
6EE5:	st	$0,(ix+$28)
6EE8:	pre	ix,&H173D
6EEC:	stm	$25,(ix+$sx),3
6EEF:	rtn
6EF0:	ld	$28,&H31
6EF3:	anc	$27,&H04,jr &H6F11
6EF7:	ld	$28,&H3C
6EFA:	anc	$27,&H08,jr &H6F11
6EFE:	ld	$28,&H46
6F01:	anc	$27,&H10,jr &H6F11
6F05:	ld	$28,&H51
6F08:	anc	$27,&H02,jr &H6F11
6F0C:	ld	$28,&H5C
6F0F:	anc	$27,$sy
6F11:	ldw	$0,&H4F20
6F15:	ldw	$2,&H5D4E
6F19:	jr	nz,&H6EA4
6F1B:	ldw	$0,&H464F
6F1F:	ld	$2,&H46,jr &H6EA4
6F23:	ld	$28,&H66
6F26:	anc	$25,$sy,jr &H6F11
6F29:	ld	$28,&H73
6F2C:	anc	$25,&H02
6F2F:	ld	$0,&H30
6F32:	jr	z,&H6EE1
6F34:	ad	$0,$sy,jr &H6EE1
6F37:	ld	$28,&H7E
6F3A:	anc	$25,&H04
6F3D:	ld	$0,&H46
6F40:	jr	z,&H6EE1
6F42:	ld	$0,&H53,jr &H6EE1
6F46:	pre	ss,&H1BD7
6F4A:	cal	&H6673
6F4D:	cal	&H6549
6F50:	ldw	$17,&H1721	;main CASL menu
6F54:	cal	&H293F
6F57:	jr	nz,&H6F5D
6F59:	ldw	$17,&H17F4	;main C menu
6F5D:	cal	&H6520		;display a string from bank 2
6F60:	phsw	$18
6F62:	cal	&H20A5		;display the list of data files
6F65:	cal	&H2AD7		;display a space
6F68:	cal	&H20E2
6F6B:	ld	$16,&H46	;'F'
6F6E:	cal	&H2AF1		;display character $16
6F71:	ppsw	$17
6F73:	cal	&H7005
6F76:	phs	$16
6F78:	cal	&H7BD7		;display character $16 + '0'
6F7B:	cal	&H6520		;display a string from bank 2
6F7E:	ldw	$10,&H7F00
6F82:	cal	&H977F
6F85:	pps	$28
6F87:	cal	&H6AEE
6F8A:	cal	&H2991		;select the LCD as the output device
6F8D:	cal	&H930F
6F90:	cal	&H655F		;wait for a key, convert to upper case
6F93:	ld	$17,$sz
6F95:	cal	&H7005
6F98:	ldd	$28,(ix+$sx)
6F9A:	sbc	$17,&H1C	;right
6F9D:	jr	z,&H7002	;next file area
6F9F:	sbc	$17,&H1D	;left
6FA2:	jr	z,&H6FE4	;previous file area
6FA4:	sbc	$17,&H43	;'C'
6FA7:	jp	z,&H2446	;mode CAL
6FAA:	sbc	$17,&H53	;'S'
6FAD:	jp	z,&H6CA4	;menu "Source"
6FB0:	cal	&H293F
6FB3:	jr	z,&H6FBD
6FB5:	sbc	$17,&H41	;'A'
6FB8:	jp	z,&H7028	;menu "Assemble"
6FBB:	jr	&H6F90
6FBD:	ld	$14,$28
6FC0:	ad	$14,&H0A
6FC3:	sbc	$17,&H52
6FC6:	jr	z,&H6FD8
6FC8:	sbc	$17,&H4C
6FCB:	jr	nz,&H6F90
6FCD:	cal	&H6B63
6FD0:	cal	&H33FA		;$2,$3 <- file size
6FD3:	jr	z,&H6FE1
6FD5:	jp	&HA0DB
6FD8:	cal	&H6B63
6FDB:	cal	&H33FA		;$2,$3 <- file size
6FDE:	jp	nz,&HA100
6FE1:	jp	&H6F4D

; previous file area
6FE4:	sbb	$16,$sy
6FE6:	an	$16,&H0F
6FE9:	std	$16,(ix+$sx)
6FEB:	cal	&H6AEE
6FEE:	ld	$0,&H61
6FF1:	or	$16,&H30
6FF4:	cal	&H6AC5
6FF7:	cal	&H0397		;conditionally set the key repeat flag
6FFA:	cal	&H7005
6FFD:	ld	$28,$16
7000:	jr	&H6F87
; next file area
7002:	adb	$16,$sy,jr &H6FE6

7005:	cal	&H293F
7008:	pre	ix,&H168B
700C:	jr	nz,&H7010
700E:	ldd	$16,(ix+$sy)
7010:	ldd	$16,(ix+$sx)
7012:	rtn

7013:	pre	ss,&H1BD7
7017:	cal	&H667A
701A:	ldw	$0,&H168E
701E:	ldw	$2,&H0029
7022:	cal	&H0157		;CLRME, clear memory block
7025:	jp	&H6F4D


; *** CASL assembler, COMET simulator ***

; An assembler statement consists of following fields:
; [label] [operation] [operands] [;comment]

; utilisation of the buffer WORK1
; WORK1+0:	DS 1	;register $29
; WORK1+1:	DS 6	;name of the label following the START directive
; WORK1+7:	DS 2	;address of the block
; data for the assembly listing
; WORK1+10:	DS 2	;location counter
; WORK1+12:	DS 2	;pointer to object code
; WORK1+14:	DS 1	;instruction opcode
; WORK1+15:	DS 2	;pointer to the source line
; data for the function &H79B9
; WORK1+16:	DS 2	;pointer to the source
; WORK1+18:	DS 2	;line number
; WORK1+20:	DS 2	;location counter

; global variables in registers
; $19,$20 = line counter
; $21,$22 = location counter
; $23,$24 = pointer to the end of object code and the begin of free area
; $25,$26 = pointer to the end of free area and the top of the symbol table

; bits of register $29
; bit 0 - assembly error
; bit 1 - an entry was added to the symbol table (local to the function &H79B9)
; bit 2 - label found (result of the function &H72EB)
; bit 3 - what to search in the symbol or mnemonic table (argument of the
;  functions &H7316 and &H7A2F)
; bits 5,4 specify how the labels in the label field are processed (argument
;  of the function &H79B9)
;  00 - they are added to the symbol table
;  01 - nothing is done with them
;  11 - local ones are compared with the START label and operand
; bit 6 - START is followed by a not yet defined label (argument and result of
;  the function &H79B9)

; menu "Assemble"
7028:	phs	$16
702A:	cal	&H7C05
702D:	pps	$14
702F:	cal	&H3425
7032:	pre	ix,&H16C9
7036:	stw	$1,(ix+$sx)
7038:	ldw	$0,$27
703B:	sbw	$0,$sy
703D:	sbcw	$25,$sz
703F:	jr	z,&H7013
7041:	pre	iz,$25
7043:	pre	ix,&H18D0
7047:	ldm	$23,(ix-$sy),4
704A:	ldw	$27,(ix+$sy)
704C:	ldw	$19,$sy
704E:	sbw	$21,$21
7051:	pre	ix,&H1694
7055:	stm	$21,(ix+$sx),4
7058:	ld	$29,$sx,jr &H7063
;
705B:	sbc	$0,&H1A		;EOF?
705E:	jr	z,&H70CE	;SO error if so
7060:	cal	&H7ADB		;next line of the source code
; look for a START directive obligatory preceded by a label
7063:	an	$29,&H0F
7066:	cal	&H79B9		;parse the label field and the operation field
7069:	jr	z,&H705B	;loop if no instruction or directive found
706B:	anc	$29,&H04
706E:	jr	z,&H70CE	;SO error if the label field is empty
7070:	cal	&H7A76		;advance the Location Counter $21,$22
7073:	sbc	$11,&H02	;START directive?
7076:	jr	nz,&H70CE	;SO error if not
7078:	or	$29,&H30
707B:	cal	&H736A		;end of statement?
707E:	jr	z,&H7099	;skip if so
; optional START operand, must be a label
7080:	cal	&H72EB		;fetch a label name pointed to by IZ to $8-$13
7083:	anc	$29,&H04
7086:	jr	z,&H70CE	;SO error if no label found
7088:	cal	&H7367		;end of statement expected
708B:	jr	nz,&H70CE	;otherwise SO error
708D:	or	$29,&H40	;START is followed by a not yet defined label
7090:	pre	ix,&H165E	;WORK1, work buffer
7094:	sti	$29,(ix+$sx)
7096:	cal	&H7360		;store the label and block address at WORK1+1
; look for an END directive
7099:	cal	&H7ADB		;next line of the source code
709C:	cal	&H79B9		;parse the label field and the operation field
709F:	jr	z,&H70C9	;branch if no instruction or directive found
70A1:	cal	&H7A76		;advance the Location Counter $21,$22
70A4:	sbc	$11,$sy		;END directive?
70A6:	jr	nz,&H7099	;loop if not
;
70A8:	cal	&H736A		;end of statement expected
70AB:	jr	nz,&H70CE	;otherwise SO error
70AD:	anc	$29,&H44
70B0:	jr	nz,&H70CE	;SO error if START operand undefined or END
				;preceded by a label
70B2:	cal	&H7ADB		;next line of the source code
70B5:	cal	&H0049		;NEXTC, get next charaxter other than space
70B8:	sbc	$0,&H1A		;EOF?
70BB:	jr	z,&H70D7	;pass 2 if so
70BD:	sbc	$0,&H3B		;semicolon?
70C0:	jr	z,&H70B2
70C2:	sbc	$0,&H0D		;CR?
70C5:	jr	z,&H70B2
70C7:	jr	&H7063
;
70C9:	sbc	$0,&H1A		;EOF?
70CC:	jr	nz,&H7099	;loop if not
70CE:	ld	$2,&H02		;index of the acronym "SO"
70D1:	cal	&H7280		;report an assembly error
70D4:	jp	&H7013

; pass 2
70D7:	anc	$29,$sy
70D9:	jr	nz,&H70D4	;branch if an assembly error occurred
70DB:	sbcw	$21,$sy
70DD:	jr	c,&H70D4
70DF:	pre	ix,&H1690
70E3:	stm	$25,(ix+$sx),4
70E6:	cal	&H33EE		;get starting/ending address of current file
70E9:	pre	iz,$25
70EB:	pre	ix,&H1690
70EF:	ldw	$25,(ix+$sx)
70F1:	ldw	$19,$sy		;line counter = 1
70F3:	sbw	$21,$21		;location counter
70F6:	ld	$29,$sx
70F8:	or	$29,&H10
70FB:	ldw	$27,$25
70FE:	pre	ix,&H166E	;WORK1+16
7102:	gre	iz,$17
7104:	stm	$17,(ix+$sx),6
7107:	cal	&H79B9		;parse the label field and the operation field
710A:	jr	z,&H711E	;branch if no instruction or directive found
710C:	cal	&H7A76		;advance the Location Counter $21,$22
710F:	sbc	$11,&H02
7112:	jr	c,&H7133	;pass 3 if END
7114:	jr	nz,&H7119
; START
7116:	an	$29,&H0F
7119:	cal	&H7ADB		;next line of the source code
711C:	jr	&H7107
711E:	sbc	$0,&H1A		;EOF?
7121:	jr	nz,&H7119
; end of source reached
7123:	anc	$29,$sy
7125:	jr	nz,&H70D4	;branch if an assembly error occurred
7127:	jp	&H73A5

712A:	sbc	$11,$sy
712C:	jr	nz,&H7190	;branch if START
; END
712E:	cal	&H7ADB		;next line of the source code
7131:	jr	&H70F8		;next block, pass 2
;
; pass 3
7133:	or	$29,&H10
7136:	pre	ix,&H166E	;WORK1+16
713A:	ldm	$17,(ix+$sx),6
713D:	pre	iz,$17
713F:	pre	ix,&H1668	;WORK1+10
7143:	stim	$21,(ix+$sx),4
7146:	gre	iz,$0
7148:	stw	$0,(ix+$sy)
714A:	cal	&H79B9		;parse the label field and the operation field
714D:	jr	z,&H7190	;branch if no instruction or directive found
714F:	pre	ix,&H166C	;WORK1+14
7153:	std	$11,(ix+$sx)
7155:	cal	&H7A76		;advance the Location Counter $21,$22
7158:	jp	c,&H71EF	;OM error
; parse the operand field
715B:	sbw	$12,$12
715E:	ld	$10,$sx
7160:	sbc	$11,&H03
7163:	jr	c,&H712A	;START, END
7165:	jr	nz,&H716B
7167:	ld	$11,&H90,jr &H7188	;EXIT, change the opcode to &H9000
716B:	sbc	$11,&H06
716E:	jp	z,&H7215	;DC
7171:	jp	c,&H71F8	;IN, OUT
7174:	sbc	$11,&H07
7177:	jr	z,&H71DC	;DS
7179:	sbc	$11,&H60
717C:	jr	c,&H7195
717E:	sbc	$11,&H71
7181:	jr	z,&H7195	;POP
7183:	sbc	$11,&H81
7186:	jr	nz,&H71A8	;branch if not RET
7188:	cal	&H7367		;end of statement expected
718B:	jr	nz,&H71D4	;otherwise OR error
718D:	cal	&H7266		;write two words of the object code
7190:	cal	&H7ADB		;next line of the source code
7193:	jr	&H713F

; operands: GR, adr, [,XR]
7195:	cal	&H77FD		;parse for a GR register
7198:	jr	nc,&H71D4	;OR error if not found
719A:	ld	$10,$sz
719C:	diu	$10
719E:	sbc	$11,&H71
71A1:	jr	z,&H7188	;POP
71A3:	cal	&H00C3		;test for a comma
71A6:	jr	nz,&H71D4	;OR error if not found
; jumps/CALL/push operands: adr [, XR]
71A8:	cal	&H00A9		;is next character a letter?
71AB:	jr	nc,&H71BC	;branch if not
; address specified by a label
71AD:	phsw	$11
71AF:	cal	&H72CF		;search the symbol table
71B2:	ldw	$12,$6
71B5:	ppsw	$10
71B7:	jr	nz,&H71C4	;branch if the label found
71B9:	ld	$2,$sx,jr &H71D7	;otherwise LA error
; address specified by a signed decimal number
71BC:	cal	&H781E		;$17,$18 <- value of a number pointed to by IX
71BF:	jr	nc,&H71D4	;OR error
71C1:	ldw	$12,$17
; optional index register XR
71C4:	cal	&H00C3		;test for a comma
71C7:	jr	nz,&H7188
71C9:	cal	&H77FD		;parse for a GR register
71CC:	jr	nc,&H71D4	;OR error if not found
71CE:	or	$10,$sz
71D0:	sbc	$0,$sx		;GR0 cannot be used as an index register
71D2:	jr	nz,&H7188
71D4:	ld	$2,&H06		;index of the acronym "OR"
71D7:	cal	&H7280		;report an assembly error
71DA:	jr	&H7190

; DS operand
71DC:	cal	&H736A		;end of statement expected
71DF:	jr	nz,&H71D4	;otherwise OR error
71E1:	biuw	$17
71E3:	jr	c,&H71ED
71E5:	adw	$23,$17		;$23,$24 = pointer to the end of object code
71E8:	jr	c,&H71ED
71EA:	sbcw	$25,$23		;$25,$26 = pointer to the end of free area
71ED:	jr	nc,&H7190
71EF:	ld	$2,&H04		;index of the acronym "OM"
71F2:	cal	&H7280		;report an assembly error
71F5:	jp	&H2446		;mode CAL

; IN/OUT operands
71F8:	sb	$11,&H73	;change the opcode to &H9100/&H9200
71FB:	cal	&H7266		;write two words of the object code
71FE:	ldd	$0,(iz+$sx)
7200:	cal	&H72CF		;search the symbol table
7203:	jr	z,&H71B9	;LA error if not found
7205:	cal	&H00C3		;test for a comma
7208:	jr	nz,&H71D4	;OR error if not found
720A:	cal	&H0049		;NEXTC, get next character other than space
720D:	cal	&H726F		;write a word of the object code
7210:	cal	&H72CF		;search the symbol table
7213:	jr	&H7227

; DC operand
7215:	ldd	$0,(iz+$sx)
7217:	sbc	$0,&H27		;apostrophe? (begin of a string)
721A:	jr	z,&H7240
721C:	cal	&H72EB		;fetch a label name pointed to by IZ to $8-$13
721F:	anc	$29,&H04
7222:	jr	z,&H7236	;branch if no label found
; label
7224:	cal	&H72D6		;search the symbol table
7227:	jp	z,&H71B9	;LA error if not found
722A:	cal	&H7367		;end of statement expected
722D:	jp	nz,&H71D4	;otherwise OR error
7230:	cal	&H726F		;write a word of the object code
7233:	jp	&H7190
; number
7236:	cal	&H7819		;$17,$18 <- value of a number pointed to by IX
7239:	jp	nc,&H71D4	;OR error if value > 65535
723C:	ldw	$6,$17,jr &H722A
; string
7240:	ld	$7,$sx
7242:	ldd	$0,(iz+$sy)
7244:	sbc	$0,&H27		;apostrophe?
7247:	jr	z,&H7239	;OR error if an empty string
7249:	sbc	$0,&H27		;apostrophe? (end of the string)
724C:	jr	z,&H725C
724E:	cal	&H7370		;premature end_of_line or end_of_file?
7251:	jr	z,&H7239	;OR error if so
7253:	ld	$6,$sz
7255:	cal	&H726F		;write a word of the object code
7258:	ldd	$0,(iz+$sy)
725A:	jr	&H7249
725C:	cal	&H004D
725F:	cal	&H736A		;end of statement expected
7262:	jr	nz,&H722D	;otherwise OR error
7264:	jr	&H7233

; write two words of the object code
7266:	ldw	$6,$10
7269:	cal	&H726F		;write a word of the object code
726C:	ldw	$6,$12
; write a word of the object code
726F:	pre	ix,$23		;pointer to the end of object code
7271:	adw	$23,$sy
7273:	adw	$23,$sy
7275:	sbcw	$25,$23		;$25,$26 = pointer to the end of free area
7278:	jp	c,&H71EF	;OM error
727B:	stw	$6,(ix+$sx)
727D:	rtn

727E:	ld	$2,$sx		;index of the acronym "LA"
; report an assembly error - display or print an error message of the index $2
; followed by the line number $19
7280:	or	$29,$sy
7282:	cal	&H72B5
7285:	cal	&H72A6
7288:	ldw	$3,$19		;line number
728B:	cal	&H7CC6
728E:	cal	&H2AE8		;OUTCR, display CR-LF
7291:	cal	&H2991		;select the LCD as the output device
7294:	gre	iz,$0
7296:	phsw	$1
7298:	cal	&H655F		;wait for a key, convert to upper case
729B:	ppsw	$1
729D:	sbc	$0,&H53		;'S'
72A0:	jp	z,&H6CA6
72A3:	pre	iz,$1
72A5:	rtn

72A6:	phsm	$19,3
72A9:	ldw	$17,&H16D7
72AD:	cal	&H6520		;display a string from bank 2
72B0:	ppsm	$17,3
72B3:	jr	&H72CC

; display the acronym of the index $2
72B5:	pre	ix,&H169F	;table of acronyms
72B9:	pst	ua,&HA4
72BC:	ldw	$15,(ix+$2)	;fetch two characters from the table
72BF:	pst	ua,&H54
72C2:	phs	$15
72C4:	cal	&H2AF1		;display character $16
72C7:	pps	$16
72C9:	cal	&H2AF1		;display character $16
72CC:	jp	&H2AD7		;display a space

; search the symbol table for a label pointed to by IX
; pointers $25,$26 and $27,$28 enclose the scope in the local symbol table
72CF:	cal	&H72EB		;fetch a label name pointed to by IZ to $8-$13
72D2:	anc	$29,&H04
72D5:	rtn	z		;return if no label found
; search the symbol table for a label in $8-$13
72D6:	cal	&H7328		;search the symbol table
72D9:	rtn	c		;return if found
72DA:	phsm	$28,4
72DD:	pre	ix,&H1690
72E1:	ldm	$25,(ix+$sx),4	;pointers to the global symbol table
72E4:	cal	&H7328		;search the symbol table
72E7:	ppsm	$25,4
72EA:	rtn

; fetch a label name pointed to by IZ to $8-$13, right aligned
72EB:	an	$29,&HFB
72EE:	sbbm	$8,$8,8
72F1:	sbc	$0,&H20		;space
72F4:	rtn	z
; A label can contain upper case letters and digits. The first character must
; not be a digit.
72F5:	sbc	$0,&H41		;'A'
72F8:	rtn	c		;return with Not Zero
72F9:	sbc	$0,&H5B		;'Z'+1
72FC:	jr	nc,&H733C	;return with Not Zero
72FE:	or	$29,&H04	;label found
7301:	adc	$8,&HFF		;test $8 for zero
7304:	rtn	c		;return with NZ if already 6 characters copied
7305:	bydm	$13,6
7308:	ld	$13,$sz
730A:	ldd	$0,(iz+$sy)
730C:	cal	&H002B		;OKNM1, is $0 a digit?
730F:	jr	nc,&H72F5	;branch if not
7311:	jr	&H72FE

; $0-$5 <- name of a label with a value $17,$18
7313:	ld	$29,&H08
; $6,$7 <- value of a label with a name $8-$13
7316:	pre	ix,&H1690
731A:	ldm	$25,(ix+$sx),4	;pointers to the global symbol table
731D:	cal	&H7328		;search the symbol table
7320:	rtn	nz		;return if found
7321:	pre	ix,&H168E
7325:	ldm	$25,(ix+$sx),4	;pointers to the local symbol table
; search the symbol table between pointers $25,$26 and $27,$28 for a name
; or value, depending on bit 3 of register $29
7328:	pre	ix,$27
; loop
732A:	gre	ix,$0
732C:	sbcw	$25,$sz
732E:	rtn	z		;end of the table, not found
732F:	lddm	$7,(ix-$sy),8
7332:	anc	$29,&H08
7335:	jr	nz,&H733F
7337:	xrcm	$8,$sz,6	;compare the names
733A:	jr	nz,&H732A	;next table entry if they don't match
733C:	sbc	$31,$sy		;Not Zero, Carry
733E:	rtn			;found
733F:	sbcw	$17,$6		;compare the values
7342:	jr	nc,&H733A
7344:	sbc	$31,$sx		;Zero flag
7346:	rtn			;not found

; add an entry to the symbol table
; label name in $0-$5, label value (location counter) in $21,$22,
; pointer to the top of the table in $25,$26,
; pointer to the begin of the free area in $23,$24
7347:	cal	&H7328		;search the symbol table
734A:	jr	z,&H7352	;skip if label not yet defined
734C:	cal	&H727E		;display "LA error" message and line number
734F:	sbbm	$8,$8,8
7352:	ldw	$0,&H0008	;size of the symbol table entry
7356:	sbw	$25,$sz
7358:	sbcw	$25,$23
735B:	jp	c,&H71EF	;OM error
735E:	pre	ix,$25
7360:	ldw	$14,$21
7363:	stm	$8,(ix+$sx),8
7366:	rtn

; test for an end of a statement
7367:	cal	&H0049		;NEXTC, get next character other than space
736A:	ldd	$0,(iz+$sx)
736C:	sbc	$0,&H3B		;semicolon?
736F:	rtn	z
7370:	sbc	$0,&H0D		;end_of_line?
7373:	rtn	z
7374:	sbc	$0,&H1A		;end_of_file?
7377:	rtn

7378:	pre	ss,&H1BD7
737C:	cal	&H0323
737F:	cal	&H7AFF		;test the Print on/off switch
7382:	jr	nz,&H738A	;branch if Print on
7384:	cal	&H654F
7387:	jp	&H7672
738A:	cal	&H654F
738D:	cal	&H7C05
7390:	cal	&H2989		;select the printer as the output device
7393:	ldw	$17,&H16DD
7397:	cal	&H6520		;display a string from bank 2
739A:	cal	&H7B94		;display the PC value and an optional label
739D:	cal	&H2AE8		;OUTCR, display CR-LF
73A0:	cal	&H2991		;select the LCD as the output device
73A3:	jr	&H7387

; assembly completed successfully
73A5:	pre	ix,&H169C
73A9:	sti	$31,(ix+$sx)	;Trace off
73AB:	ld	$0,$sx
73AD:	stw	$31,(ix+$sx)	;clear the breakpoint
73AF:	ldd	$0,(ix-&H0F)	;IX<-&H168E
73B2:	stw	$25,(ix+$sx)
73B4:	ldd	$0,(ix+&H0A)	;IX<-&H1698
73B7:	sbw	$21,$sy		;decrement the location counter
73B9:	stw	$21,(ix+$sx)	;last address in the object code
73BB:	pre	ix,&H16A7
73BF:	sbbm	$0,$sz,8
73C2:	stim	$0,(ix+$sx),8	;clear registers GR0 to GR3
73C5:	sbw	$0,$sy
73C7:	stm	$0,(ix+$sx),3	;GR4=&HFFFF, FR=0
73CA:	pre	ix,&H1694
73CE:	ldw	$1,(ix+$sx)
73D0:	cal	&H7B7B		;IX<-&H169A
73D3:	stw	$1,(ix+$sx)	;PC = default object code execution address
73D5:	pre	ss,&H1BD7
73D9:	cal	&H66BA		;US<-&H1CD0, UA<-&H54
73DC:	cal	&H0323
73DF:	ldw	$2,&H73D5	;jump address
73E3:	cal	&H297A		;BRSTR, set ACJMP
73E6:	cal	&H6549
73E9:	ldw	$17,&H174D	;menu "Go/Dump/Source/Cal/Print/Trace"
73ED:	cal	&H6520		;display a string from bank 2
73F0:	cal	&H7B18
73F3:	ldw	$0,&H1101
73F7:	st	&H74,($sz)
73FA:	pre	ix,&H169C
73FE:	ldd	$0,(ix+$sx)
7400:	ld	$1,(ix+&H17)
7403:	pre	ix,&H17BE
7407:	cal	&H6512
740A:	cal	&H6543
740D:	cal	&H655F		;wait for a key, convert to upper case
7410:	sbc	$0,&H0D		;[EXE]
7413:	jp	z,&H7672
7416:	sb	$0,&H43		;'C'
7419:	jp	z,&H2446	;mode CAL
741C:	sb	$0,$sy
741E:	jr	z,&H7448	;branch if 'D' pressed
7420:	sb	$0,&H03
7423:	jp	z,&H764F	;branch if 'G' pressed
7426:	pre	ix,&H16B3
742A:	sb	$0,&H09
742D:	jr	z,&H743D	;branch if 'P' pressed
742F:	sb	$0,&H03
7432:	jp	z,&H6CA4	;branch if 'S' pressed
7435:	pre	ix,&H169C
7439:	sb	$0,$sy
743B:	jr	nz,&H740D	;branch if not 'T' pressed, invalid key
; submenu "Print", "Trace"
743D:	ldd	$0,(ix+$sx)
743F:	ad	$0,$sy		;flip the off/on flag
7441:	an	$0,$sy
7443:	std	$0,(ix+$sx)
7445:	jp	&H73D5

; submenu "Dump" of the menu "Assemble" after successful assembly
7448:	ldw	$17,&H1789	;menu "Object/Register/Break point"
744C:	cal	&H653D
744F:	cal	&H655F		;wait for a key, convert to upper case
7452:	sbc	$0,&H52		;'R'
7455:	jp	z,&H7499
7458:	sbc	$0,&H4F		;'O'
745B:	jp	z,&H754E
745E:	sbc	$0,&H42		;'B'
7461:	jr	nz,&H744F
7463:	cal	&H6549
7466:	ldw	$17,&H16DD
746A:	cal	&H6520		;display a string from bank 2
746D:	pre	ix,&H169D
7471:	ldm	$17,(ix+$sx),4
7474:	anc	$18,$sy
7476:	cal	nz,&H7B1D
7479:	cal	&H75F9
747C:	jr	z,&H7496
747E:	pre	ix,&H1698
7482:	sbw	$4,$4
7485:	adcw	$6,$sy
7487:	jr	c,&H748F
7489:	sbcw	(ix+$sx),$6
748B:	jr	c,&H7479
748D:	ld	$5,$sy
748F:	pre	ix,&H169D
7493:	stim	$4,(ix+$sx),4
7496:	jp	&H73D5
7499:	pre	ix,&H16A6
749D:	std	$31,(ix+$sx)
749F:	cal	&H6549
74A2:	ld	$28,$sx
74A4:	cal	&H7B8A		;display a string 'GR'
74A7:	ld	$16,$28
74AA:	cal	&H7BD7		;display character $16 + '0'
74AD:	cal	&H7B80		;display a colon
74B0:	pre	ix,&H16A7
74B4:	ld	$0,$28
74B7:	ad	$0,$sz
74B9:	ldd	$0,(ix+$sz)
74BB:	ldw	$0,(ix+$sx)
74BD:	phsw	$1
74BF:	ldw	$14,$sz
74C1:	cal	&H7ABC
74C4:	cal	&H2AD7		;display a space
74C7:	ppsw	$3
74C9:	cal	&H7CC6
74CC:	cal	&H7BDD
74CF:	ad	$28,$sy
74D1:	sbc	$28,&H05
74D4:	jr	nz,&H74A4
74D6:	ld	$16,&H46	;'G'
74D9:	cal	&H7B8D		;display character $16 followed by 'R'
74DC:	cal	&H2AD7		;display a space
74DF:	cal	&H7B80		;display a colon
74E2:	pre	iz,&H16B1
74E6:	cal	&H7BD2
74E9:	pre	ix,&H16A6
74ED:	ldd	$0,(ix+$sx)
74EF:	ad	$0,$sz
74F1:	pre	ix,&H1717
74F5:	pst	ua,&HA4
74F8:	ldw	$17,(ix+$sz)
74FA:	pst	ua,&H54
74FD:	cal	&H75FD
7500:	pre	ix,&H16A7
7504:	jr	z,&H750C
7506:	ld	$0,(ix-$sy)
7508:	biu	$0
750A:	stw	$6,(ix+$sz)
750C:	ldd	$0,(ix-$sy)
750E:	ad	$0,$sy
7510:	sbc	$0,&H05
7513:	jr	c,&H7517
7515:	ld	$0,$sx
7517:	std	$0,(ix+$sx)
7519:	jr	&H749F
751B:	cal	&H7C05
751E:	cal	&H2989		;select the printer as the output device
7521:	cal	&H2AE8		;OUTCR, display CR-LF
7524:	ppsw	$17
7526:	sbcw	$21,$17
7529:	jr	c,&H7548
752B:	cal	&H7AB6
752E:	cal	&H7B4D
7531:	cal	&H7B45		;display the name of an optional label
7534:	cal	&H7B50
7537:	ldw	$0,$17
753A:	biuw	$0
753C:	adw	$0,$19
753F:	cal	&H7ABA
7542:	cal	&H2AE8		;OUTCR, display CR-LF
7545:	adw	$17,$sy,jr &H7526
7548:	cal	&H2991		;select the LCD as the output device
754B:	jp	&H29F0
754E:	sbw	$6,$6
7551:	cal	&H7B06
7554:	cal	&H75F9
7557:	ldw	$17,$6
755A:	pre	ix,&H1696
755E:	ldm	$19,(ix+$sx),4
7561:	sbcw	$21,$17
7564:	jr	c,&H754E
7566:	phsw	$18
7568:	cal	&H7AFF		;test the Print on/off switch
756B:	jr	nz,&H751B	;branch if Print on
756D:	cal	&H6549
7570:	ld	$23,&H04,jr &H7577
7574:	cal	&H2AE8		;OUTCR, display CR-LF
7577:	sbcw	$21,$17
757A:	jr	c,&H7599
757C:	cal	&H7AB6
757F:	cal	&H7BDD
7582:	cal	&H7B26
7585:	cal	&H7BDD
7588:	ldw	$0,$17
758B:	biuw	$0
758D:	adw	$0,$19
7590:	cal	&H7ABA
7593:	adw	$17,$sy
7595:	sb	$23,$sy
7597:	jr	nz,&H7574
7599:	ppsw	$17
759B:	cal	&H6543
759E:	cal	&H655F		;wait for a key, convert to upper case
75A1:	sbc	$0,&H0D
75A4:	jr	z,&H75B6
75A6:	sb	$0,&H1C
75A9:	jr	z,&H75C9
75AB:	sb	$0,&H02
75AE:	jr	c,&H75C9
75B0:	jr	z,&H75BE
75B2:	sb	$0,$sy
75B4:	jr	nz,&H759E
75B6:	sbcw	$17,$21
75B9:	jr	z,&H759E
75BB:	adw	$17,$sy,jr &H75C4
75BE:	sbcw	$17,$sy
75C0:	jr	c,&H759E
75C2:	sbw	$17,$sy
75C4:	cal	&H0397		;conditionally set the key repeat flag
75C7:	jr	&H75F6
75C9:	ldw	$19,&H6510
75CD:	phsw	$18
75CF:	ldw	$17,&H16F4
75D3:	ldw	$0,&H1101
75D7:	st	&H60,($sz)
75DA:	cal	&H6520		;display a string from bank 2
75DD:	ldw	$0,&H7F65
75E1:	cal	&H6851
75E4:	cal	&H0317		;respect the cursor movement range setting
75E7:	cal	&H7619
75EA:	ppsw	$19
75EC:	jr	z,&H75F3
75EE:	cal	&H77DE		;convert an address $19,$20 to a pointer IX
75F1:	stw	$6,(ix+$sx)
75F3:	ldw	$17,$19
75F6:	jp	&H755A
75F9:	ldw	$17,&H16EB
75FD:	ldw	$0,&H1101
7601:	st	&H60,($sz)
7604:	cal	&H6520		;display a string from bank 2
7607:	cal	&H6543
760A:	pre	ix,&H1101
760E:	ld	$0,(ix+$sx)
7610:	ld	$1,&H7F
7613:	cal	&H6851
7616:	cal	&H0317		;respect the cursor movement range setting
7619:	cal	&H2ADB
761C:	cal	&H6817
761F:	sbw	$6,$6
7622:	sbc	(iz+$sx),$31
7624:	jr	z,&H7649
7626:	cal	&H00A9
7629:	jr	c,&H7634
762B:	cal	&H7819
762E:	jr	nc,&H7619
7630:	ldw	$6,$17,jr &H763E
7634:	cal	&H72EB
7637:	ld	$29,$sx
7639:	cal	&H7316
763C:	jr	z,&H7619
763E:	cal	&H003C		;ENDSC, test for an end of a BASIC line
7641:	jr	nc,&H7619
7643:	cal	&H0323
7646:	sbc	$31,$sy
7648:	rtn
7649:	cal	&H0323
764C:	sbc	$31,$sx		;Zero flag
764E:	rtn

; submenu "Go" of the menu "Assemble" after successful assembly
764F:	cal	&H7B06
7652:	ldw	$17,&H16FA	;string "go?"
7656:	cal	&H75FD
7659:	jr	z,&H7672
765B:	pre	ix,&H1698	;last address in the object code
765F:	sbcw	(ix+$sx),$6
7661:	jr	c,&H764F	;ask again if the specified address invalid
7663:	ldw	$0,&H16AF
7667:	stw	&HFFFF,($sz)	;GR4<-&HFFFF
766B:	cal	&H7B7B		;IX<-&H169A
766E:	stiw	$6,(ix+$sx)	;PC<-specified address
7670:	std	$31,(ix+$sy)
; key [EXE] pressed in the menu "Assemble" after successful assembly - run the
; object code from the beginning
7672:	cal	&H7C05
7675:	cal	&H7B7B		;IX<-&H169A
7678:	ldw	$19,(ix+$sx)
767A:	pre	ix,&H1698	;last address in the object code
767E:	sbcw	(ix+$sx),$19
7680:	ld	$2,&H02		;index of the acronym "AD"
7683:	jp	c,&H7990	;report a run-time error
7686:	pre	ix,&H169D
768A:	ldm	$0,(ix+$sx),4
768D:	anc	$0,$sy
768F:	ld	$0,$sx
7691:	jr	nz,&H769E	;skip if no breakpoint set
7693:	sbc	$1,$sy
7695:	jr	nz,&H769E
7697:	sbcw	$2,$19		;compare the PC with the breakpoint address
769A:	jr	nz,&H769E	;skip if they aren't equal
769C:	ld	$0,$sy
769E:	std	$0,(ix+$sx)	;flag "breakpoint was reached"
76A0:	jp	z,&H7378
76A3:	cal	&H29C5		;test the power switch and BRK key
76A6:	cal	&H77DE		;convert an address $19,$20 to a pointer IX
76A9:	ldim	$17,(ix+$sx),4
76AC:	sbc	$18,&H90	;EXIT?
76AF:	jp	z,&H73CA
76B2:	sbc	$18,&H91	;IN?
76B5:	jp	z,&H77A6
76B8:	sbc	$18,&H92	;OUT?
76BB:	jp	z,&H7755
76BE:	sbc	$18,$sx
76C0:	jr	uz,&H7730	;CD error
76C2:	ld	$29,&H08
76C5:	cal	&H7A2F		;search the mnemonic table for the opcode $18
76C8:	jr	nz,&H7730	;CD error if not found
76CA:	pre	ix,&H16A7
76CE:	didw	$17
76D0:	did	$16
76D2:	sbc	$16,&H05	;XR index
76D5:	jr	nc,&H7730	;CD error
76D7:	sbw	$2,$2
76DA:	sbc	$16,$sx
76DC:	jr	z,&H76E3	;skip if no XR specified
76DE:	biu	$16
76E0:	ldw	$2,(ix+$16)	;$2,$3 = contents of the XR register
76E3:	adw	$19,$2		;$19,$20 = effective address
76E6:	ldw	$0,$19
76E9:	adw	$0,$sz		;offset = 2 * effective address
76EB:	cal	&H7736		;is address $19,$20 in the range &HFF70-&HFF7F?
76EE:	jr	nc,&H770A	;branch if so
76F0:	sbc	$1,&HFF		;is the stack accessed?
76F3:	jr	nz,&H76FC	;branch if not
76F5:	ldw	$14,&H1BDF	;starting address of the stack buffer
76F9:	ld	$1,$sx,jr &H770A	;upper byte of the offset = 0
76FC:	sbc	$11,&H11	;ST?
76FF:	jr	nz,&H770A	;skip if not
7701:	pre	iz,&H1698	;last address in the object code
7705:	sbcw	(iz+$sx),$19
7707:	jp	c,&H7680	;AD error
770A:	adw	$14,$sz		;address of the buffer + offset
770C:	sbc	$17,&H05	;GR index
770F:	jr	nc,&H7730	;CD error
7711:	biu	$17
7713:	ldd	$0,(ix+$17)	;IX<-IX+2*index, pointer to the GR storage
7716:	didw	$18		;$18 <- upper nibble of the operation code
7718:	sb	$18,$sy
771A:	biu	$18
771C:	pre	iz,&H7CF1	;addresses of instruction handler procedures
7720:	gst	ua,$2
7722:	pst	ua,&H04
7725:	ldw	$0,(iz+$18)
7728:	pst	ua,$2
772A:	pre	iz,$14		;IZ = pointer to memory corresponding to the EA
772C:	did	$17		;operation code
772E:	jp	$0

7730:	ld	$2,&H00
7733:	jp	&H7990

; is the effective address $19,$20 in the range &HFF70-&HFF7F?
7736:	pre	iz,&H168D
773A:	std	$31,(iz+$sx)
773C:	ldw	$4,&HFF70
7740:	sbcw	$19,$4
7743:	rtn	c
7744:	ldw	$4,&H0080
7748:	adcw	$19,$4
774B:	rtn	c
; the effective address is in the range &HFF70-&HFF7F
774C:	std	$30,(iz+$sx)	;flag
774E:	ldw	$0,$19		;offset = effective address
7751:	sbw	$14,$14		;starting address of the object code = &H0000
7754:	rtn

; operation code &H9200 - OUT
7755:	ldm	$19,(ix+$sx),4
7758:	cal	&H77D3		;convert a pair of addresses to pointers
775B:	ldw	$21,($21)	;string length
775E:	cal	&H7AFF		;test the Print on/off switch
7761:	jr	z,&H7774	;branch if Print off
; printer
7763:	cal	&H2989		;select the printer as the output device
7766:	sbw	$21,$sy
7768:	jr	c,&H7785
776A:	ldiw	$16,(iz+$sx)
776C:	cal	&H2AF1		;display character $16
776F:	cal	&H29C5		;test the power switch and BRK key
7772:	jr	&H7766
; LCD
7774:	sbw	$21,$sy
7776:	jr	c,&H7782
7778:	ldiw	$16,(iz+$sx)
777A:	cal	&H2AF1		;display character $16
777D:	cal	&H29C5		;test the power switch and BRK key
7780:	jr	&H7774
7782:	cal	&H655F		;wait for a key, convert to upper case
7785:	cal	&H2AE8		;OUTCR, display CR-LF
7788:	cal	&H2991		;select the LCD as the output device
778B:	cal	&H7B7B		;IX<-&H169A
778E:	ldw	$19,(ix+$sx)
7790:	ldw	$0,&H0004
7794:	adw	$19,$sz
7796:	cal	&H7B7B		;IX<-&H169A
7799:	ldw	$17,(ix+$sx)
779B:	stw	$19,(ix+$sx)
779D:	cal	&H7AF8		;test the Trace mode
77A0:	cal	nc,&H7AE3
77A3:	jp	&H7675

; operation code &H9100 - IN
77A6:	ldm	$0,(ix+$sx),4
77A9:	phsm	$3,4
77AC:	cal	&H2002
77AF:	cal	&H975E
77B2:	gre	iz,$12
77B4:	ppsm	$19,4
77B7:	cal	&H77D3		;convert a pair of addresses to pointers
77BA:	pre	ix,$12
77BC:	sbbm	$5,$5,3
; this loop copies up to 80 characters from the EDTOP buffer to the address
; specified by the first IN operand
77BF:	sbc	$6,&H50
77C2:	jr	z,&H77CF
77C4:	ldi	$4,(ix+$sx)
77C6:	sbc	$4,$sx
77C8:	jr	z,&H77CF
77CA:	stiw	$4,(iz+$sx)
77CC:	ad	$6,$sy,jr &H77BF	;next character
77CF:	stw	$6,($21),jr &H7785	;store the string length

; conversion of a pair of CASL addresses in $19,$20 and $21,$22 to memory
; pointers IZ and IX
77D3:	cal	&H77DE		;convert an address $19,$20 to a pointer IX
77D6:	biuw	$21
77D8:	adw	$21,$14
77DB:	pre	iz,$2
77DD:	rtn

; conversion of a CASL address in $19,$20 to a memory pointer IX
77DE:	pre	ix,&H1696
77E2:	ldw	$2,(ix+$sx)	;begin of the object code
77E4:	ldw	$14,(ix+$sx)
77E6:	ldw	$0,$19
77E9:	biuw	$0
77EB:	adw	$2,$sz
77ED:	pre	ix,$2
77EF:	rtn

77F0:	sb	$0,&H30
77F3:	jr	c,&H7841
77F5:	sbc	$0,&H05
77F8:	rtn	nc
77F9:	ldd	$1,(iz+$sy)
77FB:	jr	&H7816
77FD:	ldw	$0,(iz+$sx)
77FF:	ldw	$2,&H5247
7803:	sbcw	$2,$sz
7805:	jr	nz,&H77F0
7807:	ld	$0,(iz+&H02)
780A:	sb	$0,&H30
780D:	jr	c,&H7841
780F:	sbc	$0,&H05
7812:	rtn	nc
7813:	ldd	$1,(iz+&H03)
7816:	sbc	$31,$sy
7818:	rtn
7819:	cal	&H00CD		;test for '#'
781C:	jr	z,&H7833
781E:	ld	$4,$sz
7820:	sbc	$0,&H2D
7823:	cal	z,&H004D
7826:	cal	&H1EE6
7829:	jr	c,&H7841
782B:	sbc	$4,&H2D
782E:	jr	nz,&H7816
7830:	cmpw	$17,jr &H7816
7833:	sbw	$17,$17
7836:	cal	&H0049
7839:	cal	&H009D
783C:	rtn	nc
783D:	sbc	$18,$sx
783F:	jr	uz,&H7844
7841:	sbc	$31,$sx		;Zero flag
7843:	rtn
7844:	diuw	$17
7846:	or	$17,$sz
7848:	ldd	$0,(iz+$sy)
784A:	cal	&H009D
784D:	jr	nc,&H7816
784F:	jr	&H783D

7851:	ldw	$19,(ix+$sx)	;contents of a GR register
7853:	ldw	$0,(iz+$sx)	;contents of the effective address in bank 1
7855:	gre	ix,$2
7857:	pre	ix,&H168D
785B:	sbc	(ix+$sx),$30	;is address $19,$20 in the range &HFF70-&HFF7F?
785D:	pre	ix,$2
785F:	rtn	nz		;return if not
; otherwise read the contents of the effective address from bank 3
7860:	pst	ua,&HF4
7863:	ldd	$0,(iz+$sx)	;lower byte
7865:	pst	ua,&H54
7868:	ld	$1,$sx		;upper byte = 0
786A:	rtn

786B:	pre	ix,&H16B1
786F:	std	$30,(ix+$sx)
7871:	sbcw	$19,$sy
7873:	rtn	c
7874:	adcw	$19,$19
7877:	jr	c,&H787C
7879:	std	$31,(ix+$sx)
787B:	rtn
787C:	ad	(ix+$sx),$30
787E:	rtn

; operation code &H2xxx - ADD, SUB
787F:	cal	&H7851
7882:	sbc	$17,$sy
7884:	jr	z,&H7889
7886:	adw	$19,$sz,jr &H78EB
7889:	sbw	$19,$sz,jr &H78EB

; operation code &H3xxx - AND, OR, EOR
788C:	cal	&H7851
788F:	sbc	$17,$sy
7891:	jr	c,&H7898
7893:	jr	nz,&H789B
7895:	orw	$19,$sz,jr &H78EB
7898:	anw	$19,$sz,jr &H78EB
789B:	xrw	$19,$sz,jr &H78EB

; operation code &H4xxx - CPA, CPL
789E:	cal	&H7851
78A1:	sbc	$17,$sy
78A3:	jr	z,&H78AB
78A5:	ad	$20,&H80
78A8:	ad	$1,&H80
78AB:	pre	ix,&H16B1
78AF:	std	$30,(ix+$sx)
78B1:	sbw	$19,$sz
78B3:	cal	nz,&H7877
78B6:	jr	&H78F0

; operation code &H7xxx - PUSH, POP
78B8:	ldw	$21,$19
78BB:	cal	&H795B		;operation on the stack
78BE:	sbc	$17,$sy
78C0:	jr	nz,&H78F0
78C2:	jr	&H78C9

; operation code &H10xx - LD
78C4:	cal	&H7851
78C7:	ldw	$19,$sz
78C9:	stw	$19,(ix+$sx)
78CB:	jr	&H78F0		;don't affect the Flag Register

; operation code &H11xx - ST
78CD:	ldw	$0,(ix+$sx)
78CF:	pre	ix,&H168D
78D3:	sbc	(ix+$sx),$30	;is address $19,$20 in the range &HFF70-&HFF7F?
78D5:	jr	nz,&H78E1	;branch if not
; write to bank 3
78D7:	pst	ua,&HF4
78DA:	std	$0,(iz+$sx)
78DC:	pst	ua,&H54
78DF:	jr	&H78F0		;don't affect the Flag Register
; write to bank 1
78E1:	stw	$0,(iz+$sx)
78E3:	jr	&H78F0

; operation code &H1xxx - LD, ST, LEA
78E5:	sbc	$17,$sy
78E7:	jr	c,&H78C4	;LD
78E9:	jr	z,&H78CD	;ST
78EB:	stw	$19,(ix+$sx)	;store the result to a GR register
78ED:	cal	&H786B		;set the Flag Register
78F0:	cal	&H7B7B		;IX<-&H169A
78F3:	ldw	$19,(ix+$sx)
78F5:	adw	$19,$sy
78F7:	adw	$19,$sy,jr &H7906

; operation code &H8xxx - CALL, RET
78FA:	cal	&H7B7B		;IX<-&H169A
78FD:	ldw	$21,(ix+$sx)
78FF:	adw	$21,$sy
7901:	adw	$21,$sy
7903:	cal	&H795B		;operation on the stack
7906:	jp	&H7796

; operation code &H5xxx - SLA, SRA, SLL, SRL
7909:	sbc	$20,$sy
790B:	jr	c,&H790F
790D:	na	$19,$sx
790F:	bydw	$19
7911:	ldw	$19,(ix+$sx)
7913:	sbw	$0,$sz
7915:	naw	$2,$sz
7917:	anc	$17,&H02
791A:	jr	nz,&H7924
791C:	ld	$1,$20
791F:	an	$1,&H80
7922:	bidw	$3
7924:	sb	$18,$sy
7926:	jr	c,&H78EB
7928:	anc	$17,$sy
792A:	jr	nz,&H7934
792C:	biuw	$19
792E:	anw	$19,$2
7931:	orw	$19,$sz,jr &H7924
7934:	bidw	$20,jr &H792E

; operation code &H6xxx - JPZ, JMI, JNZ, JZE, JMP
7937:	pre	ix,&H16B1
793B:	ldd	$0,(ix+$sx)
793D:	sbc	$17,&H03
7940:	jr	z,&H7951
7942:	jr	nc,&H794F
7944:	sbc	$17,$sy
7946:	jr	c,&H7954
7948:	jr	nz,&H7958
794A:	sbc	$0,&H02
794D:	jr	nz,&H78F0
794F:	jr	&H7906
7951:	sbc	$0,$sy,jr &H794D
7954:	anc	$0,&H02,jr &H794D
7958:	anc	$0,$sy,jr &H794D

; if $17=0 then push word $21,$22 to the stack,
; else pop word $19,$20 from the stack
795B:	pre	iz,&H16AF
795F:	ldw	$0,(iz+$sx)	;register GR4
7961:	ldw	$4,$sz
7963:	ldw	$2,&HFF80
7967:	sbw	$0,$2
796A:	jr	c,&H798D	;ST error
; the stack of size &H80 words occupies the User Stack area
796C:	biuw	$0
796E:	ldw	$2,&H1BDF
7972:	adw	$2,$sz		;pointer to the memory
7974:	sbc	$17,$sx		;push or pop?
7976:	jr	nz,&H7989
; push
7978:	sb	$4,$sy		;decrement GR4
797A:	sbc	$4,&H80
797D:	jr	c,&H798D	;ST error
797F:	stw	$4,(iz+$sx)
7981:	pre	iz,$2
7983:	ldd	$0,(iz-&H02)
7986:	stw	$21,(iz+$sx)
7988:	rtn
; pop
7989:	ad	$4,$sy		;increment GR4
798B:	jr	nc,&H79AA
; stack overflow/underflow
798D:	ld	$2,&H04		;index of the acronym "ST"
; report a run-time error
7990:	phs	$2
7992:	cal	&H6549
7995:	pps	$0		;index to the table of string addresses
7997:	pre	ix,&H16D1	;table of string addresses
799B:	cal	&H651B		;display a string from bank 2
799E:	cal	&H7B94		;display the PC value and an optional label
79A1:	cal	&H6543
79A4:	cal	&H655F		;wait for a key, convert to upper case
79A7:	jp	&H73D5
;
79AA:	stw	$4,(iz+$sx)
79AC:	pre	iz,$2
79AE:	ldw	$19,(iz+$sx)
79B0:	rtn

79B1:	or	$29,&H02
79B4:	cal	&H7347		;add an entry to the symbol table
79B7:	jr	&H7A08
; parse the label field and the operation field
79B9:	an	$29,&HFD
79BC:	cal	&H736A		;end of statement?
79BF:	rtn	z		;return if so
; label field
79C0:	cal	&H72EB		;fetch a label pointed to by IZ to $8-$13
79C3:	jp	z,&H7A29	;skip if the label field is empty
79C6:	anc	$29,&H04
79C9:	ld	$2,$sx		;index of the acronym "LA"
79CB:	jr	z,&H7A21	;LA error if no label found
79CD:	sbc	$29,&H10
79D0:	jr	uz,&H7A08
79D2:	jr	c,&H79B1
79D4:	pre	ix,$25		;pointer to the top of the symbol table
79D6:	ldm	$0,(ix+$sx),6	;global label of the current block
79D9:	xrcm	$8,$sz,6	;local label cannot be the same
79DC:	jr	z,&H79C9	;otherwise LA error
79DE:	sbc	$29,&H30
79E1:	jr	uz,&H7A08	;skip if there's no undefined START operand
79E3:	pre	ix,&H165E
79E7:	ldim	$0,(ix+$sx),7	;$1-$6 = START operand
79EA:	xrcm	$8,$1,6		;compare with the local label
79ED:	jr	nz,&H7A08	;skip if they don't match
79EF:	sbcw	(ix+$sx),$30	;address of the block
79F1:	jr	nc,&H79F9	;skip if not &H0000 (i.e. not the first block)
79F3:	pre	ix,&H1694
79F7:	stw	$21,(ix+$sx)	;default execution address = location counter
79F9:	an	$29,&H3F	;the START operand is no longer undefined
79FC:	anc	$0,&H02		;was an entry added to the symbol table?
79FF:	jr	z,&H7A08	;skip if not (superfluous safety measure)
; change the value of the last global symbol to the value of the START operand
7A01:	pre	ix,$25		;pointer to the top of the symbol table
7A03:	ldd	$0,(ix+&H06)	;IX<-IX+6, skip the label field
7A06:	stw	$21,(ix+$sx)	;replace the value with the location counter
; operation field
7A08:	cal	&H00A9		;is next character a letter?
7A0B:	jr	nc,&H7A1E	;branch if not
7A0D:	ldm	$0,(iz+$sx),5
7A10:	cal	&H7A2F		;search the mnemonic table for a string $0-$4
7A13:	jr	nz,&H7A1E	;OC error if not found
7A15:	ldd	$0,(iz+$5)	;IZ <- IZ+mnemonic_length
7A18:	cal	&H0049		;NEXTC, get next character other than space
7A1B:	sbc	$30,$sx		;Not Zero flag
7A1D:	rtn

7A1E:	ld	$2,&H08		;index of the acronym "OC"
7A21:	ppsw	$0
7A23:	cal	&H7280		;report an assembly error
7A26:	jp	&H7099

7A29:	cal	&H7367		;test for an end of a statement
7A2C:	rtn	z
7A2D:	jr	&H7A08

; search the mnemonic table, Zero if found
; if bit 3 of register $29 is cleared then
;   $11 <- opcode of the mnemonic in $0-$4
; else
;   IX <- mnemonic of the opcode $18
7A2F:	pre	ix,&H1613	;table of CASL mnemonics and opcodes
7A33:	pst	ua,&H24
7A36:	sbbm	$5,$5,6
; fetch the mnemonic from the table to $10-$14, right aligned
7A39:	bydm	$10,5
7A3C:	ldi	$10,(ix+$sx)
7A3E:	ad	$5,$sy		;mnemonic length
7A40:	anc	$10,&H80	;last character of the keyword?
7A43:	jr	z,&H7A39	;loop if not
7A45:	sb	$10,&H80	;get rid of the of the last character mark
7A48:	ldi	$11,(ix+$sx)	;opcode
7A4A:	anc	$29,&H08
7A4D:	jr	nz,&H7A72
7A4F:	sbc	$5,&H04
7A52:	jr	z,&H7A66	;branch if mnemonic length = 4
7A54:	jr	nc,&H7A6A	;branch if mnemonic length = 5
7A56:	anc	$5,$sy
7A58:	jr	nz,&H7A6E	;branch if mnemonic length = 3
7A5A:	sbcw	$9,$sz		;comparison, mnemonic length = 2
7A5C:	pst	ua,&H54
7A5F:	rtn	z		;mnemonic found, Zero flag
7A60:	sbc	$11,&H02	;end of the mnemonic table?
7A63:	jr	nc,&H7A33	;loop if not
7A65:	rtn			;mnemonic not found, Not Zero flag
; comparison of strings
7A66:	xrcm	$7,$sz,4,jr &H7A5C	;mnemonic length = 4
7A6A:	xrcm	$6,$sz,5,jr &H7A5C	;mnemonic length = 5
7A6E:	xrcm	$8,$sz,3,jr &H7A5C	;mnemonic length = 3
; comparison of opcodes
7A72:	sbc	$11,$18,jr &H7A5C

; advance the Location Counter $21,$22 by the instruction size
7A76:	ldw	$17,&H0002	;size of most instructions
7A7A:	sbc	$11,&H07	;instruction opcode
7A7D:	jr	z,&H7AA7	;DS
7A7F:	jr	nc,&H7AAB
7A81:	sbc	$11,&H03
7A84:	jr	z,&H7AAB	;EXIT
7A86:	jr	c,&H7A1B	;if START or END then return with Not Carry
7A88:	sbc	$11,&H06
7A8B:	jr	nz,&H7AAF	;IN, OUT
; DC
7A8D:	sbc	$0,&H27		;apostrophe? (begin of a string)
7A90:	ldw	$17,$sy
7A92:	jr	nz,&H7AAB	;branch if not
; determine the string length
7A94:	gre	iz,$2
7A96:	ld	$17,$sx
7A98:	ldd	$0,(iz+$sy)
7A9A:	sbc	$0,&H27		;apostrophe? (end of a string)
7A9D:	jr	z,&H7AB3
7A9F:	cal	&H7370		;premature end_of_line or end_of_file?
7AA2:	jr	z,&H7AB3	;branch if so
7AA4:	ad	$17,$sy,jr &H7A98
; the operand of DS must be a decimal number
7AA7:	cal	&H1EE6		;$17,$18 <- value of ASCII decimal number
7AAA:	rtn	c
7AAB:	adw	$21,$17	;add the instruction size to the location counter
7AAE:	rtn
; IN, OUT
7AAF:	ld	$17,&H04,jr &H7AAB
7AB3:	pre	iz,$2,jr &H7AAB

; display hexadecimal word $17,$18
7AB6:	ldw	$14,$17,jr &H7ABC
; display hexadecimal the word pointed to by the $0,$1 register pair
7ABA:	ldw	$14,($sz)
; display hexadecimal word $14,$15
7ABC:	ld	$10,&H04	;counter of digits
; this loop expands the hexadecimal number and displays the digits
7ABF:	dium	$14,3		;shift the next digit to $16
7AC2:	an	$16,&H0F	;separate the top digit
; conversion of digit $16 to HEX ASCII
7AC5:	sbc	$16,&H0A
7AC8:	jr	c,&H7ACD	;skip if digit in range 0..9
7ACA:	ad	$16,&H07	;digit in range A..F
7ACD:	phsm	$15,6
7AD0:	cal	&H7BD7		;display character $16 + '0'
7AD3:	ppsm	$10,6
7AD6:	sb	$10,$sy		;decrement the digit counter
7AD8:	jr	nz,&H7ABF	;next digit
7ADA:	rtn

; next line of the source code
7ADB:	cal	&H0B7E		;move pointer IZ to the next line
7ADE:	adw	$19,$sy		;increment the line counter
7AE0:	ldd	$0,(iz+$sx)
7AE2:	rtn

7AE3:	cal	nz,&H2989	;select the printer as the output device
7AE6:	cal	&H7B3F
7AE9:	cal	&H7BA7
7AEC:	cal	&H7AF8		;test the Trace mode
7AEF:	cal	z,&H655F	;wait for a key, convert to upper case
7AF2:	cal	&H2AE8		;OUTCR, display CR-LF
7AF5:	jp	&H2991		;select the LCD as the output device

; test the Trace mode
7AF8:	pre	ix,&H169C
7AFC:	sbc	(ix+$sx),$30
7AFE:	rtn	c
; test the Print on/off switch
7AFF:	pre	ix,&H16B3
7B03:	sbc	(ix+$sx),$31
7B05:	rtn

7B06:	ldw	$17,&H1785	;string "PC:"
7B0A:	cal	&H6549
7B0D:	cal	&H6520		;display a string from bank 2
7B10:	jr	&H7B18

7B12:	ld	$2,&H10
7B15:	cal	&H72B5
7B18:	cal	&H7B7B		;IX<-&H169A
7B1B:	ldw	$19,(ix+$sx)
7B1D:	ldw	$17,$19
7B20:	cal	&H7AB6
7B23:	cal	&H7B50
7B26:	cal	&H7313
7B29:	rtn	z
7B2A:	ld	$14,&H06
7B2D:	gre	ix,$0
7B2F:	pre	iz,$0
7B31:	ldi	$16,(iz+$sx)
7B33:	phs	$14
7B35:	cal	&H2AF1		;display character $16
7B38:	pps	$14
7B3A:	sb	$14,$sy
7B3C:	jr	nz,&H7B31
7B3E:	rtn

; display address $17,$18 and the name of an optional label
7B3F:	cal	&H7AB6		;display hexadecimal word $17,$18
7B42:	cal	&H7B50		;display two spaces
; display the name of an optional label
7B45:	cal	&H7313		;$0-$5 <- name of a label with a value $17,$18
7B48:	jr	nz,&H7B56
7B4A:	cal	&H7B50		;display two spaces
7B4D:	cal	&H7B50		;display two spaces
7B50:	cal	&H2AD7		;display a space
7B53:	jp	&H2AD7		;display a space
7B56:	ldw	$14,&H0006	;name length
7B5A:	gre	ix,$0
7B5C:	pre	iz,$0
7B5E:	ldi	$16,(iz+$sx)
7B60:	sbc	$16,&H20
7B63:	jr	nc,&H7B68
7B65:	ad	$15,$sy,jr &H7B6F
7B68:	phsw	$15
7B6A:	cal	&H2AF1		;display character $16
7B6D:	ppsw	$14
7B6F:	sb	$14,$sy
7B71:	jr	nz,&H7B5E
7B73:	sb	$15,$sy
7B75:	rtn	c
7B76:	cal	&H2AD7		;display a space
7B79:	jr	&H7B73

7B7B:	pre	ix,&H169A	;Program Counter
7B7F:	rtn

; display a colon
7B80:	ld	$16,&H3A,jr &H7BDA

7B84:	sb	$29,$sy
; display a comma
7B86:	ld	$16,&H2C,jr &H7BDA

; display a string 'GR'
7B8A:	ld	$16,&H47	;'G'
7B8D:	cal	&H2AF1		;display character $16
7B90:	ld	$16,&H52,jr &H7BDA	;display 'R'

; display the 'PC' string, PC value and the name of an optional label
7B94:	ldw	$17,&H1785	;string 'PC:'
7B98:	cal	&H6520		;display a string from bank 2
7B9B:	cal	&H7B18
7B9E:	cal	&H2AE8		;OUTCR, display CR-LF
7BA1:	cal	&H7B4A
7BA4:	cal	&H7B4A
7BA7:	cal	&H7C16		;disassemble an instruction at address $17,$18
7BAA:	cal	&H2AD7		;display a space
7BAD:	sb	$29,$sy
7BAF:	jr	nz,&H7BAA
7BB1:	cal	&H299A
7BB4:	sbc	$1,&H02
7BB7:	jr	nz,&H7BBF
7BB9:	cal	&H7B4D		;display four spaces
7BBC:	cal	&H7B4D		;display four spaces
7BBF:	ld	$29,&H05
7BC2:	pre	iz,&H16A7
7BC6:	ldiw	$14,(iz+$sx)
7BC8:	cal	&H7ABC
7BCB:	cal	&H2AD7		;display a space
7BCE:	sb	$29,$sy
7BD0:	jr	nz,&H7BC6
7BD2:	ldd	$16,(iz+$sx)
7BD4:	an	$16,&H03
7BD7:	ad	$16,&H30
7BDA:	jp	&H2AF1		;display character $16

7BDD:	ldw	$2,&H070A
7BE1:	cal	&H031D
7BE4:	cal	&H293B
7BE7:	jr	z,&H7BEC
7BE9:	ld	$3,&H03
7BEC:	sb	$2,$sy
7BEE:	rtn	c
7BEF:	phsw	$3
7BF1:	ld	$16,&H20
7BF4:	cal	&H2AF4
7BF7:	ppsw	$2
7BF9:	ldw	$0,&H1101
7BFD:	ld	$0,($sz)
7BFF:	an	$0,$3
7C02:	jr	nz,&H7BEC
7C04:	rtn
7C05:	cal	&H9338
7C08:	jp	&H92F5
7C0B:	ldw	$0,&H168E
7C0F:	ldw	$2,&H002B
7C13:	jp	&H0157		;CLRME, clear memory block

; disassemble an instruction at address $17,$18
7C16:	cal	&H2AD7		;display a space
7C19:	ldw	$19,$17
7C1C:	cal	&H77DE		;convert an address $19,$20 to a pointer IX
7C1F:	ldim	$17,(ix+$sx),8
7C22:	pst	ua,&H24
7C25:	pre	ix,&H158C	;table of CASL opcodes and mnemonics
; search the table for an opcode $18
7C29:	ldim	$25,(ix+$sx),5
7C2C:	sbc	$25,$18
7C2F:	jr	z,&H7C35
7C31:	sbc	$25,$sx
7C33:	jr	nz,&H7C29
7C35:	pst	ua,&H54
; display the mnemonic $26-$29
7C38:	ld	$16,$26
7C3B:	cal	&H2AF1		;display character $16
7C3E:	ld	$16,$27
7C41:	cal	&H2AF1		;display character $16
7C44:	ld	$16,$28
7C47:	cal	&H2AF1		;display character $16
7C4A:	ld	$16,$29
7C4D:	cal	&H2AF1		;display character $16
7C50:	cal	&H2AD7		;display a space
; display the operands
7C53:	ld	$29,&H13
7C56:	sbc	$18,&H90
7C59:	rtn	z		;EXIT
7C5A:	jr	c,&H7C6E
; IN, OUT
7C5C:	ldw	$14,$21
7C5F:	cal	&H7C68		;display hexadecimal word $14,$15
7C62:	cal	&H7B84		;display a comma
7C65:	ldw	$14,$23
7C68:	sb	$29,&H04
7C6B:	jp	&H7ABC		;display hexadecimal word $14,$15
7C6E:	sbc	$18,&H81
7C71:	rtn	z		;RET
7C72:	sbc	$18,&H71
7C75:	jr	nz,&H7C7A
; POP
7C77:	did	$17,jr &H7C9E
7C7A:	sbc	$18,&H60
7C7D:	jr	nc,&H7C92	;skip for jumps, PUSH, CALL
7C7F:	sbc	$17,&H50
7C82:	jr	nc,&H7CC1
; GR register
7C84:	cal	&H7B8A		;display a string 'GR'
7C87:	ld	$16,$17
7C8A:	did	$16		;GR field
7C8C:	cal	&H7CAC		;display character $16 + '0'
7C8F:	cal	&H7B84		;display a comma
; address
7C92:	ldw	$14,$19		;adr field
7C95:	cal	&H7C68		;display hexadecimal word $14,$15
; optional XR register
7C98:	sbc	$17,$sx
7C9A:	rtn	lz		;return if XR=0
7C9B:	cal	&H7B84		;display a comma
7C9E:	an	$17,&H0F
7CA1:	sbc	$17,&H05
7CA4:	jr	nc,&H7CB2	;display '***'
7CA6:	cal	&H7B8A		;display a string 'GR'
7CA9:	ld	$16,$17
7CAC:	sb	$29,&H03
7CAF:	jp	&H7BD7		;display character $16 + '0'
;
7CB2:	sb	$29,&H03
7CB5:	ld	$16,&H2A	;'*'
7CB8:	cal	&H2AF1		;display character $16
7CBB:	cal	&H2AF1		;display character $16
7CBE:	jp	&H2AF1		;display character $16
;
7CC1:	cal	&H7CB2		;display '***'
7CC4:	jr	&H7C8F

7CC6:	cal	&H0AB2
7CC9:	ld	$13,$sy
7CCB:	orcm	$14,$14,3
7CCE:	jr	z,&H7CDD
7CD0:	ld	$13,&H05
7CD3:	sbc	$16,$sy
7CD5:	jr	nc,&H7CDD
7CD7:	dium	$14,3
7CDA:	sb	$13,$sy,jr &H7CD3
7CDD:	phsm	$16,4
7CE0:	an	$16,&H0F
7CE3:	cal	&H7BD7
7CE6:	ppsm	$13,4
7CE9:	dium	$14,3
7CEC:	sb	$13,$sy
7CEE:	jr	nz,&H7CDD
7CF0:	rtn

; addresses of handler procedures for instructions with operation codes
; &H1xxx, &H2xxx, ... , &H7xxx, &H8xxx
7CF1:	dw	78E5, 787F, 788C, 789E
7CF9:	dw	7909, 7937, 78B8, 78FA


; *** Floppy disk routines ***

; wait until the FDD operation is complete
7D01:	cal	&H7D42		;read the FDD status register to $0
7D04:	anc	$0,&H08
7D07:	jr	z,&H7D01
7D09:	rtn

; write a byte &HFF to the FDD
7D0A:	ld	$0,&HFF,jr &H7D17
; write a word $8,$9 to the FDD
7D0E:	ld	$0,$8
7D11:	cal	&H7D17
7D14:	ld	$0,$9
; write a byte $0 to the FDD
7D17:	pre	ix,&HFFFE
7D1B:	gst	ua,$1
7D1D:	pst	ua,&H34
7D20:	std	$0,(ix+$sx)
7D22:	pst	ua,$1
7D24:	cal	&H7D42		;read the FDD status register to $0
7D27:	anc	$0,&H02
7D2A:	jr	z,&H7D24	;wait until the FDD reads the data byte
7D2C:	rtn

; read a byte from the FDD to $0
7D2D:	cal	&H7D42		;read the FDD status register to $0
7D30:	anc	$0,$sy
7D32:	jr	nz,&H7D2D	;wait until the FDD sends the data byte
7D34:	pre	ix,&HFFFE
7D38:	gst	ua,$1
7D3A:	pst	ua,&H34
7D3D:	ldd	$0,(ix+$sx)
7D3F:	pst	ua,$1
7D41:	rtn

; read the FDD status register to $0
7D42:	pre	ix,&HFFFF
7D46:	gst	ua,$1
7D48:	pst	ua,&H34
7D4B:	ldd	$0,(ix+$sx)
7D4D:	anc	$0,&H10		;error flag asserted?
7D50:	jr	nz,&H7D3F
; an error has occurred
7D52:	pre	ix,&HFFFE
7D56:	ldd	$0,(ix+$sx)	;read and discard the FDD data register
7D58:	ldd	$0,(ix+$sy)	;FDD status register
7D5A:	anc	$0,$sy
7D5C:	jr	z,&H7D52	;loop until all data bytes from FDD are read
7D5E:	ld	$0,&H02		;FDD command &H02: get the error code
7D61:	std	$0,(ix+$sx)	;FDD command register
7D63:	pst	ua,$1
7D65:	cal	&H7D2D		;read a byte from the FDD to $0
7D68:	an	$0,&H0F
7D6B:	ld	$29,$sz
7D6D:	cal	&H7D01		;wait until the FDD operation is complete
7D70:	ld	$0,$29
7D73:	pre	ix,&H8071	;table of FDD error messages
7D77:	pst	ua,&H04
7D7A:	ad	$0,$sz
7D7C:	ldw	$2,(ix+$sz)
7D7E:	pst	ua,&H54
7D81:	jp	$2

7D83:	ldw	$10,&H1775
7D87:	jr	&H7D8D

7D89:	ldw	$10,&H165E	;WORK1
7D8D:	ldw	$8,&H000B
; write $8,$9 bytes from address $10,$11 to the FDD
7D91:	pre	ix,$10
7D93:	sbw	$8,$sy
7D95:	rtn	c
7D96:	ldi	$0,(ix+$sx)
7D98:	gre	ix,$10
7D9A:	cal	&H7D17		;write a byte $0 to the FDD
7D9D:	jr	&H7D91

; read $8,$9 bytes from the FDD to address $10,$11
7D9F:	sbw	$8,$sy
7DA1:	rtn	c
7DA2:	cal	&H7D2D		;read a byte from the FDD to $0
7DA5:	pre	ix,$10
7DA7:	sti	$0,(ix+$sx)
7DA9:	gre	ix,$10,jr &H7D9F

; send the command $0 to the FDD
7DAC:	pre	ix,&H16BF	;OPTCT, option code
7DB0:	sbc	(ix+$sx),$30
7DB2:	jr	z,&H7DE3	;NR Error
7DB4:	pre	ix,&HFFFF	;FDD control/status register
7DB8:	gst	ua,$1
7DBA:	pst	ua,&H34
7DBD:	ldd	$2,(ix+$sx)
7DBF:	anc	$2,&H10
7DC2:	jr	z,&H7DE3	;NR Error
7DC4:	std	$30,(ix+$sx)	;FDD command &H01: identification
7DC6:	ld	$3,$sx
7DC8:	ldd	$2,(ix+$sx)
7DCA:	sb	$3,$sy
7DCC:	jr	z,&H7DE3	;NR Error
7DCE:	anc	$2,$sy
7DD0:	jr	nz,&H7DC8
7DD2:	anc	$2,&H04
7DD5:	jr	z,&H7DC8
7DD7:	ld	$2,(ix-$sy)	;FDD data register, MD-120 unit returns &H01
7DD9:	adc	$2,$sy		;any value other than &HFF will do
7DDB:	jr	z,&H7DE3	;NR Error
7DDD:	ld	$3,$sx
7DDF:	ldd	$2,(ix+$sx)
7DE1:	sb	$3,$sy
7DE3:	jp	z,&H2B80	;NR Error, I/O device not ready
7DE6:	anc	$2,&H10
7DE9:	jr	z,&H7DDF
7DEB:	std	$0,(ix+$sx)
7DED:	pst	ua,$1
7DEF:	cal	&H7D42		;read the FDD status register to $0
7DF2:	anc	$0,&H04
7DF5:	jr	z,&H7DEF	;wait until the FDD reads the data byte
7DF7:	rtn

7DF8:	pre	ix,$15
7DFA:	ldw	$2,&H3A30	;"0:"
7DFE:	sbcw	(ix+$sx),$2
7E00:	rtn	nz
7E01:	sb	$17,&H02	;decrement the string length
7E04:	jp	c,&H2B88	;BF Error, improper filename
7E07:	ldiw	$2,(ix+$sx)	;IX<-IX+2, skip the device name "0:"
7E09:	rtn

; expand the filename of length $17, pointed to by $15,$16
7E0A:	ld	$10,$sx		;flag: allow wildcards
7E0C:	ldw	$0,&H165E	;destination pointer = WORK1
7E10:	cal	&H7DF8		;skip the optional device name "0:"
7E13:	phsw	$1
7E15:	ld	$2,&H08		;length of the base filename
7E18:	cal	&H7E4F		;expand the substring
7E1B:	ld	$2,&H03		;length of the extension
7E1E:	cal	&H7E4F		;expand the substring
7E21:	ppsw	$4
7E23:	sbc	$10,&H02	;flag: is an empty filename allowed?
7E26:	jr	c,&H7E44	;skip if not
; test if the filename is empty
7E28:	pre	ix,$4
7E2A:	ld	$1,&H0B
7E2D:	ldi	$0,(ix+$sx)
7E2F:	sbc	$0,&H20
7E32:	jr	nz,&H7E44
7E34:	sb	$1,$sy
7E36:	jr	nz,&H7E2D
; replace an empty filename with a string of '?' wildcards
7E38:	ldw	$0,&H0B3F	;$0='?', $1=number of question marks
7E3C:	pre	ix,$4
7E3E:	sti	$0,(ix+$sx)
7E40:	sb	$1,$sy
7E42:	jr	nz,&H7E3E
; throw an error if the filename is empty
7E44:	pre	ix,$4
7E46:	ldd	$0,(ix+$sx)
7E48:	sbc	$0,&H20
7E4B:	jp	z,&H2B88	;BF Error, improper filename
7E4E:	rtn

; expand a substring of a filename of length $17, pointed to by IX
; $0,$1=destination pointer, $2=length of the destination substring
7E4F:	ld	$4,&H20
; this loop copies the characters
7E52:	sbc	(ix+$sx),$31	;the source substring ends with a zero byte...
7E54:	jr	z,&H7E91
7E56:	ldi	$5,(ix+$sx)
7E58:	sb	$17,$sy
7E5A:	sbc	$5,&H2E		;...or with a dot
7E5D:	jr	z,&H7E85
7E5F:	anc	$10,$sy		;flag: are wildcards allowed?
7E61:	jr	nz,&H7E6D	;skip if not
7E63:	sbc	$5,&H2A		;'*'
7E66:	jr	z,&H7E8D
7E68:	sbc	$5,&H3F		;'?'
7E6B:	jr	z,&H7E70
7E6D:	cal	&H7EB7		;is character $5 is allowed in a file name?
7E70:	st	$5,($sz)
7E72:	adw	$0,$sy		;advance the destination pointer
7E74:	sb	$2,$sy		;counter of stored characters
7E76:	jr	nz,&H7E52
; move the pointer IX to the end of the source substring
7E78:	sbc	(ix+$sx),$31	;the source substring ends with a zero byte...
7E7A:	jr	z,&H7E91
7E7C:	ldi	$5,(ix+$sx)
7E7E:	sb	$17,$sy
7E80:	sbc	$5,&H2E		;...or with a dot
7E83:	jr	nz,&H7E78
; pad the destination substring with the character $4 (space or question mark)
7E85:	sb	$2,$sy		;counter of stored characters
7E87:	rtn	c
7E88:	st	$4,($sz)
7E8A:	adw	$0,$sy,jr &H7E85
; wildcard '*' in the source substring: pad the destination substring with '?'
7E8D:	ld	$4,&H3F,jr &H7E78
7E91:	sbc	$17,$sx
7E93:	jr	z,&H7E85
7E95:	jp	&H2B88		;BF Error, improper filename

; display a string of length $2 pointed to by $0,$1
7E98:	ld	$16,($sz)
7E9A:	adw	$0,$sy
; non-printable characters are replaced with spaces
7E9C:	sbc	$16,&H20
7E9F:	jr	c,&H7EA6
7EA1:	sbc	$16,&H7F
7EA4:	jr	nz,&H7EA9
7EA6:	ld	$16,&H20
7EA9:	phsm	$2,3
7EAC:	cal	&H2AF1		;display character $16
7EAF:	ppsm	$0,3
7EB2:	sb	$2,$sy
7EB4:	jr	nz,&H7E98
7EB6:	rtn

; check if character $5 is allowed in a file name
7EB7:	sbc	$5,&HE0
7EBA:	jp	nc,&H2B88	;BF Error, improper filename
7EBD:	anc	$5,&H60
7EC0:	jr	z,&H7EBA	;BF Error
7EC2:	phs	$0
7EC4:	ld	$0,$5
7EC7:	cal	&H00B6		;TCAPS, lower to upper case conversion
7ECA:	ld	$5,$sz
7ECC:	pps	$0
7ECE:	gre	ix,$7
7ED0:	gst	ua,$9
7ED2:	pst	ua,&H24
7ED5:	pre	ix,&H157A	;list of illegal file name characters
7ED9:	ldi	$11,(ix+$sx)
7EDB:	sbc	$11,$5
7EDE:	jr	z,&H7EBA	;BF Error
7EE0:	sbc	$11,$sx		;end of the list?
7EE2:	jr	nz,&H7ED9	;loop if not
7EE4:	pst	ua,$9
7EE6:	pre	ix,$7
7EE8:	rtn

; function DSKF, prefix 5, code &H61
7EE9:	ld	$0,&H10		;FDD command &H10: get the free disk space
7EEC:	cal	&H7DAC		;send the command $0 to the FDD
7EEF:	cal	&H7D2D		;read a byte from the FDD to $0
7EF2:	ld	$15,$sz		;lower byte of the result
7EF4:	cal	&H7D2D		;read a byte from the FDD to $0
7EF7:	ld	$16,$sz		;upper byte of the result
7EF9:	cal	&H7D2D		;read a byte from the FDD to $0
7EFC:	cal	&H7D2D		;read a byte from the FDD to $0
7EFF:	cal	&H7D01		;wait until the FDD operation is complete
7F02:	jp	&H0A97		;CNVR, integer to floating point conversion

; make sure there is not an opened file
7F05:	pre	ix,&H1770
7F09:	sbcw	(ix+$sx),$30
7F0B:	jp	nc,&H2BD7	;OP Error, OPEN
7F0E:	rtn

; command FORMAT, prefix 4, code &8B
7F0F:	cal	&H0093		;SN Error if not an end of a BASIC line
7F12:	cal	&H7F05		;make sure there is not an opened file
7F15:	ld	$0,&H11		;FDD command &H11: format disk
7F18:	cal	&H7DAC		;send the command $0 to the FDD
7F1B:	jp	&H7D01		;wait until the FDD operation is complete

; command KILL, prefix 4, code &H8E
7F1E:	cal	&H11D2		;evaluate a string expression
7F21:	cal	&H125D		;append zero
7F24:	cal	&H7F05		;make sure there is not an opened file
7F27:	cal	&H7E0A		;expand the filename, wildcards allowed
7F2A:	cal	&H0093		;SN Error if not an end of a BASIC line
7F2D:	ld	$0,&H16		;FDD command &H16: delete file
7F30:	cal	&H7DAC		;send the command $0 to the FDD
7F33:	jr	&H7F6B		;write &H000B bytes from WORK1 to the FDD

; command NAME, prefix 4, code &H96
7F35:	cal	&H11D2		;evaluate a string expression
7F38:	cal	&H125D		;append zero
7F3B:	cal	&H7F05		;make sure there is not an opened file
7F3E:	ldw	$0,&H16A7	;destination pointer for the expanded filenames
7F42:	ld	$10,$sy		;flag: disallow wildcards in the filename
7F44:	cal	&H7E10		;expand the old filename
7F47:	ld	$2,&HBC		;code of the keyword "AS"
7F4A:	cal	&H00E9		;test for keyword prefix 7 and code $2
7F4D:	jp	nz,&H2B70	;SN Error, syntax
7F50:	cal	&H11D2		;evaluate a string expression
7F53:	cal	&H125D		;append zero
7F56:	ld	$10,$sy		;flag: disallow wildcards in the filename
7F58:	cal	&H7E0C		;expand the new filename
7F5B:	cal	&H0093		;SN Error if not an end of a BASIC line
7F5E:	ld	$0,&H15		;FDD command &H15: rename file
7F61:	cal	&H7DAC		;send the command $0 to the FDD
7F64:	ldw	$10,&H16A7	;pointer to the old name
7F68:	cal	&H7D8D		;write &H000B bytes to the FDD
7F6B:	cal	&H7D89		;write &H000B bytes from WORK1 to the FDD
7F6E:	jp	&H7D01		;wait until the FDD operation is complete

7F71:	cal	&H0093		;SN Error if not an end of a BASIC line
7F74:	cal	&H7F05		;make sure there is not an opened file
; create a filename consisting of a string of '?' wildcards
7F77:	pre	ix,&H165E	;WORK1
7F7B:	ldw	$0,&H0B3F	;$0='?', $1=number of question marks
7F7F:	sti	$0,(ix+$sx)
7F81:	sb	$1,$sy
7F83:	jr	nz,&H7F7F
7F85:	jr	&H7FA8

; command FILES, prefix 4, code &HB5
7F87:	cal	&H003C		;ENDSC, test for an end of a BASIC line
7F8A:	jr	c,&H7F71	;branch if no filename specified
7F8C:	cal	&H11D2		;evaluate a string expression
7F8F:	cal	&H125D		;append zero
7F92:	cal	&H7F05		;make sure there is not an opened file
7F95:	sbc	$17,$sx		;filename length
7F97:	jr	z,&H7F71	;branch if an empty filename
7F99:	cal	&H7DF8		;skip the optional device name "0:"
7F9C:	jr	z,&H7F71	;branch if an empty filename
7F9E:	ld	$10,&H02	;flag: allow wildcards and an empty filename
7FA1:	ldw	$0,&H165E	;destination pointer = WORK1
7FA5:	cal	&H7E13		;expand the filename
7FA8:	cal	&H0093		;SN Error if not an end of a BASIC line
7FAB:	ld	$0,&H12		;FDD command &H12: get the number of files
7FAE:	cal	&H7DAC		;send the command $0 to the FDD
7FB1:	cal	&H7D89		;write &H000B bytes from WORK1 to the FDD
7FB4:	cal	&H7D2D		;read a byte from the FDD to $0
7FB7:	ld	$24,$sz		;number of files on the floppy disk
7FB9:	cal	&H7D01		;wait until the FDD operation is complete
; loop
7FBC:	sb	$24,$sy		;number of files
7FBE:	rtn	c		;return if there are not any more files
7FBF:	ld	$0,&H03		;FDD command &H03: get the next directory entry
7FC2:	cal	&H7DAC		;send the command $0 to the FDD
7FC5:	ldw	$10,&H165E	;destination pointer = WORK1
7FC9:	ldw	$8,&H0014	;number of bytes
7FCD:	cal	&H829F		;read from the FDD
; display the file name
7FD0:	ldw	$0,&H165E	;pointer to the string = WORK1
7FD4:	ld	$2,&H08		;string length
7FD7:	cal	&H7E98		;display the string
7FDA:	phsw	$1
7FDC:	ld	$16,&H2E	;a dot before the extension
7FDF:	cal	&H2AF1		;display character $16
7FE2:	ppsw	$0
7FE4:	ld	$2,&H03		;string length
7FE7:	cal	&H7E98		;display the string
; display the file type
7FEA:	pre	ix,$0
7FEC:	ldim	$0,(ix+$sx),4	;IX<-IX+4, skip the "last write time/date" field
7FEF:	ldim	$25,(ix+$sx),5	;$25-$28 = file size, $29 = file type
7FF2:	cal	&H2AD7		;display a space
7FF5:	anc	$29,&HE0
7FF8:	ld	$16,&H20	;space
7FFB:	jr	z,&H800F	;branch if the file type is not specified
7FFD:	orcm	$26,$26,3
8000:	jr	nz,&H8007
8002:	sbc	$25,&H10
8005:	jr	c,&H800F	;branch if file size < 16 bytes
; file size >= 16 bytes
8007:	sbc	$29,&H7F
800A:	jr	z,&H800F
800C:	ld	$16,$29
800F:	cal	&H2AF1		;display character $16
8012:	cal	&H7B4D		;display four spaces
; convert the file size $25-$27 from binary to BCD, result in $13-$15
8015:	sbbm	$10,$10,7	;SBBM $11,$11,6 would do
8018:	ld	$10,$sy
801A:	anc	$25,$sy
801C:	jr	z,&H8021
801E:	adbm	$13,$10,3
8021:	bidw	$27
8023:	rod	$25
8025:	adbm	$10,$10,3
8028:	orcm	$25,$25,3
802B:	jr	nz,&H801A
; display the file size
802D:	ld	$23,&H17	;upper nibble: flag of suppressed leading zeros
				;lower nibble: counter of digits
8030:	orcm	$13,$13,3
8033:	jr	nz,&H805B
8035:	ld	$13,&H0F,jr &H805B	;digit=&H0F means non-suppressed zero
; this loop expands the BCD number and converts it to ASCII
8039:	an	$16,&H0F	;separate the top digit
803C:	adc	$16,$sy
803E:	jr	lz,&H8070	;branch if non-suppressed zero
8040:	sbc	$23,$sx		;test the flag of suppressed leading zeros
8042:	jr	uz,&H804C	;branch if cleared
8044:	sbc	$16,$sx		;test the digit for 0
8046:	jr	nz,&H804C
8048:	ld	$16,&H20,jr &H8052 ;replace suppressed leading zero with space
804C:	an	$23,&H0F	;clear the flag of suppressed leading zeros
804F:	or	$16,&H30	;convert the digit to ASCII
8052:	phsm	$15,3
8055:	cal	&H2AF1		;display character $16
8058:	ppsm	$13,3
805B:	dium	$13,4		;shift the top digit to $16
805E:	sb	$23,$sy		;decrement the counter of digits
8060:	jr	nlz,&H8039	;process the next digit
; wait for an [EXE] key
8062:	cal	&H655F		;wait for a key, convert to upper case
8065:	sbc	$0,&H0D		;[EXE]?
8068:	jr	nz,&H8062	;loop if not
806A:	cal	&H2AE8		;OUTCR, display CR-LF
806D:	jp	&H7FBC		;loop to the next file
8070:	ld	$16,$sx,jr &H804F

8073:	dw	&H2B94	;code &H01: FL Error, disk write error
8075:	dw	&H2B90	;code &H02: NF Error, file not found
8077:	dw	&H2B80	;code &H03: NR Error, I/O device not ready
8079:	dw	&H2B94	;code &H04: FL Error, disk full
807B:	dw	&H2BCC	;code &H05: FM Error, bad disk
807D:	dw	&H2B5E	;code &H06: LB Error, low batteries in the FDD
807F:	dw	&H2BB8	;code &H07: PR Error, write-protected disk
8081:	dw	&H2B90	;code &H08: NF Error, file not found
8083:	dw	&H2BCF	;code &H09: FM Error, bad disk
8085:	dw	&H2B94	;code &H0A: FL Error, disk write error
8087:	dw	&H2BE7	;code &H0B: DF Error, abnormality in the FDD
8089:	dw	&H2BE7	;code &H0C: DF Error, abnormality in the FDD
808B:	dw	&H2B88	;code &H0D: BF Error, improper filename

; reset the FDD
808D:	pst	ua,&H34
8090:	pre	ix,&HFFFC
8094:	ldw	$0,&HC080
8098:	std	$0,(ix+$sx)
809A:	ldm	$0,$sz,8	;small delay
809D:	std	$1,(ix+$sx)
809F:	pst	ua,&H54
80A2:	rtn

; open a disk file
80A3:	ld	$0,&H19		;FDD command &H19: open file
80A6:	cal	&H7DAC		;send the command $0 to the FDD
80A9:	cal	&H7D83		;write file name from address &H1775 to the FDD
80AC:	ld	$0,$sy		;file #1
80AE:	cal	&H7D17		;write a byte $0 to the FDD
80B1:	pre	ix,&H1773
80B5:	ld	$0,&H57		;'W'
80B8:	ldd	$1,(ix+$sx)	;access mode
80BA:	sbc	$1,&H32
80BD:	jr	c,&H80C7	;branch if OUTPUT or RANDOM
80BF:	ld	$0,&H52		;'R'
80C2:	jr	z,&H80C7	;branch if INPUT
; APPEND
80C4:	ld	$0,&H41		;'A'
80C7:	cal	&H7D17		;write a byte $0 to the FDD
80CA:	ld	$7,&H04
80CD:	cal	&H80D6		;write a number of zero bytes to the FDD
80D0:	cal	&H7D01		;wait until the FDD operation is complete
80D3:	jp	&H84C2

; write a number (specified in $7) of zero bytes to the FDD
80D6:	ld	$0,$sx
80D8:	cal	&H7D17		;write a byte $0 to the FDD
80DB:	sb	$7,$sy
80DD:	jr	nz,&H80D6
80DF:	rtn

; save file to disk
80E0:	cal	&H4930
80E3:	ld	$0,&H14		;FDD command &H14: save file
80E6:	cal	&H7DAC		;send the command $0 to the FDD
80E9:	cal	&H7D83		;write file name from address &H1775 to the FDD
80EC:	ld	$7,&H04
80EF:	cal	&H80D6		;write a number of zero bytes to the FDD
80F2:	cal	&H33EE		;get starting/ending address of current file
80F5:	cal	&H33FA		;$2,$3 <- file size
80F8:	sbc	$14,&H24	;'$'
80FB:	ldw	$8,$2
80FE:	jr	z,&H8107	;branch if not a typed file
8100:	ldw	$0,&H0010	;typed file header size
8104:	adw	$8,$sz,jr &H810B
8107:	adw	$2,$sy
8109:	adw	$8,$sy
810B:	phsw	$3
810D:	cal	&H7D0E		;write a word $8,$9 to the FDD
8110:	ld	$7,&H02
8113:	cal	&H80D6		;write a number of zero bytes to the FDD
8116:	sbc	$14,&H24	;'$'
8119:	jr	z,&H813E	;skip if not a typed FDD file
; header of a typed FDD file, starts with a sequence of bytes &HFF, &HFE
811B:	cal	&H7D0A		;write a byte &HFF to the FDD
811E:	ld	$0,&HFE
8121:	cal	&H7D17		;write a byte $0 to the FDD
8124:	ld	$0,&H42		;'B' - FDD file type: tokenized BASIC
8127:	cal	&H7D17		;write a byte $0 to the FDD
812A:	cal	&H7D0E		;write a word $8,$9 to the FDD
812D:	ld	$7,&H03
8130:	cal	&H80D6		;write a number of zero bytes to the FDD
8133:	ldw	$10,&H1683	;source pointer: password
8137:	ldw	$8,&H0008	;number of bytes
813B:	cal	&H7D91		;write to the FDD
813E:	ldw	$10,$25
8141:	ppsw	$8
8143:	jp	&H8301		;write $8,$9 bytes to the FDD

; load untyped file from disk
8146:	ld	$0,&H13		;FDD command &H13: load file
8149:	cal	&H7DAC		;send the command $0 to the FDD
814C:	cal	&H7D83		;write file name from address &H1775 to the FDD
814F:	ldw	$10,&H165E	;destination pointer = WORK1
8153:	ldw	$8,&H0014	;number of bytes = 4 + header size
8157:	cal	&H7D9F		;read from the FDD
815A:	cal	&H8165		;valid BASIC header found?
815D:	jr	nz,&H8194	;branch if not
; terminate the command
815F:	cal	&H7D0A		;write a byte &HFF to the FDD
8162:	sbc	$30,$sx		;Not Zero flag
8164:	rtn

; test for a valid BASIC file header
8165:	pre	ix,&H165E	;WORK1
8169:	ldim	$2,(ix+$sx),7	;$2..$5 = file size reported by FDD
816C:	sbcw	$4,$sy
816E:	jr	nc,&H8191	;invalid if file size > &HFFFF
8170:	adc	$6,$sy		;test for &HFF tag
8172:	jr	nc,&H8191
8174:	sbc	$7,&HFE		;test for &HFE tag
8177:	jr	nz,&H8191
8179:	sbc	$8,&H42		;test for 'B' file type
817C:	jr	nz,&H8191
817E:	ldw	$0,&H0010
8182:	sbcw	$2,$sz
8184:	jr	c,&H8191	;invalid if file size < 16
8186:	ldim	$6,(ix+$sx),5	;$6..$9 = file size in the header
8189:	orcm	$6,$6,4		;is it specified?
818C:	rtn	z		;OK if not
818D:	xrcm	$2,$6,4		;is the value correct?
8190:	rtn
; invalid file header
8191:	sbc	$30,$sx		;Not Zero flag
8193:	rtn

; terminate the command
8194:	cal	&H7D0A		;write a byte &HFF to the FDD
8197:	sbc	$31,$sx		;Zero flag
8199:	rtn
; load tokenized BASIC file from disk
819A:	ld	$0,&H13		;FDD command &H13: load file
819D:	cal	&H7DAC		;send the command $0 to the FDD
81A0:	cal	&H7D83		;write file name from address &H1775 to the FDD
81A3:	ldw	$10,&H165E	;destination pointer = WORK1
81A7:	ldw	$8,&H0014	;number of bytes = 4 + header size
81AB:	cal	&H7D9F		;read from the FDD
81AE:	cal	&H8165		;valid BASIC header found?
81B1:	jr	nz,&H8194	;reject the file if not
81B3:	sbw	$2,$sz		;decrement file size by header size
81B5:	phsw	$3
81B7:	ldim	$0,(ix+$sx),8	;file password
81BA:	adc	$0,$sy		;test for &HFF
81BC:	ld	$24,$sx
81BE:	jr	z,&H81D5	;skip if file not password protected
81C0:	cal	&H5294		;IX <- password buffer
81C3:	jr	z,&H81D3	;skip if empty
81C5:	ldm	$17,(ix+$sx),8
81C8:	xrcm	$17,$sz,8
81CB:	jr	z,&H81D5	;branch if password accepted
81CD:	cal	&H7D0A		;write a byte &HFF to the FDD
81D0:	jp	&H2BB8		;PR Error, password
81D3:	ld	$24,$sy
81D5:	cal	&H33EE		;get starting/ending address of current file
81D8:	cal	&H33FA		;$2,$3 <- file size
81DB:	pre	ix,&H18CF
81DF:	ldm	$4,(ix+$sx),4
81E2:	sbw	$6,$4
81E5:	ldw	$4,$2
81E8:	ldw	$2,$25
81EB:	ppsw	$0
81ED:	ldw	$8,$sz
81EF:	sbw	$0,$4
81F2:	jr	c,&H8224
81F4:	sbcw	$6,$sz
81F6:	jr	c,&H8234
81F8:	cal	&H34B1		;expand a memory block in a RAM file
81FB:	pre	ix,&H166A	;WORK1 + 8
81FF:	ldm	$0,(ix+$sx),8	;file password
8202:	cal	&H5294		;IX <- password buffer
8205:	sbc	$24,$sy
8207:	jr	nz,&H820C
8209:	stm	$0,(ix+$sx),8
; file accepted
820C:	ld	$0,$sx
820E:	cal	&H7D17		;write a byte $0 to the FDD
; skip the header
8211:	ld	$7,&H10		;header size
8214:	cal	&H7D2D		;read a byte from the FDD to $0
8217:	sb	$7,$sy
8219:	jr	nz,&H8214
821B:	ldw	$10,$25		;destination pointer
821E:	cal	&H829F		;read from the FDD
8221:	sbc	$31,$sy
8223:	rtn
8224:	invw	$0
8226:	adw	$0,$sy
8228:	phsw	$1
822A:	ldw	$0,$2
822D:	ppsw	$2
822F:	cal	&H34EA		;shrink a memory block in a RAM file
8232:	jr	&H81FB
; file too large, so reject it
8234:	cal	&H7D0A		;write a byte &HFF to the FDD
8237:	jp	&H2B6D		;OM Error, insufficient memory

; command MODE200, read a sector from the FDD to address &H18D4
823A:	ld	$0,&H17,jr &H8241
; command MODE201, write a sector from address &H18D4 to the FDD
823E:	ld	$0,&H18
8241:	phs	$0
8243:	cal	&H00E1		;'(' expected
8246:	cal	&H0EC3		;evaluate num. expression to integer (byte)
8249:	sbc	$15,&H50	;track in range 0-79
824C:	jr	nc,&H8266	;BS Error
824E:	phs	$15
8250:	cal	&H00DB		;comma expected
8253:	cal	&H0EC3		;evaluate num. expression to integer (byte)
8256:	sbc	$15,&H02	;side in range 0-1
8259:	jr	nc,&H8266	;BS Error
825B:	phs	$15
825D:	cal	&H00DB		;comma expected
8260:	cal	&H0EC3		;evaluate num. expression to integer (byte)
8263:	sbc	$15,&H09	;sector in range 1-8
8266:	jp	nc,&H2BA4	;BS Error, subscript out of range
8269:	sbc	$15,$sy
826B:	jp	c,&H2BA4	;BS Error, subscript out of range
826E:	cal	&H00DF		;')' expected
8271:	cal	&H0093		;SN Error if not an end of the parsed line
8274:	ppsm	$16,3
8277:	ld	$0,$18		;command code
827A:	cal	&H7DAC		;send the command $0 to the FDD
827D:	ld	$0,$17		;track
8280:	cal	&H7D17		;write a byte $0 to the FDD
8283:	ld	$0,$16		;side
8286:	cal	&H7D17		;write a byte $0 to the FDD
8289:	ld	$0,$15		;sector
828C:	cal	&H7D17		;write a byte $0 to the FDD
828F:	pre	ix,&H18D3
8293:	sti	$31,(ix+$sx)
8295:	gre	ix,$10		;source/destination pointer
8297:	ldw	$8,&H0200	;number of bytes (sector size)
829B:	anc	$18,$sy		;$18 = FDD command
829D:	jr	z,&H8301	;write $8,$9 bytes to the FDD
829F:	cal	&H7D9F		;read from the FDD
82A2:	jp	&H7D01		;wait until the FDD operation is complete

; read a record from a disk file to address &H1793
82A5:	ld	$0,&H1B		;FDD command &H1B: read/write file
82A8:	cal	&H7DAC		;send the command $0 to the FDD
82AB:	ld	$0,$sy		;file #1
82AD:	cal	&H7D17		;write a byte $0 to the FDD
82B0:	ld	$0,&H52		;'R'
82B3:	cal	&H7D17		;write a byte $0 to the FDD
82B6:	cal	&H7D2D		;read a byte from the FDD to $0
82B9:	ld	$8,$sz		;lower byte of record size
82BB:	cal	&H7D2D		;read a byte from the FDD to $0
82BE:	ld	$9,$sz		;upper byte of record size
82C0:	ldw	$26,&H0101
82C4:	sbcw	$26,$8
82C7:	ldw	$26,$8
82CA:	jr	c,&H82D6	;branch if too many data bytes
82CC:	ldw	$10,&H1793	;destination pointer = data buffer
82D0:	cal	&H829F		;read from the FDD
82D3:	jp	&H29C5		;test the power switch and BRK key
; too many data bytes
82D6:	cal	&H7D2D		;read and discard a byte from the FDD to $0
82D9:	sbw	$8,$sy
82DB:	jr	nz,&H82D6
82DD:	cal	&H7D01		;wait until the FDD operation is complete
82E0:	jp	&H2B74		;ST Error, string too long

; write a record of size of $5,$6 bytes from address &H1793 to a disk file
82E3:	sbcw	$5,$sy
82E5:	rtn	c
82E6:	ld	$0,&H1B		;FDD command &H1B: read/write file
82E9:	cal	&H7DAC		;send the command $0 to the FDD
82EC:	ld	$0,$sy		;file #1
82EE:	cal	&H7D17		;write a byte $0 to the FDD
82F1:	ld	$0,&H57		;'W'
82F4:	cal	&H7D17		;write a byte $0 to the FDD
82F7:	ldw	$8,$5		;number of bytes to write
82FA:	cal	&H7D0E		;write a word $8,$9 to the FDD
82FD:	ldw	$10,&H1793	;source pointer = data buffer
8301:	cal	&H7D91		;write $8,$9 bytes to the FDD
8304:	jr	&H82A2		;wait until the FDD operation is complete

; close a disk file
8306:	ld	$0,&H1A		;FDD command &H1A: close file
8309:	cal	&H7DAC		;send the command $0 to the FDD
830C:	ld	$0,$sy		;file #1
830E:	cal	&H7D17		;write a byte $0 to the FDD
8311:	jp	&H7D01		;wait until the FDD operation is complete


; returns Carry set for 8kB internal RAM (VX-4) otherwise 32kB (FX-870P)
8314:	phsw	$1
8316:	gst	ua,$0
8318:	pst	ua,&H34
831B:	pre	ix,&H0006
831F:	ldd	$1,(ix+$sx)
8321:	biu	$1		;Carry <- state of the PAD1/PAD2
8323:	pst	ua,$0
8325:	ppsw	$0
8327:	rtn

8328:	pre	iz,&H0004
832C:	std	$3,(iz+$sx)	;(&H0004)
832E:	st	$4,(iz+$sy)	;(&H0005)
8330:	or	$4,&H02
8333:	st	$4,(iz+$sy)	;(&H0005)
; delay 3 ms
8335:	ld	$1,&H98
8338:	sb	$1,$sy
833A:	jr	nz,&H8338
833C:	or	$4,&H20
833F:	st	$4,(iz+$sy)	;(&H0005)
8341:	rtn

; reset the gate array registers
8342:	pre	iz,&H0004
8346:	st	$31,(iz+&H03)	;(&H0007) <- &H00
8349:	ld	$0,&H40
834C:	st	$0,(iz-$sy)	;(&H0003) <- &H40
834E:	st	$31,(iz-$sy)	;(&H0003) <- &H00
8350:	st	$31,(iz-$sy)
8352:	st	$31,(iz-$sy)
8354:	ldw	$0,(iz+$sx)
8356:	an	$0,&H3F
8359:	std	$0,(iz+$sx)	;clear bits 7,6 of (&H0004)
835B:	an	$1,&HDF
835E:	st	$1,(iz+$sy)	;clear bit 5 of (&H0005)
8360:	an	$1,&HFD
8363:	st	$1,(iz+$sx)
8365:	ld	$0,$sx
8367:	stw	$31,(iz+$sx)
8369:	rtn

836A:	cal	&H8581		;save UA and IZ on the user stack, UA <- &HD4
836D:	sbw	$3,$3
8370:	cal	&H8328		;write gate array registers &H0004 and &H0005
8373:	cal	&H8342		;reset the gate array registers
8376:	jr	&H838F		;restore UA and IZ from the user stack

8378:	cal	&H0179		;INT1 interrupt disable
837B:	cal	&H8581		;save UA and IZ on the user stack, UA <- &HD4
837E:	pre	ix,&H165B
8382:	ldd	$2,(ix+$sx)
8384:	pre	iz,&H0003
8388:	an	$2,&HFB
838B:	std	$2,(iz+$sx)
838D:	std	$2,(ix+$sx)
838F:	jp	&H8579		;restore UA and IZ from the user stack

8392:	ld	$0,&H08,jr &H83A4	;Not ready
8396:	ld	$0,&H04,jr &H83A4	;Framing error
839A:	ld	$0,&H02,jr &H83A4	;Parity/Overrun error
839E:	pre	ix,&H1554
83A2:	ld	$0,$sy			;Buffer overflow
83A4:	st	$0,(ix+&H03)		;RS4 system variable
83A7:	pre	ix,&H165B
83AB:	ldd	$0,(ix+$sx)
83AD:	or	$0,&H10
83B0:	pre	iz,&H0003
83B4:	std	$0,(iz+$sx)
83B6:	jp	&H844D

; external interrupt 1 service routine
83B9:	phsm	$7,8
83BC:	phsm	$11,4
83BF:	gfl	$6
83C1:	gst	ua,$7
83C3:	gre	ix,$8
83C5:	gre	iz,$10
83C7:	pst	ua,&HD4
83CA:	pre	iz,&H0002
83CE:	ldw	$1,(iz+$sx)	;$1 = received data, $2 = error bits
83D0:	ld	$0,(iz+&H04)
83D3:	pre	ix,&H1556
83D7:	lddm	$5,(ix+$sx),3
83DA:	anc	$2,&H18
83DD:	jr	nz,&H839A	;branch if Parity/Overrun error
83DF:	anc	$2,&H20
83E2:	jr	nz,&H8396	;branch if Framing error
83E4:	xr	$0,&H1C		;invert bits DCD, DSR, CTS
83E7:	an	$0,$5		;$5 = RS3
83EA:	anc	$0,&H18		;state of the DCD and DSR signals
83ED:	jr	nz,&H8392	;branch if Not ready
83EF:	anc	$3,&H08		;number of data bits
83F2:	jr	z,&H8407	;skip if 8 data bits
83F4:	anc	$5,$sy		;RS3, SI/SO control?
83F6:	jr	z,&H8407	;skip if not
; 7 data bits and SI/SO control selected
83F8:	sbc	$1,&H20		;$1 = received data
83FB:	jr	nc,&H8466	;branch if not a control character
; control characters
83FD:	sbc	$1,&H0F		;SO, character codes <= &H7F
8400:	jr	z,&H8462
8402:	sbc	$1,&H0E		;SI, character codes >= &H80
8405:	jr	z,&H845C
;
8407:	anc	$5,&H02		;XON/XOFF flow control?
840A:	jr	z,&H8476	;branch if not
; XON/XOFF flow control selected
840C:	sbc	$1,&H11		;XON, resume transmission
840F:	jr	z,&H8472
8411:	sbc	$1,&H13		;XOFF, suspend transmission
8414:	jr	z,&H846E
;
8416:	ldd	$4,(ix+&H05)	;IX<-IX+5, receive buffer &H1559
841B:	st	$1,(ix+$4)	;store the received byte
841E:	ad	$4,$sy		;increment the input pointer
8420:	ad	$3,$sy		;increment the number of received bytes
8422:	stdw	$4,(ix-$sy)
8424:	jp	c,&H839E	;branch if buffer overrun
8427:	std	$30,(ix-$sy)	;(&H1558) <- &H01, INTCK <- data receive
8429:	sbc	$3,&HC0		;is the buffer 75% full?
842C:	jr	c,&H844D	;skip if not yet
842E:	anc	$5,&H40		;XOFF already in progress
8431:	jr	nz,&H844D	;skip if so
8433:	anc	$0,&H0C		;CTS, DSR
8436:	jr	nz,&H844D	;skip if the other end cannot receive
; apparently reading the "TX ready" bit may yield a false positive?
8438:	ld	$0,(iz+$sy)	;(&H0003) -> $0
843A:	ld	$1,(iz+$sy)
843C:	an	$1,$sz
843E:	bid	$1
8440:	jr	nc,&H844D	;skip if TX busy
8442:	ld	$0,&H13		;XOFF code
8445:	std	$0,(iz+$sx)	;(&H0002) <- $0, serial port transmit data reg.
8447:	or	$5,&H40		;XOFF in progress flag
844A:	std	$5,(ix-&H02)	;RS3 system variable
844D:	pre	iz,$10
844F:	pre	ix,$8
8451:	pst	ua,$7
8453:	pfl	$6
8455:	ppsm	$8,4
8458:	ppsm	$0,8
845B:	rtni

845C:	or	$4,$sy
845E:	st	$4,(ix+$sy)
8460:	jr	&H844D
8462:	an	$4,&HFE,jr &H845E
8466:	anc	$4,$sy
8468:	jr	z,&H8407
846A:	or	$1,&H80,jr &H8407
846E:	or	$4,&H02,jr &H845E
8472:	an	$4,&HFD,jr &H845E

; no flow control
8476:	ldd	$4,(ix+&H05)	;IX<-IX+5, receive buffer &H1559
8479:	ldiw	$4,(ix+$sx)
847B:	st	$1,(ix+$5)	;store the received byte
847E:	ad	$5,$sy		;increment the input pointer
8480:	ad	$4,$sy		;increment the number of received bytes
8482:	stdw	$5,(ix-$sy)
8484:	jp	c,&H839E	;branch if buffer overflow
8487:	anc	$3,$sy		;MT or RS232C?
8489:	jr	nz,&H844D	;skip if MT
848B:	std	$30,(ix-$sy)	;INTCK, flag of received data
848D:	jr	&H844D

848F:	sb	$0,$sy,jr &H84AE
8492:	ld	$0,&H02
8495:	pre	ix,&H1773
8499:	ldd	$1,(ix+$sx)
849B:	sbc	$1,&H32
849E:	jr	z,&H84AE
84A0:	jp	nc,&H2BDB	;AM Error, file access
84A3:	sbc	$1,$sx
84A5:	jr	lz,&H848F
84A7:	ad	$0,$sy
84A9:	ld	$1,&H41
84AC:	st	$1,(ix+$sx)
84AE:	pre	ix,&H173E
84B2:	stw	$12,(ix+$sx)
84B4:	pre	ix,&H1554
84B8:	bydw	$12
84BA:	ld	$14,$sx
84BC:	stm	$11,(ix+$sx),4
84BF:	cal	&H84EC		;RSOPN
84C2:	pre	ix,&H1770
84C6:	gre	ix,$8
84C8:	ld	$1,&H32		;INPUT
84CB:	sbc	(ix+&H03),$1	;access mode
84CE:	jp	z,&H4C54
84D1:	rtn

84D2:	cal	&H8581		;save UA and IZ on the user stack, UA <- &HD4
84D5:	pre	ix,&H1557	;RS4
84D9:	std	$31,(ix+$sx)	;clear the errors
84DB:	pre	ix,&H165B
84DF:	ldd	$2,(ix+$sx)
84E1:	or	$2,&H14		;8 data bits, parity control on
84E4:	pre	iz,&H0003
84E8:	std	$2,(iz+$sx)
84EA:	jr	&H853F

; RSOPN:
; RS232C controller chip initialisation (baud rate etc.),
; expects following input parameters:
; correctly preset variables RS1-RS4 (&H1554-&H1557)
; $0 - open mode (1=transmit, 2=receive, 3=transmit/receive)
; $11 - RS1 (baud rate, data length, parity, number of stop bits)
; $13 - RS3 (flow control)
84EC:	pre	ix,&H173A	;IOSTS
84F0:	anc	$13,&H02	;XON/XOFF flow control?
84F3:	jr	z,&H84F8	;skip if not
84F5:	or	$0,&H03		;send+receive for XON/XOFF control required
84F8:	std	$0,(ix+$sx)
84FA:	cal	&H8581		;save UA and IZ on the user stack, UA <- &HD4
84FD:	ld	$3,$11
8500:	did	$3
8502:	bid	$3		;baud rate on bits 0-2
8504:	ld	$4,&H08
8507:	cal	&H8328		;write gate array registers &H0004 and &H0005
850A:	ld	$1,$11
850D:	bid	$1
850F:	ld	$2,&H4A
8512:	bid	$1
8514:	jr	c,&H8519	;skip if Odd parity
8516:	or	$2,&H20
8519:	bid	$1
851B:	jr	c,&H8520	;skip if parity off
851D:	or	$2,&H10
8520:	bid	$1
8522:	jr	c,&H8527	;skip if 7 data bits
8524:	or	$2,&H04
8527:	bid	$1
8529:	jr	c,&H852E	;skip if 1 stop bit
852B:	or	$2,&H80
852E:	st	$2,(iz-$sy)	;(&H0003) <- $2
8530:	sbc	$0,&H02
8533:	jr	c,&H8559	;branch if transmit only
8535:	jr	z,&H8552	;branch if receive only
; transmit and receive
8537:	or	$3,&HC0
853A:	ld	$2,&H37
853D:	stw	$2,(iz-$sy)	;(&H0003) <- $2, (&H0004) <- $3
; initialise the receive buffer
853F:	pre	ix,&H1559
8543:	std	$31,(ix+$sx)	;RXCNT, number of received bytes <- 0
8545:	st	$31,(ix+$sy)	;input pointer <- 0
8547:	cal	&H0174		;INT1 interrupt enable
854A:	pre	ix,&H165B
854E:	std	$2,(ix+$sx)
8550:	jr	&H8579		;restore UA and IZ from the user stack

; receive only
8552:	or	$3,&H40
8555:	ld	$2,&H36,jr &H853D

; transmit only
8559:	or	$3,&H80
855C:	ld	$2,&H33
855F:	stw	$2,(iz-$sy)	;(&H0003) <- $2, (&H0004) <- $3
8561:	jr	&H854A

; RSCLO:
8563:	pre	ix,&H173A	;IOSTS
8567:	ldd	$0,(ix+$sx)
8569:	cal	&H8581		;save UA and IZ on the user stack, UA <- &HD4
856C:	anc	$0,$sy
856E:	cal	nz,&H86A3	;delay depending on the baud rate
8571:	std	$31,(ix+$sx)
8573:	cal	&H0179		;INT1 interrupt disable
8576:	cal	&H8342		;reset the gate array registers
; restore UA and IZ from the user stack
8579:	ppum	$0,3
857C:	pre	iz,$1
857E:	pst	ua,$0
8580:	rtn

8581:	cal	&H8588
8584:	pst	ua,&HD4
8587:	rtn

8588:	gst	ua,$1
858A:	gre	iz,$2
858C:	phum	$3,3
858F:	rtn

; RSGET:
; read a data byte from the RS232C receive buffer to $0
8590:	cal	&H85D0		;$0 <- first character in the receive buffer
8593:	pre	ix,&H1559	;receive buffer
8597:	sb	(ix+$sx),$30	;decrement the number of bytes in the buffer
8599:	ldd	$1,(ix+$sx)
859B:	sbc	$1,&H20		;less than 32 bytes in the buffer?
859E:	rtn	nc		;return if not
859F:	ldd	$4,(ix-&H03)	;RS3 system variable
85A2:	anc	$4,&H02		;XON/XOFF flow control?
85A5:	rtn	z		;return if not
85A6:	anc	$4,&H40		;XOFF in progress?
85A9:	rtn	z		;return if not
85AA:	phs	$0
85AC:	cal	&H8581		;save UA and IZ on the user stack, UA <- &HD4
85AF:	cal	&H29C5		;test the power switch and BRK key
85B2:	cal	&H8662		;is the other end ready to receive data?
85B5:	jr	nz,&H85AF	;loop if not
85B7:	ld	$0,&H11		;XON flow control character
85BA:	cal	&H865C		;NTX0, transmit $0 through the RS232C port
85BD:	ld	$0,&H40
85C0:	sb	(ix+$sx),$0	;RS3, clear the "XOFF in progress" flag
85C2:	cal	&H8579		;restore UA and IZ from the user stack
85C5:	pps	$0
85C7:	rtn

85C8:	cal	&H8581		;save UA and IZ on the user stack, UA <- &HD4
85CB:	cal	&H85FB		;PRTRS, transmit $16 through the RS232C port
85CE:	jr	&H8579		;restore UA and IZ from the user stack

; $0 <- first character in the receive buffer
85D0:	cal	&H29C5		;test the power switch and BRK key
85D3:	pre	ix,&H1558
85D7:	sbc	(ix-$sy),$31	;RS4 system variable, any receive errors?
85D9:	jr	nz,&H85E7	;branch if so
85DB:	sbc	(ix+$sy),$31	;number of bytes in the receive buffer
85DD:	jr	z,&H85D0	;loop if buffer empty
85DF:	ldiw	$0,(ix+$sy)
85E1:	sb	$1,$sz		;$1 = read pointer
85E3:	ld	$0,(ix+$1)	;get a byte from the receive buffer
85E6:	rtn

; serial port receive errors
85E7:	ld	$0,(ix-$sy)	;RS4 system variable
85E9:	bid	$0
85EB:	jp	c,&H2B7C	;BV Error, buffer overflow
85EE:	bid	$0
85F0:	jp	c,&H2BE3	;PO Error, parity or overrun error
85F3:	bid	$0
85F5:	jp	c,&H2BDF	;FR Error, framing error
85F8:	jp	&H2B80		;NR Error, I/O device not ready

; PRTRS:
; transmit the $16 byte through the RS232C port
85FB:	phs	$16
85FD:	cal	&H29C5		;test the power switch and BRK key
8600:	pre	ix,&H1554
8604:	ldm	$2,(ix+$sx),3
8607:	cal	&H8662		;is the other end ready to receive data?
860A:	jr	nz,&H85FD	;loop if not
860C:	anc	$4,&H02
860F:	jr	z,&H8616
8611:	anc	$3,&H02
8614:	jr	nz,&H85FD
8616:	pps	$0
8618:	anc	$2,&H08
861B:	jr	z,&H865C	;NTX0, transmit $0 through the RS232C port
861D:	anc	$4,$sy
861F:	jr	z,&H8659	;transmit $0 AND &H7F through the RS232C port
; character codes &H80..&H9F are processed as control codes in the SO mode
8621:	sbc	$0,&HA0
8624:	jr	nc,&H8648
8626:	sbc	$0,&H80
8629:	jr	nc,&H8659	;transmit $0 AND &H7F through the RS232C port
862B:	sbc	$0,&H20
862E:	jr	c,&H8659	;transmit $0 AND &H7F through the RS232C port
8630:	anc	$4,&H20
8633:	jr	z,&H8659	;transmit $0 AND &H7F through the RS232C port
8635:	phs	$0
8637:	ld	$0,&H0F		;SO, character codes <= &H7F
863A:	cal	&H865C		;NTX0, transmit $0 through the RS232C port
863D:	ld	$4,&HE0
8640:	pre	ix,&H1556
8644:	ad	(ix+$sx),$4
8646:	jr	&H85FD
8648:	anc	$4,&H20
864B:	jr	nz,&H8659	;transmit $0 AND &H7F through the RS232C port
864D:	phs	$0
864F:	ld	$0,&H0E		;SI, character codes >= &H80
8652:	cal	&H865C		;NTX0, transmit $0 through the RS232C port
8655:	ld	$4,&H20,jr &H8640

8659:	an	$0,&H7F
; NTX0:
; transmit $0 through the RS232C port, regardless of XON/XOFF or SI/SO settings
865C:	cal	&H8678		;wait until transmitter ready
865F:	st	$0,(iz-$sy)	;(&H0002) <- $0
8661:	rtn

; is the other end ready to receive data?
8662:	pre	iz,&H0002
8666:	ld	$0,(iz+&H04)	;serial port status register
8669:	xr	$0,&H0C
866C:	an	$0,$4
866F:	anc	$0,&H0C		;CTS, DSR
8672:	rtn

8673:	phs	$4
8675:	ld	$4,$sy,jr &H867C

; wait until transmitter ready
8678:	phs	$4
867A:	ld	$4,$sx
867C:	phsw	$1
867E:	pre	iz,&H0003
8682:	ldw	$2,&H0890	;time limit
8686:	sbw	$2,$sy
8688:	jr	z,&H869A	;time out
; repeat until two consecutive reads return the same value
868A:	ldd	$0,(iz+$sx)	;(&H0003) -> $0
868C:	ldd	$1,(iz+$sx)
868E:	sbc	$1,$sz
8690:	jr	nz,&H868A
8692:	sbc	$4,$sy
8694:	jr	z,&H869F
8696:	anc	$0,$sy		;TX ready flag
8698:	jr	z,&H8686
869A:	ppsw	$0
869C:	pps	$4
869E:	rtn
869F:	anc	$0,&H04,jr &H8698

; delay depending on the baud rate
86A3:	cal	&H8673
86A6:	ldw	$2,&H1554
86AA:	ld	$1,($2)		;RS1
86AD:	ld	$3,$sy
86AF:	sb	$1,&H20
86B2:	jr	c,&H86B7
86B4:	biu	$3,jr &H86AF
86B7:	ld	$2,&H0B
86BA:	sb	$2,$sy
86BC:	jr	nz,&H86BA
86BE:	sb	$3,$sy
86C0:	jr	nz,&H86B7
86C2:	rtn

; loading from the tape
86C3:	cal	&H87A1
86C6:	cal	&H8579		;restore UA and IZ from the user stack
86C9:	pre	ix,&H178C
86CD:	ld	$0,(ix+$sx)
86CF:	sbc	$0,&H24
86D2:	rtn	nz
86D3:	ld	$0,(ix+&H03)
86D6:	anc	$0,&H40
86D9:	rtn	nz
86DA:	jp	&H84C2

; open a cassette tape file, $10 = access mode, $12 = RS1, $13 = RS2
86DD:	anc	$10,&H05	;RANDOM or APPEND access mode?
86E0:	jp	nz,&H2BDB	;AM Error if so
86E3:	ld	$0,(ix+&H20)	;(&H1790)
86E6:	pre	ix,&H173D
86EA:	std	$0,(ix+$sx)
86EC:	cal	&H0179		;INT1 interrupt disable
86EF:	phs	$10
86F1:	ldw	$27,$12
86F4:	pre	ix,&H1554	;RS1 system variable
86F8:	sti	$27,(ix+$sx)
86FA:	sbw	$0,$sz
86FC:	stm	$31,(ix+$sx),3
86FF:	cal	&H8581		;save UA and IZ on the user stack, UA <- &HD4
8702:	ldw	$3,&H0C00	;initial data for registers &H0004, &H0005
8706:	pre	ix,&H173D
870A:	ldd	$0,(ix+$sx)
870C:	anc	$0,&H02
870F:	jr	z,&H8714
8711:	or	$4,&H10		;inversion of the MT signal
8714:	pps	$10
8716:	sbc	$10,$sx
8718:	pre	ix,&H173A	;IOSTS
871C:	jr	nlz,&H86C3	;branch if loading
;
; write a header segment to the tape
871E:	ld	$3,$12
8721:	did	$3
8723:	bid	$3		;baud rate on bits 0-2
8725:	or	$3,&H10		;parity control on
8728:	cal	&H8328		;write gate array registers &H0004 and &H0005
872B:	ld	$0,&HFE
872E:	st	$0,(iz-$sy)	;(&H0003)
8730:	ld	$0,&H11
8733:	st	$0,(iz-$sy)	;(&H0003)
8735:	pre	ix,&H165B
8739:	std	$0,(ix+$sx)
873B:	or	$3,&H80
873E:	std	$3,(iz+$sx)	;(&H0004)
8740:	pre	ix,&H173A	;IOSTS
8744:	std	$30,(ix+$sx)	;sending mode
8746:	cal	&H8983		;enable MT communication
8749:	ld	$4,&HC8		;lead-in length = 9 sec
874C:	ld	$0,&H48		;character 'H' - the header segment identifier
874F:	cal	&H88E1		;write the lead-in followed by byte $0
8752:	pre	ix,&H1770
8756:	ld	$0,&H1C
8759:	ldm	$22,(ix+$sz),3
875C:	ld	$0,$22
875F:	cal	&H88EA		;write byte to the tape, update the checksum
8762:	ldw	$5,&H000B	;length of the file name
8766:	pre	ix,&H1775	;pointer to the file name
876A:	cal	&H88FA		;write $5,$6 bytes pointed to by IX to the tape
876D:	ld	$5,&H08
8770:	pre	ix,&H1683
8774:	cal	&H88FA		;write $5,$6 bytes pointed to by IX to the tape
8777:	ld	$5,&H06
877A:	cal	&H887A		;write $5 zero bytes to the tape
877D:	ld	$0,$23
8780:	cal	&H88EA		;write byte to the tape, update the checksum
8783:	ld	$0,$24
8786:	cal	&H88EA		;write byte to the tape, update the checksum
8789:	ld	$5,&H04
878C:	cal	&H887A		;write $5 zero bytes to the tape
; write the checksum byte to the tape
878F:	pre	ix,&H176C	;MTFL2, checksum
8793:	ldd	$0,(ix+$sx)
8795:	cal	&H865C		;NTX0, transmit $0 through the RS232C port
8798:	cal	&H86A3		;delay depending on the baud rate
879B:	cal	&H8975		;disable MT communication
879E:	jp	&H8579		;restore UA and IZ from the user stack

; $12 = RS3, IX = &H173A ;IOSTS
87A1:	anc	$12,&H80
87A4:	jr	z,&H87A9
87A6:	or	$3,&H20
87A9:	cal	&H8328		;write gate array registers &H0004 and &H0005
87AC:	ld	$0,&H10
87AF:	st	$0,(iz+&H03)	;(&H0007)
87B2:	ld	$0,&HFD
87B5:	st	$0,(iz-$sy)	;(&H0003)
87B7:	ld	$0,&H10
87BA:	st	$0,(iz-$sy)	;(&H0003)
87BC:	pre	ix,&H165B
87C0:	std	$0,(ix+$sx)
87C2:	or	$3,&H40
87C5:	std	$3,(iz+$sx)	;(&H0004)
87C7:	pre	ix,&H173A	;IOSTS
87CB:	ld	$0,&H02		;receive mode
87CE:	std	$0,(ix+$sx)
87D0:	cal	&H8927		;wait for the header segment identifier 'H'
87D3:	ldw	$6,&H1000
87D7:	ld	$5,&H20
87DA:	cal	&H8905		;read byte from the tape, update the checksum
87DD:	pre	ix,$6
87DF:	sti	$0,(ix+$sx)
87E1:	gre	ix,$6
87E3:	sb	$5,$sy
87E5:	jr	nz,&H87DA
87E7:	cal	&H8884
87EA:	pre	ix,&H1000
87EE:	ldi	$0,(ix+$sx)
87F0:	sbc	$0,&H30
87F3:	jr	nz,&H87F8
87F5:	ld	$0,&H24
87F8:	gre	ix,$1
87FA:	phsm	$2,3
87FD:	cal	&H888F
8800:	pre	ix,&H178C
8804:	ldm	$18,(ix+$sx),4
8807:	ppsm	$0,3
880A:	anc	$21,&H40
880D:	jr	nz,&H881F
880F:	sbc	$18,$sz
8811:	jr	z,&H8821
8813:	sbc	$18,&H10
8816:	jr	nz,&H87D0
8818:	sbc	$0,&H24
881B:	jr	nz,&H87D0
881D:	or	$21,$sy
881F:	ld	$18,$sz
8821:	pre	ix,$1
8823:	ldim	$0,(ix+$sx),8
8826:	ld	$16,&H11
8829:	ldw	$16,(ix+$16)
882C:	pre	ix,&H1775
8830:	ldm	$8,(ix+$sx),8
8833:	sbc	$8,&H20
8836:	jr	z,&H883D
8838:	xrcm	$8,$sz,8
883B:	jr	nz,&H87D0
883D:	pre	ix,&H178C
8841:	stm	$18,(ix+$sx),4
8844:	pre	ix,&H176E
8848:	stw	$16,(ix+$sx)
884A:	adw	$16,$sy
884C:	pre	ix,&H1793	;data buffer
8850:	sbw	$14,$14
8853:	stm	$14,(ix+$sx),4
8856:	anc	$21,&H40
8859:	rtn	nz
885A:	pre	ix,&H100C
885E:	ldm	$0,(ix+$sx),8
8861:	pre	ix,&H1683
8865:	ldm	$8,(ix+$sx),8
8868:	adc	$0,$sy
886A:	rtn	c
886B:	adc	$8,$sy
886D:	jr	c,&H8876
886F:	xrcm	$8,$sz,8
8872:	jp	nz,&H2BB8	;PR Error, password
8875:	rtn
8876:	stm	$0,(ix+$sx),8
8879:	rtn

; write $5 zero bytes to the tape
887A:	ld	$0,$sx
887C:	cal	&H88EA		;write byte to the tape, update the checksum
887F:	sb	$5,$sy
8881:	jr	nz,&H887C
8883:	rtn

8884:	cal	&H8905		;read byte from the tape, update the checksum
8887:	sbc	(ix+$sx),$31
8889:	jp	nz,&H2B84	;RW Error, I/O device operation error
888C:	jp	&H8975		;disable MT communication

888F:	ldw	$8,&H4220	;$8=space, $9='B'
8893:	sbc	$0,&H10
8896:	jr	z,&H88A3
8898:	ld	$9,&H53		;'S'
889B:	sbc	$0,&H24		;'$'
889E:	jr	z,&H88A3
88A0:	ld	$9,&H41		;'A'
88A3:	ldm	$0,(ix+$sx),8
88A6:	phu	$30
88A8:	phuw	$9
88AA:	phum	$7,8
88AD:	pre	ix,&H16C5
88B1:	ldd	$10,(ix+$sx)
88B3:	sbc	$10,&H02
88B6:	jr	z,&H88C4
88B8:	ppu	$16
88BA:	sbc	$16,$sy
88BC:	jp	z,&H2AE8	;OUTCR, display CR-LF
88BF:	cal	&H2AF1		;display character $16
88C2:	jr	&H88B8
88C4:	cal	&H5D57
88C7:	pre	ix,&H151C
88CB:	ppu	$0
88CD:	sbc	$0,$sy
88CF:	jp	z,&H5D1E
88D2:	sti	$0,(ix+$sx)
88D4:	jr	&H88CB

88D6:	cal	&H8581		;save UA and IZ on the user stack, UA <- &HD4
88D9:	ld	$0,$16
88DC:	cal	&H88EA		;write byte to the tape, update the checksum
88DF:	jr	&H8935

; write the lead-in followed by byte $0 to the tape
88E1:	cal	&H8914		;wait 45 ms * $4
88E4:	pre	ix,&H176C	;MTFL2, checksum
88E8:	std	$31,(ix+$sx)	;initialize the checksum to 0
; write a byte $0 to the tape, update the checksum
88EA:	ldw	$2,&H176C	;MTFL2, checksum
88EE:	ld	$1,($2)
88F1:	sb	$1,$sz
88F3:	st	$1,($2)
88F6:	jp	&H865C		;NTX0, transmit $0 through the RS232C port

88F9:	rtn	z
; write $5,$6 bytes pointed to by IX to the tape
88FA:	cal	&H29C5		;test the power switch and BRK key
88FD:	ldi	$0,(ix+$sx)
88FF:	cal	&H88EA		;write byte to the tape, update the checksum
8902:	sbw	$5,$sy,jr &H88F9

; read a byte from the tape to $0, update the checksum
8905:	cal	&H8590		;RSGET, read a byte from the tape to $0
8908:	pre	ix,&H176C	;MTFL2, checksum
890C:	ad	(ix+$sx),$0
890E:	rtn

; wait 0.9 sec
890F:	ld	$4,&H14,jr &H8914
8913:	rtn	z
; wait 45 ms * $4
8914:	ld	$3,&H3C
8917:	phsm	$3,4
891A:	cal	&H29C5		;test the power switch and BRK key
891D:	ppsm	$0,4
8920:	sb	$3,$sy
8922:	jr	nz,&H8917
8924:	sb	$4,$sy,jr &H8913

; wait for the header segment identifier 'H'
8927:	cal	&H8581		;save UA and IZ on the user stack, UA <- &HD4
892A:	cal	&H8378
892D:	cal	&H8946		;read the first byte from the tape file to $0
8930:	sbc	$0,&H48		;character 'H'
8933:	jr	nz,&H892A	;loop if not
8935:	jp	&H8579		;restore UA and IZ from the user stack

; check for the data segment identifier 'D'
8938:	cal	&H8581		;save UA and IZ on the user stack, UA <- &HD4
893B:	cal	&H8946		;read the first byte from the tape file to $0
893E:	sbc	$0,&H44		;character 'D'
8941:	jp	nz,&H2B84	;RW Error, I/O device operation error
8944:	jr	&H8935		;restore UA and IZ from the user stack

; read the first byte from the tape file to $0, initialise the checksum
8946:	cal	&H8983		;enable MT communication
8949:	cal	&H890F		;wait 0.9 sec
894C:	ld	$5,&HE9
894F:	cal	&H29C5		;test the power switch and BRK key
8952:	pre	iz,&H0006
8956:	ldd	$0,(iz+$sx)
8958:	bid	$0
895A:	jr	nc,&H894C	;wait for a carrier
895C:	sb	$5,$sy
895E:	jr	nz,&H894F	;ensure that the carrier is stable
8960:	cal	&H84D2		;save UA and IZ on the user stack, UA <- &HD4,
				;initialise the receive buffer, enable INT1
8963:	cal	&H8590		;RSGET, read a byte from the tape to $0
8966:	pre	ix,&H176C	;MTFL2, checksum
896A:	std	$0,(ix+$sx)
896C:	rtn

896D:	cal	&H8581		;save UA and IZ on the user stack, UA <- &HD4
8970:	cal	&H8983		;enable MT communication
8973:	jr	&H8935		;restore UA and IZ from the user stack

8975:	cal	&H8581		;save UA and IZ on the user stack, UA <- &HD4
8978:	cal	&H897D		;disable MT communication
897B:	jr	&H8935		;restore UA and IZ from the user stack

; disable MT communication
897D:	cal	&H8378
8980:	ld	$1,$sx,jr &H8985

; enable MT communication
8983:	ld	$1,$sy
8985:	pre	ix,&H165B
8989:	ldd	$0,(ix+$sx)
898B:	pre	iz,&H0003
898F:	bid	$1
8991:	ld	$1,(iz+$sy)	;(&H0004)
8993:	jr	nc,&H89A2	;branch if disable
8995:	or	$0,&H02		;set DTR = motor relay on
8998:	or	$1,&H80
899B:	st	$1,(iz+$sy)	;(&H0004)
899D:	std	$0,(ix+$sx)
899F:	std	$0,(iz+$sx)	;(&H0003)
89A1:	rtn
;
89A2:	an	$0,&HF9		;clear DTR = motor relay off
89A5:	an	$1,&H7F,jr &H899B

; PROUT:
; print a character $16 on the printer
89A9:	gst	ua,$0
89AB:	gre	iz,$1
89AD:	phsm	$2,3
89B0:	pst	ua,&HD4
89B3:	pre	iz,&HFFF0
89B7:	cal	&H89DB		;wait until the printer is ready
89BA:	std	$16,(iz+$sx)	;Printer Data
89BC:	cal	&H89C7		;printer strobe pulse
89BF:	ppsm	$0,3
89C2:	pre	iz,$1
89C4:	pst	ua,$0
89C6:	rtn

; printer strobe pulse
89C7:	gst	pd,$0
89C9:	an	$0,&HF7		;clear the Printer Strobe bit
89CC:	pst	pd,$0
89CE:	or	$0,&H08		;set the Printer Strobe bit
89D1:	pst	pd,$0
89D3:	cal	&H89DB		;wait until the printer is ready
89D6:	na	$0,$sx
89D8:	std	$0,(iz+$sx)	;Printer Data <- &HFF
89DA:	rtn

; wait until the printer is ready
89DB:	cal	&H299A		;$1 <- (OUTDV)
89DE:	gst	ua,$2
89E0:	phsw	$2
89E2:	pst	ua,&H54
89E5:	cal	&H2991		;select the LCD as the output device
89E8:	cal	&H29C5		;test the power switch and BRK key
89EB:	ppsw	$0
89ED:	pst	ua,$1
89EF:	cal	&H2993		;(OUTDV) <- &H08
89F2:	gpo	$0
89F4:	anc	$0,&H20		;Printer Busy bit
89F7:	jr	nz,&H89DB
89F9:	gpo	$0
89FB:	anc	$0,&H20
89FE:	jr	nz,&H89DB
8A00:	rtn

8A01:	gre	ix,$14
8A03:	phsw	$15
8A05:	cal	&H2ADF
8A08:	ppsw	$14
8A0A:	cal	&H7ABC

8A0D:	ldw	$17,&H293A	;string "TEST NG"
8A11:	cal	&H6520		;display a string from bank 2
8A14:	cal	&H032E		;cursor display disable
8A17:	cal	&H03A4
8A1A:	sbc	$0,&H0D
8A1D:	jr	nz,&H8A14
8A1F:	cal	&H031B		;cursor display enable
8A22:	pre	ss,&H1BD7
8A26:	pre	ix,&H16EB
8A2A:	ldw	$0,(ix+$sx)
8A2C:	jp	$0

; self-test invoked with SYSTEM*
8A2E:	cal	&H0093		;SN Error if not an end of a BASIC line
8A31:	cal	&H9272
8A34:	pre	ss,&H1BD7
8A38:	cal	&H66BA		;US<-&H1CD0, UA<-&H54
8A3B:	ldw	$2,&H8A31
8A3F:	cal	&H297A		;BRSTR, set ACJMP
8A42:	ldw	$17,&H266A
8A46:	cal	&H8C83
8A49:	ldw	$1,&H8B0A
8A4D:	phsm	$2,3
8A50:	cal	&H2ADF
8A53:	ppsm	$16,3
8A56:	pre	ix,$17
8A58:	cal	&H0166		;execute a procedure from the table
8A5B:	jr	&H8A31		;self-test main menu

; sub-menu EXE:I/O LOOP
8A5D:	cal	&H28D4
8A60:	ld	$14,$sx
8A62:	ldw	$17,&H2E48
8A66:	cal	&H6B57
8A69:	pre	ix,&H1AD3
8A6D:	ld	$0,$sx
8A6F:	stw	$31,(ix+$sx)
8A71:	pre	iz,$17
8A73:	pre	ix,&H19D5
8A77:	pst	ua,&H94
8A7A:	ldi	$0,(iz+$sx)
8A7C:	gre	iz,$17
8A7E:	pst	ua,&H54
8A81:	sbc	$0,$sy
8A83:	jr	z,&H8AA2
8A85:	sti	$0,(ix+$sx)
8A87:	jr	nc,&H8A77
8A89:	phsm	$18,5
8A8C:	cal	&H9753		;INCLR, clear the INTOP input buffer
8A8F:	sbw	$14,$14
8A92:	pre	ix,&H1AD3
8A96:	pre	iz,&H19D5
8A9A:	cal	&H4AF7
8A9D:	ppsm	$14,5
8AA0:	jr	&H8A69
8AA2:	adb	$14,$sy
8AA4:	jr	uz,&H8A66
8AA6:	pre	ss,&H1BD7
8AAA:	ldw	$2,&H8AA6
8AAE:	cal	&H297A		;BRSTR, set ACJMP
8AB1:	ldw	$17,&H26CF
8AB5:	cal	&H653D
8AB8:	cal	&H655F		;wait for a key, convert to upper case
8ABB:	cal	&H002B		;OKNM1, is $0 a digit?
8ABE:	jr	nc,&H8AB8	;loop if not
8AC0:	sbc	$0,&H31		;'1'
8AC3:	jr	c,&H8ADA	;0:BZ
8AC5:	jr	z,&H8AFB	;1:FDD
8AC7:	ld	$14,$sz
8AC9:	an	$14,&H0F
8ACC:	cal	&H6B57
8ACF:	cal	&H2930
8AD2:	std	$31,(ix+$sy)
8AD4:	sbbw	$17,$17
8AD7:	jp	&H3545
; 0:BZ
8ADA:	ldw	$2,&H8AF2
8ADE:	cal	&H297A		;BRSTR, set ACJMP
8AE1:	gst	pd,$4
8AE3:	an	$4,&H3F
8AE6:	or	$4,&H40
8AE9:	pst	pd,$4
8AEB:	cal	&H29C5		;test the power switch and BRK key
8AEE:	xr	$4,&HC0,jr &H8AE9
8AF2:	gst	pd,$4
8AF4:	or	$4,&HC0
8AF7:	pst	pd,$4
8AF9:	jr	&H8AA6
; 1:FDD
8AFB:	ldw	$17,&H2959	;string "FDD CHECK"
8AFF:	cal	&H653D
8B02:	cal	&H8E01		;perform the FDD check
8B05:	cal	&H29C5		;test the power switch and BRK key
8B08:	jr	&H8B02

8B0A:	30, 8C99	;0:ROM
8B0D:	31, 8C37	;1:LCD
8B10:	32, 8BDB	;2:KEY
8B13:	33, 8D94	;3:I/0
8B16:	34, 8D22	;4:RAM
8B19:	35, 8D3A	;5:RAMW
8B1C:	36, 8D06	;6:RAMR
8B1F:	37, 8B90	;7:DISP
8B22:	38, 8E48	;8:3PinConnector
8B25:	39, 8B81	;9:DISPLOOP
8B28:	0D, 8A5D	;EXE:I/O LOOP
8B2B:	00, 8A31	;self-test main menu

8B2E:	ldw	$11,&H0050
8B32:	ldw	$13,&H0002
8B36:	pre	ix,&H1554
8B3A:	stm	$11,(ix+$sx),4
8B3D:	ld	$0,&H03
8B40:	cal	&H84EC
8B43:	pre	ix,&H1774
8B47:	ld	$0,&H02
8B4A:	st	$0,(ix+$sx)
8B4C:	rtn
8B4D:	ldw	$4,&H4000
8B51:	cal	&H8B6D
8B54:	ldw	$4,&H8001
8B58:	cal	&H8B6D
8B5B:	ldw	$4,&H8002
8B5F:	cal	&H8B6D
8B62:	ldw	$4,&H0102
8B66:	cal	&H8B6D
8B69:	ldw	$4,&H0203
8B6D:	cal	&H92CD
8B70:	cal	&H655F		;wait for a key, convert to upper case
8B73:	sbw	$4,$4
8B76:	cal	&H92CD
8B79:	ad	$4,$sy
8B7B:	anc	$4,&H40
8B7E:	jr	z,&H8B76
8B80:	rtn

; sub-menu 9:DISPLOOP
8B81:	ld	$16,&H20
8B84:	cal	&H2AF1		;display character $16
8B87:	cal	&H29C5		;test the power switch and BRK key
8B8A:	ad	$16,$sy
8B8C:	jr	nc,&H8B84
8B8E:	jr	&H8B81

; sub-menu 7:DISP
8B90:	cal	&H8C89
8B93:	ldw	$17,&H273A
8B97:	cal	&H8C83
8B9A:	ldw	$0,&H1101
8B9E:	st	&H20,($sz)
8BA1:	ldw	$16,&H40FF
8BA5:	cal	&H2AF1		;display character $16
8BA8:	cal	&H29C5		;test the power switch and BRK key
8BAB:	sb	$17,$sy
8BAD:	jr	nz,&H8BA5
8BAF:	jr	&H8B9A
8BB1:	cal	&H9238		;English or Japanese version?
8BB4:	jr	nz,&H8BBE	;skip if Japanese
8BB6:	ldw	$0,&H29B4
8BBA:	sbcw	$17,$sz
8BBC:	jr	z,&H8BCE
8BBE:	cal	&H653D
8BC1:	pre	iz,$17
8BC3:	pst	ua,&HA4
8BC6:	ldi	$16,(iz+$sx)
8BC8:	pst	ua,&H54
8BCB:	gre	iz,$17
8BCD:	rtn
8BCE:	ldw	$17,&H2992
8BD2:	cal	&H653D
8BD5:	pre	iz,&H29B6
8BD9:	jr	&H8BC3

; sub-menu 2:KEY
8BDB:	ldw	$2,&H8BDB
8BDF:	cal	&H297A		;BRSTR, set ACJMP
8BE2:	pre	ix,&H1113
8BE6:	std	$31,(ix+$sx)
8BE8:	ldw	$17,&H29A4
8BEC:	cal	&H9238		;English or Japanese version?
8BEF:	jr	z,&H8C0F	;branch if English
8BF1:	cal	&H8BB1
8BF4:	cal	&H8C1C
8BF7:	sbc	$16,$sz
8BF9:	jr	nz,&H8BF4
8BFB:	sbc	$0,&H20
8BFE:	jr	z,&H8C05
8C00:	cal	&H33BA
8C03:	jr	&H8BF1
8C05:	cal	&H33B3
8C08:	ldw	$2,&H1FB0
8C0C:	jp	&H297A		;BRSTR, set ACJMP
8C0F:	ldw	$17,&H2994
8C13:	cal	&H8BB1
8C16:	ldw	$17,&H29AA
8C1A:	jr	&H8BF4
8C1C:	ldw	$0,&H110F	;system variable APOCN, APO counter
8C20:	st	&H07,($sz)
8C23:	cal	&H0171		;one-minute timer and ON interrupt enable
8C26:	cal	&H03F3
8C29:	pre	ix,&H111B
8C2D:	sbc	(ix+$sx),$31
8C2F:	jr	z,&H8C26
8C31:	cal	&H017C		;one-minute timer and ON interrupt disable
8C34:	jp	&H036C

; sub-menu 1:LCD
8C37:	cal	&H8B73
8C3A:	cal	&H655F		;wait for a key, convert to upper case
8C3D:	cal	&H8B4D
8C40:	pre	ix,&H2AD9
8C44:	pre	iy,&H2DD8
8C48:	pre	iz,&H123C
8C4C:	pst	ua,&H64
8C4F:	bup
8C50:	pst	ua,&H54
8C53:	cal	&H930F
8C56:	cal	&H655F		;wait for a key, convert to upper case
8C59:	cal	&H8C89
8C5C:	phsm	$5,6
8C5F:	ldw	$17,&H273A
8C63:	cal	&H8C83
8C66:	ppsm	$0,6
8C69:	ld	$6,&HFF
8C6C:	ldm	$7,$6,6
8C6F:	xrm	$0,$6,6
8C72:	cal	&H8C7B
8C75:	ld	$0,&HFF
8C78:	ldm	$1,$sz,6
8C7B:	cal	&H8C91
8C7E:	cal	&H92F5
8C81:	jr	&H8C86
8C83:	cal	&H653D
8C86:	jp	&H655F		;wait for a key, convert to upper case
8C89:	ldw	$0,&H55AA
8C8D:	ldw	$2,$sz
8C8F:	ldw	$4,$sz
8C91:	pre	ix,&H154E
8C95:	stm	$0,(ix+$sx),6
8C98:	rtn

; sub-menu 0:ROM
8C99:	ldw	$0,&H8C99
8C9D:	cal	&H8E41
8CA0:	ldw	$17,&H27D4
8CA4:	cal	&H9238		;English or Japanese version?
8CA7:	jr	nz,&H8CAD	;skip if Japanese
8CA9:	ldw	$17,&H2816
8CAD:	cal	&H8C83
8CB0:	cal	&H2ADF
8CB3:	pre	ix,&H0C00
8CB7:	pst	ua,&H04
8CBA:	sbw	$14,$14
8CBD:	cal	&H8CCE
8CC0:	pst	ua,&HA4
8CC3:	cal	&H8CCE
8CC6:	pst	ua,&H54
8CC9:	cal	&H7ABC
8CCC:	jr	&H8C86

8CCE:	ldi	$0,(ix+$sx)
8CD0:	ad	$14,$sz
8CD2:	xr	$15,$sz
8CD4:	gre	ix,$0
8CD6:	sbcw	$0,$sy
8CD8:	jr	nc,&H8CCE
8CDA:	rtn

8CDB:	pre	ix,&H1895
8CDF:	sbbm	$0,$sz,6
8CE2:	ldw	$2,(ix+$sx)
8CE4:	ldw	$4,&H18D1
8CE8:	ldw	$4,($4)
8CEB:	adw	$4,$sy
8CED:	sbw	$4,$2
8CF0:	sbc	$6,$sy
8CF2:	rtn	z
8CF3:	sbw	$0,$sy
8CF5:	rtn
8CF6:	ad	$0,$6
8CF9:	jr	nc,&H8D01
8CFB:	ad	$1,$6
8CFE:	ld	$0,$1
8D01:	adw	$2,$sy
8D03:	sbw	$4,$sy
8D05:	rtn

; sub-menu 6:RAMR
8D06:	ldw	$0,&H8D06
8D0A:	cal	&H8E41
8D0D:	cal	&H8D66
8D10:	ld	$6,$sy
8D12:	cal	&H8CDB
8D15:	pre	ix,$2
8D17:	sbc	(ix+$sx),$0
8D19:	jp	nz,&H8A01
8D1C:	cal	&H8CF6
8D1F:	jr	nz,&H8D15
8D21:	rtn

; sub-menu 4:RAM
8D22:	cal	&H2ADF
8D25:	ldw	$0,&H8D22
8D29:	cal	&H8E41
8D2C:	cal	&H8D41
8D2F:	cal	&H8D10
8D32:	ld	$6,&HFF
8D35:	cal	&H8D59
8D38:	jr	&H8D12

; sub-menu 5:RAMW
8D3A:	ldw	$0,&H8D3A
8D3E:	cal	&H8E41
8D41:	ldw	$17,&H2858
8D45:	cal	&H8314		;is the size of the internal RAM 8kB or 32kB?
8D48:	jr	c,&H8D4E	;skip if 8kB
8D4A:	ldw	$17,&H28A4
8D4E:	cal	&H8C83
8D51:	cal	&H28D4
8D54:	cal	&H8D66
8D57:	ld	$6,$sy
8D59:	cal	&H8CDB
8D5C:	pre	ix,$2
8D5E:	std	$0,(ix+$sx)
8D60:	cal	&H8CF6
8D63:	jr	nz,&H8D5C
8D65:	rtn
8D66:	cal	&H2ADF
8D69:	pre	ix,&H18D1
8D6D:	ldw	$0,(ix+$sx)
8D6F:	anc	$1,&H10
8D72:	jr	nz,&H8D77
8D74:	ad	$1,&H50
8D77:	sb	$1,&H7F
8D7A:	sbc	$1,&H20
8D7D:	jr	c,&H8D88
8D7F:	jr	z,&H8D8E
8D81:	ldw	$17,&H28F1
8D85:	jp	&H653D
8D88:	ldw	$17,&H2922
8D8C:	jr	&H8D85
8D8E:	ldw	$17,&H290A
8D92:	jr	&H8D85

; sub-menu 3:I/0
8D94:	ldw	$0,&H8D94
8D98:	cal	&H8E41
8D9B:	ldw	$17,&H2966
8D9F:	cal	&H653D
8DA2:	cal	&H655F		;wait for a key, convert to upper case
8DA5:	sb	$0,&H30
8DA8:	jr	z,&H8DB3
8DAA:	sb	$0,$sy
8DAC:	jr	nz,&H8DA2
; 1:CHECK I/O BUS (FDD)
8DAE:	cal	&H8E01		;perform the FDD check
8DB1:	jr	&H8DF1
; 0:CHECK I/O Connector
8DB3:	pst	ua,&HD4
8DB6:	ldw	$3,&H0805
8DBA:	cal	&H8328		;write gate array registers &H0004 and &H0005
8DBD:	or	$3,&HC0
8DC0:	std	$3,(iz+$sx)	;(&H0004)
8DC2:	ld	$3,&H7E
8DC5:	st	$3,(iz-$sy)	;(&H0003)
8DC7:	pre	ix,&H2DD9	;table of bit patterns
8DCB:	pst	ua,&HE4
8DCE:	ldim	$0,(ix+$sx),4
8DD1:	pst	pd,$2
8DD3:	st	$3,(iz-$sy)	;(&H0003)
8DD5:	gpo	$2
8DD7:	ld	$3,(iz+&H02)	;(&H0006)
8DDA:	adc	$0,$sy		;end of the table mark &HFF?
8DDC:	jr	c,&H8DF1
8DDE:	an	$2,&H20
8DE1:	an	$3,&H1C		;DCD, DSR, CTS inputs
8DE4:	sbcw	$2,$sz
8DE6:	jr	z,&H8DCB
; test failed
8DE8:	cal	&H8DF7		;reset the gate array registers
8DEB:	cal	&H2ADF
8DEE:	jp	&H8A0D
; test passed
8DF1:	cal	&H8DF7		;reset the gate array registers
8DF4:	jp	&H8A31		;self-test main menu

; reset the gate array registers
8DF7:	pst	ua,&HD4
8DFA:	cal	&H8342		;reset the gate array registers
8DFD:	pst	ua,&H54
8E00:	rtn

; perform the FDD check
8E01:	pre	ix,&H18D3
8E05:	ld	$0,$sx
8E07:	sti	$0,(ix+$sx)
8E09:	sti	$0,(ix+$sx)
8E0B:	ad	$0,$sy
8E0D:	jr	nz,&H8E09
8E0F:	sti	$0,(ix+$sx)
8E11:	sb	$0,$sy
8E13:	jr	nz,&H8E0F
8E15:	ldw	$15,&H0005
8E19:	ldw	$17,&H1828	;FDD command &H18: write sector
8E1D:	cal	&H8277
8E20:	sb	$18,$sy		;FDD command &H17: read sector
8E22:	cal	&H8277
8E25:	pre	ix,&H18D4
8E29:	ld	$0,$sx
8E2B:	ldi	$1,(ix+$sx)
8E2D:	sbc	$1,$sz
8E2F:	jp	nz,&H293A
8E32:	ad	$0,$sy
8E34:	jr	nz,&H8E2B
8E36:	ldi	$1,(ix+$sx)
8E38:	sbc	$1,$sz
8E3A:	jr	nz,&H8E2F
8E3C:	sb	$0,$sy
8E3E:	jr	nz,&H8E36
8E40:	rtn

8E41:	pre	ix,&H16EB
8E45:	stw	$0,(ix+$sx)
8E47:	rtn

; sub-menu 8:3PinConnector
8E48:	ldw	$17,&H2E1D
8E4C:	cal	&H8C83
8E4F:	cal	&H2ADF
8E52:	cal	&H8B2E
8E55:	ld	$16,&H21
8E58:	cal	&H85C8
8E5B:	cal	&H86A6
8E5E:	ld	$17,$sx
8E60:	cal	&H29C5		;test the power switch and BRK key
8E63:	pre	ix,&H1558
8E67:	sbc	(ix-$sy),$31
8E69:	jr	nz,&H8E8E
8E6B:	sb	$17,$sy
8E6D:	jr	z,&H8E8E
8E6F:	sbc	(ix+$sy),$31
8E71:	jr	z,&H8E60
8E73:	ldiw	$0,(ix+$sy)
8E75:	sb	$1,$sz
8E77:	ld	$0,(ix+$1)
8E7A:	cal	&H8593
8E7D:	sbc	$16,$sz
8E7F:	jr	nz,&H8E8E
8E81:	ad	$16,$sy
8E83:	sbc	$16,&H7F
8E86:	jr	nz,&H8E58
8E88:	cal	&H8563
8E8B:	jp	&H8A31		;self-test main menu
8E8E:	cal	&H8563
8E91:	ldw	$0,&H8E48
8E95:	cal	&H8E41
8E98:	cal	&H2ADF
8E9B:	jp	&H8A0D

; F.COM menu "Copy"
8E9E:	pre	ss,&H1BD7
8EA2:	pre	ix,&H16B8
8EA6:	ldw	$0,(ix+$sx)
8EA8:	pre	ix,&H16D2
8EAC:	stw	$0,(ix+$sx)
8EAE:	ldw	$17,&H3860
8EB2:	cal	&H8F54
8EB5:	cal	&H8ED7
8EB8:	cal	&H655F		;wait for a key, convert to upper case
8EBB:	sbc	$0,&H10
8EBE:	jr	uz,&H8ECB
8EC0:	sbc	$0,&H0D
8EC3:	jr	nz,&H8EB8
8EC5:	cal	&H8F89
8EC8:	jp	&H6A4F
8ECB:	cal	&H8ED3
8ECE:	cal	&H8EEB
8ED1:	jr	&H8EB8
8ED3:	ld	$16,&H4E
8ED6:	rtn
8ED7:	ld	$16,&H46,jr &H8EDE
8EDB:	cal	&H8ED3
8EDE:	phs	$16
8EE0:	pre	ix,&H16D2
8EE4:	ldw	$18,(ix+$sx)
8EE6:	ldw	$16,$18
8EE9:	jr	&H8F18
8EEB:	sbc	$0,&H1C
8EEE:	rtn	c
8EEF:	phs	$16
8EF1:	pre	ix,&H16D2
8EF5:	ldw	$16,(ix+$sx)
8EF7:	ldw	$18,$16
8EFA:	jr	z,&H8F46
8EFC:	sbc	$0,&H1E
8EFF:	jr	nc,&H8F0B
8F01:	sbb	$19,$sy
8F03:	anc	$19,&HF0
8F06:	jr	z,&H8F16
8F08:	an	$19,&H0F
8F0B:	ld	$18,&H50
8F0E:	sbc	$16,&H50
8F11:	jr	nz,&H8F16
8F13:	ld	$18,&H46
8F16:	stw	$18,(ix+$sx)
8F18:	cal	&H6AF2
8F1B:	pre	ix,&H16B8
8F1F:	ldw	$20,(ix+$sx)
8F21:	sbcw	$18,$20
8F24:	ldw	$16,$18
8F27:	pps	$0
8F29:	jr	z,&H8F49
8F2B:	phs	$0
8F2D:	cal	&H6AC5
8F30:	pps	$0
8F32:	ad	$0,$sy
8F34:	ld	$16,$17
8F37:	or	$16,&H30
8F3A:	phs	$0
8F3C:	cal	&H6AC5
8F3F:	pps	$0
8F41:	cal	&H0397		;conditionally set the key repeat flag
8F44:	jr	&H8F65
8F46:	adb	$19,$sy,jr &H8F03
8F49:	sbc	$0,&H46
8F4C:	jr	z,&H8F2B
8F4E:	ldw	$16,&H3F3F
8F52:	jr	&H8F2B
8F54:	phsw	$18
8F56:	cal	&H6B18
8F59:	ppsw	$17
8F5B:	cal	&H6520		;display a string from bank 2
8F5E:	ldw	$10,&H7F00
8F62:	cal	&H977F
8F65:	cal	&H8F7D
8F68:	pre	ix,&H16D2
8F6C:	ldw	$16,(ix+$sx)
8F6E:	cal	&H6AF2
8F71:	cal	&H2991		;select the LCD as the output device
8F74:	jp	&H930F

8F77:	pre	ix,&H16B8
8F7B:	jr	&H8F81
8F7D:	pre	ix,&H16D2
8F81:	ldw	$13,(ix+$sx)
8F83:	sbc	$13,&H50
8F86:	jp	&H6B63
8F89:	pre	ix,&H16D2
8F8D:	ldw	$0,(ix+$sx)
8F8F:	phsw	$1
8F91:	pre	ix,&H16B8
8F95:	ldw	$0,(ix+$sx)
8F97:	cal	&H90BE
8F9A:	sbw	$4,$sy
8F9C:	sbcw	$2,$4
8F9F:	jr	nc,&H8FDE
8FA1:	sbw	$4,$2
8FA4:	ppsw	$2
8FA6:	sbcw	$2,$sz
8FA8:	jr	z,&H8FE0
8FAA:	phsm	$5,6
8FAD:	cal	&H45D1		;delete the current file
8FB0:	cal	&H33EE		;get starting/ending address of current file
8FB3:	ppsm	$0,6
8FB6:	sbc	$2,$sz
8FB8:	jr	nz,&H8FE3
8FBA:	phsw	$1
8FBC:	ldw	$0,$4
8FBF:	ldw	$2,$27
8FC2:	sbw	$2,$sy
8FC4:	cal	&H34B1		;expand a memory block in a RAM file
8FC7:	ppsw	$0
8FC9:	cal	&H90BE
8FCC:	ldw	$0,$25
8FCF:	sbw	$4,$2
8FD2:	sbw	$4,$sy
8FD4:	cal	&H014C		;block transfer within the RAM
8FD7:	sbc	$30,$sx		;Not Zero flag
8FD9:	rtn
8FDA:	ppsw	$0
8FDC:	jr	&H8FD7
8FDE:	ppsw	$0
8FE0:	sbc	$31,$sy
8FE2:	rtn
8FE3:	jr	c,&H902F
8FE5:	sbbm	$27,$27,3
8FE8:	phsw	$1
8FEA:	phsm	$29,3
8FED:	cal	&H29C5		;test the power switch and BRK key
8FF0:	ppsm	$27,3
8FF3:	ppsw	$0
8FF5:	phsw	$1
8FF7:	cal	&H90BE
8FFA:	sbw	$4,$sy
8FFC:	adw	$2,$28
8FFF:	pre	ix,&H1AD3
9003:	ld	$0,$sx
9005:	stw	$31,(ix+$sx)
9007:	pre	iz,$2
9009:	pre	ix,&H19D5
900D:	cal	&H9101
9010:	jr	c,&H8FDA
9012:	phsm	$29,3
9015:	cal	&H9753		;INCLR, clear the INTOP input buffer
9018:	sbw	$14,$14
901B:	pre	ix,&H1AD3
901F:	pre	iz,&H19D5
9023:	sbc	(iz+$sx),$31
9025:	cal	nz,&H4AF7
9028:	ppsm	$27,3
902B:	ppsw	$0
902D:	jr	&H8FE8
902F:	phsw	$3
9031:	cal	&H8F77
9034:	ppsw	$2
9036:	ldw	$0,$2
9039:	sbw	$28,$28
903C:	phsw	$1
903E:	phsw	$29
9040:	sbbm	$4,$4,4
9043:	sbw	$6,$sy
9045:	cal	&H5173		;LNSCH, search for a BASIC line $4,$5
9048:	ppsw	$28
904A:	gre	iz,$4
904C:	adw	$4,$28
904F:	pre	iz,$4
9051:	sbc	(iz+$sx),$31
9053:	jr	z,&H90B9
9055:	sbcw	(iz+$sy),$6
9057:	jr	z,&H905B
9059:	jr	nc,&H90B9
905B:	phsw	$29
905D:	phsw	$5
905F:	cal	&H508B		;ENLST
9062:	std	$31,(ix+$sx)
9064:	ppsw	$4
9066:	ppsw	$28
9068:	gre	iz,$6
906A:	sbw	$6,$4
906D:	adw	$28,$6
9070:	phsw	$29
9072:	pre	ix,&H1000
9076:	sbw	$14,$14
9079:	ldi	$16,(ix+$sx)
907B:	adc	$16,$sx
907D:	jr	nz,&H90A9
907F:	adc	$14,$sx
9081:	jr	z,&H90B7
9083:	ppsw	$28
9085:	ppsw	$0
9087:	phsw	$1
9089:	phsw	$29
908B:	cal	&H9133
908E:	pre	ix,&H1000
9092:	ldw	$16,&H0A0D
9096:	stw	$16,(ix+$sx)
9098:	ldw	$14,&H0002
909C:	ppsw	$28
909E:	ppsw	$0
90A0:	phsw	$1
90A2:	phsw	$29
90A4:	cal	&H9133
90A7:	jr	&H9040
90A9:	adw	$14,$sy
90AB:	gre	ix,$19
90AD:	phsw	$15
90AF:	cal	&H29C5		;test the power switch and BRK key
90B2:	ppsw	$14
90B4:	pre	ix,$19,jr &H9079
90B7:	ppsw	$28
90B9:	ppsw	$0
90BB:	sbc	$30,$sx		;Not Zero flag
90BD:	rtn
90BE:	pre	ix,&H18A7	;table of file addresses
90C2:	sbc	$0,&H50		;'P'
90C5:	jr	z,&H90CB
90C7:	pre	ix,&H18BB
90CB:	an	$1,&H0F
90CE:	phs	$1
90D0:	biu	$1
90D2:	ldm	$2,(ix+$1),4
90D5:	pps	$1
90D7:	rtn
90D8:	ldi	$0,(iz+$sx)
90DA:	adw	$28,$sy
90DC:	rtn
90DD:	sti	$0,(ix+$sx)
90DF:	ad	$1,$sy
90E1:	jp	c,&H2B74	;ST Error, string too long
90E4:	rtn
90E5:	ld	$0,&H0A
90E8:	sbc	(iz+$sx),$0
90EA:	cal	z,&H90D8
90ED:	ld	$0,$sx
90EF:	adc	$1,$sy
90F1:	cal	nc,&H90DD
90F4:	sbc	$30,$sx		;Not Zero flag
90F6:	rtn
90F7:	cal	&H90ED
90FA:	jr	&H90FE
90FC:	sbc	$31,$sy
90FE:	ld	$27,$sy
9100:	rtn
9101:	anc	$27,$sy
9103:	jr	nz,&H90FC
9105:	sbcw	$2,$4
9108:	jr	nc,&H90FC
910A:	sbw	$1,$1
910D:	cal	&H90D8
9110:	sbc	$0,&H1A
9113:	jr	z,&H90F7
9115:	sbc	$0,&H0D
9118:	jr	z,&H90E5
911A:	sbc	$0,&H0A
911D:	jr	z,&H90ED
911F:	sbc	$0,&H20
9122:	jr	c,&H910D
9124:	jr	z,&H912D
9126:	or	$2,$sy
9128:	cal	&H90DD
912B:	jr	&H910D
912D:	anc	$2,$sy
912F:	jr	nz,&H9128
9131:	jr	&H910D
9133:	cal	&H90BE
9136:	ldm	$25,$2,4
9139:	phsm	$5,4
913C:	ldw	$0,$14
913F:	ldw	$2,$27
9142:	sbw	$2,$sy
9144:	cal	&H34B1		;expand a memory block in a RAM file
9147:	ppsm	$2,4
914A:	ldw	$2,$4
914D:	sbw	$2,$sy
914F:	ldw	$4,$sz
9151:	ldw	$0,$2
9154:	ldw	$2,&H1000
9158:	jp	&H014C		;block transfer within the RAM

#if ROM_VERSION=2
; argument range checking of the NCR and NPR functions
915B:	sbc	$18,&H05
915E:	jr	nc,&H9166
9160:	sbc	$8,$sx
9162:	rtn	nz
9163:	sbc	$7,$sx
9165:	rtn	z
9166:	jp	&H2BA4		;BS Error, subscript out of range
#endif

; returns Not Zero if Japanese version or Zero if English version
9238:	phsw	$6
923A:	gpo	$5
923C:	gpo	$6
923E:	sbc	$5,$6
9241:	jr	nz,&H923A
9243:	anc	$5,&H10
9246:	ppsw	$5
9248:	rtn

9249:	phs	$0
924B:	cal	&H9937
924E:	pps	$0
9250:	jr	z,&H926F
9252:	sbc	$24,$sy
9254:	jr	nz,&H926F
9256:	anc	$23,&H06
9259:	jr	nz,&H926F
925B:	pre	ix,&H1113
925F:	ldd	$1,(ix+$sx)
9261:	ld	$0,&HFF
9264:	anc	$1,&H20
9267:	jr	z,&H926C
9269:	ld	$0,&H0F
926C:	jp	&H0291		;cursor bitmap in $11-$16 depending on $0,$1
926F:	jp	&H0288		;cursor bitmap in $11-$16 depending on KEYMD

9272:	phsm	$5,4
9275:	gre	ix,$2
9277:	phsw	$3
9279:	cal	&H9284
927C:	ppsw	$2
927E:	pre	ix,$2
9280:	ppsm	$2,4
9283:	rtn

9284:	cal	&H92BC
9287:	cal	&H92AC
928A:	ldw	$4,&H0002
928E:	cal	&H92CD
9291:	ad	$4,$sy
9293:	cal	&H92CD
9296:	pre	ix,&H1132
929A:	ldd	$5,(ix+$sx)
929C:	an	$5,&H03
929F:	sbc	$5,&H02
92A2:	jr	z,&H92CD
92A4:	sb	$4,$sy
92A6:	sbc	$5,$sy
92A8:	jr	z,&H92CD
92AA:	jr	&H92CA

92AC:	pre	ix,&H1113
92B0:	ldd	$5,(ix+$sx)
92B2:	an	$5,&H40
92B5:	xr	$5,&H40
92B8:	ld	$4,$sx
92BA:	jr	&H92CD
92BC:	ld	$5,$sx
92BE:	ld	$4,$sy
92C0:	pre	ix,&H16C4
92C4:	ldd	$3,(ix+$sx)
92C6:	anc	$3,$sy
92C8:	jr	z,&H92CD
92CA:	ld	$5,&H80
92CD:	ldw	$2,&HDE92
92D1:	ppo	&HFF
92D4:	stlm	$2,3
92D7:	ppo	&HFE
92DA:	stl	$5
92DC:	rtn

; $5,$6 <- address of the font table
92DD:	ldw	$5,&H0000	;Japanese font table
92E1:	cal	&H9238		;English or Japanese version?
92E4:	rtn	nz		;return if Japanese
92E5:	ldw	$5,&H0540	;English font table
92E9:	rtn

; set the initial value of the contrast data pointer ELVAD
92EA:	pre	ix,&H110B	;ELVAD, pointer to the contrast data
92EE:	ldw	$3,&H0D58
92F2:	stw	$3,(ix+$sx)
92F4:	rtn

92F5:	pre	ix,&H1102
92F9:	ld	$10,(ix+$sx)
92FB:	pre	ix,&H110A
92FF:	ldd	$11,(ix+$sx)
9301:	ad	$11,$10
9304:	sb	$11,$sy
9306:	phsm	$16,3
9309:	cal	&H977F
930C:	ppsm	$14,3
; DOTDS
930F:	ldw	$0,&H1109
9313:	ld	$0,($sz)
9315:	ld	$1,&H03
9318:	sb	$1,$sz
931A:	ld	$4,$sx
931C:	pre	ix,&H123C
9320:	cal	&H0205
9323:	ad	$4,$sy
9325:	sbc	$1,$4
9328:	jr	nc,&H9320
932A:	jp	&H01D8		;LCD on

; display a character from the LEDTP buffer at the position EDSCR
932D:	cal	&H01F2		;$2,$3 <- EDSCR address in the LEDTP buffer
9330:	cal	&H0262		;display a character, $2,$3=pointer to bitmap
9333:	pre	ix,&H1101
9337:	rtn

; CLEDB
9338:	ldw	$0,&H113B
933C:	ldw	$2,&H0401
9340:	cal	&H0157		;CLRME, clear memory block
9343:	pre	ix,&H1101
9347:	std	$31,(ix+$sx)
9349:	st	$31,(ix+$sy)
934B:	st	$31,(ix+&H04)
934E:	jp	&H9482

; This function is called upon EDCSR change. It modifies SCTOP when necessary,
; so that the cursor stays within the displayed area.
9351:	pre	ix,&H1101
9355:	ld	$0,(ix-$sy)	;LCDST
9357:	anc	$0,&H06
935A:	rtn	z
935B:	ld	$2,$sx
935D:	ld	$3,(ix+&H09)	;TOEDB
9360:	ldw	$0,(ix+$sx)	;$0=EDSCR, $1=SCTOP
9362:	sb	$0,$1
9365:	jr	c,&H9372	;branch if EDSCR<SCTOP
9367:	sbc	$0,$3
936A:	jr	c,&H9378	;branch if EDSCR<TOEDB
936C:	cal	&H02DF		;increment SCTOP by 32
936F:	ld	$2,$sy,jr &H9360
9372:	cal	&H02DD		;decrement SCTOP by 32
9375:	ld	$2,$sy,jr &H9360
9378:	sbc	$2,$sx		;test for 0
937A:	rtn

; put character $16 at the cursor position to both buffers EDTOP and LEDTP
937B:	pre	ix,&H1101
937F:	ldd	$0,(ix+$sx)	;EDSCR
9381:	ldd	$10,(ix-$sy)	;LCDST
9383:	pre	ix,&H113B	;EDTOP
9387:	std	$16,(ix+$sz)
9389:	cal	&H01F2		;$2,$3 <- EDSCR address in the LEDTP buffer
938C:	cal	&H0336		;creates a dot pattern for character $16
938F:	anc	$10,&H20	;reversed display?
9392:	rtn	z
9393:	invm	$4,6
9396:	stm	$4,(ix+$sx),6
9399:	rtn

939A:	ldw	$2,&H0528
939E:	cal	&H9238		;English or Japanese version?
93A1:	jr	nz,&H93A7	;skip if Japanese
93A3:	ldw	$2,&H0A68	;source address
93A7:	ldw	$0,&H153C	;destination address
93AB:	ldw	$4,&H0018	;number of transferred bytes
93AF:	jp	&H0EBB		;block transfer from bank 2 to bank 1

; print control codes and addresses of handler procedures
93B2:	02, 95A7	;line top
93B5:	05, 9573	;line del
93B8:	06, 95AE	;line end
93BB:	07, 33BA	;beep
93BE:	08, 95FC	;backspace
93C1:	09, 9504	;tab
93C4:	0B, 95E3	;home
93C7:	0C, 95F1	;cls
93CA:	0D, 95BF	;cr/lf
93CD:	11, 961A	;del
93D0:	12, 9632	;ins
93D3:	1C, 9559	;right
93D6:	1D, 9563	;left
93D9:	1E, 955E	;up
93DC:	1F, 9554	;down
93DF:	00, 9676

; OUTDV=&H00 or &H01, LCD
; display a character $16 on the LCD
93E2:	cal	&H9482
93E5:	pre	ix,&H93B2
93E9:	sbc	$16,&H20	;control character?
93EC:	jp	c,&H0166	;execute a procedure from the table if so
93EF:	sbc	$16,&H7F
93F2:	rtn	z
; printable character
93F3:	pre	ix,&H1739
93F7:	sbc	(ix+$sx),$30
93F9:	jr	nz,&H940E
93FB:	pre	ix,&H1101
93FF:	ldd	$0,(ix+$sx)
9401:	pre	ix,&H113B
9405:	std	$16,(ix+$sz)
9407:	pre	ix,&H1101
940B:	ad	(ix+$sx),$30
940D:	rtn
940E:	cal	&H937B		;put character $16 to buffers EDTOP and LEDTP
9411:	cal	&H932D
9414:	ldm	$0,(ix-$sy),8
9417:	sbc	$1,$4
941A:	jr	c,&H944B
941C:	phsw	$1
941E:	cal	&H2937
9421:	ppsw	$0
9423:	jr	nz,&H942D
9425:	cal	&H294F
9428:	sbc	$1,&H40
942B:	jr	nz,&H9433
942D:	cal	&H01ED
9430:	jp	nz,&H9451
9433:	sbc	$4,$7
9436:	jr	nz,&H944B
9438:	sbc	$3,$6
943B:	jr	nz,&H9442
943D:	anc	$0,&H09
9440:	jr	nz,&H944B
9442:	cal	&H96A4
9445:	cal	&H94F7
9448:	jp	&H9611
944B:	cal	&H94F7
944E:	jp	&H956A
9451:	adc	$7,$sy
9453:	jr	c,&H9461
9455:	pre	ix,&H1101
9459:	ad	(ix+$sx),$30
945B:	ad	(ix+&H06),$30
945E:	jp	&H956A
9461:	an	$6,&HE0
9464:	jr	z,&H945E
9466:	cal	&H96F8
9469:	pre	ix,&H1101
946D:	ldm	$0,(ix+$sx),7
9470:	sb	$0,&H1F
9473:	sb	$1,&H20
9476:	sb	$5,&H20
9479:	sb	$6,&H1F
947C:	stm	$0,(ix+$sx),7
947F:	jp	&H9611
9482:	cal	&H2937
9485:	jr	nz,&H9490
9487:	cal	&H294F
948A:	sbc	$1,&H40
948D:	jp	nz,&H029C
9490:	cal	&H01ED
9493:	jp	z,&H029C
9496:	pre	ix,&H1106
949A:	ldd	$0,(ix+$sx)
949C:	st	$0,(ix-$sy)
949E:	st	$0,(ix-&H03)
94A1:	ld	$0,(ix-&H05)
94A4:	pre	ix,&H113B
94A8:	sbc	(ix+$sz),$31
94AA:	jr	z,&H94B2
94AC:	ad	$0,$sy
94AE:	jr	nc,&H94A8
94B0:	sb	$0,$sy
94B2:	pre	ix,&H1104
94B6:	std	$0,(ix+$sx)
94B8:	st	$0,(ix+&H03)
94BB:	rtn
94BC:	pre	ix,&H1101
94C0:	ldim	$0,(ix+$sx),7
94C3:	sbc	$6,$sz
94C5:	jp	z,&H9676
94C8:	adc	$6,$sy
94CA:	jr	nc,&H94DF
94CC:	an	$5,&HE0
94CF:	jp	z,&H965C
94D2:	ld	$0,&H20
94D5:	sb	(ix-&H02),$0
94D8:	sb	(ix-$sy),$0
94DA:	cal	&H96A4
94DD:	jr	&H94F4
94DF:	an	$6,&H1F
94E2:	sbc	$6,&H1F
94E5:	jr	nz,&H94EF
94E7:	cal	&H9706
94EA:	cal	&H9482
94ED:	jr	&H94F4
94EF:	ad	(ix-&H04),$30
94F2:	ad	(ix-$sy),$30
94F4:	jp	&H9667
94F7:	pre	ix,&H1101
94FB:	ld	$0,(ix+&H06)
94FE:	sbc	(ix+$sx),$0
9500:	rtn	nc
9501:	ad	(ix+$sx),$30
9503:	rtn

; print control code &H09, tab
9504:	ldw	$2,&H070A
9508:	sb	$2,$sy
950A:	rtn	c
950B:	phsw	$3
950D:	ld	$16,&H20
9510:	cal	&H93E2
9513:	ppsw	$2
9515:	ldw	$0,&H1101
9519:	ld	$0,($sz)
951B:	an	$0,$3
951E:	jr	nz,&H9508
9520:	rtn

9521:	ld	$0,&H20,jr &H9527
9525:	ld	$0,$sy
; increment the cursor position by value specified in the $0 register
9527:	pre	ix,&H1101
952B:	ldd	$1,(ix+$sx)	;EDSCR, cursor position
952D:	ad	$1,$sz
952F:	rtn	c		;out of range, command failed
9530:	sbc	(ix+&H06),$1	;BOARE, cursor movement range bottom
9533:	rtn	c
9534:	jr	&H954B

9536:	ld	$0,&H20,jr &H953C
953A:	ld	$0,$sy
; decrement the cursor position by value specified in the $0 register
953C:	pre	ix,&H1101
9540:	ldd	$1,(ix+$sx)	;EDSCR, cursor position
9542:	sb	$1,$sz
9544:	rtn	c		;out of range, command failed
9545:	ld	$0,(ix+&H05)	;TOARE, cursor movement range top
9548:	sbc	$1,$sz
954A:	rtn	c
954B:	pre	ix,&H1101
954F:	std	$1,(ix+$sx)
9551:	sbc	$30,$sx		;Not Zero flag
9553:	rtn

; print control code &H1F, down
9554:	cal	&H9521		;increment the cursor position by 32
9557:	jr	&H9566

; print control code &H1C, right
9559:	cal	&H9525		;increment the cursor position by 1
955C:	jr	&H9566

; print control code &H1E, up
955E:	cal	&H9536		;decrement the cursor position by 32
9561:	jr	&H9566

; print control code &H1D, left
9563:	cal	&H953A		;decrement the cursor position by 1
9566:	rtn	c
9567:	cal	&H0393		;conditionally set the key repeat flag
956A:	cal	&H9351		;modify SCTOP when necessary
956D:	jp	z,&H9482
9570:	jp	&H9614

; print control code &H05, line del
9573:	pre	ix,&H1103
9577:	ld	$0,(ix+&H02)
957A:	ld	$1,(ix+$sy)
957C:	ad	$1,$sy
957E:	sb	$1,$sz
9580:	jp	z,&H95F7
9583:	cal	&H971D
9586:	pre	ix,&H1101
958A:	ld	$0,(ix+&H04)
958D:	std	$0,(ix+$sx)
958F:	jp	&H9611
9592:	pre	ix,&H1103
9596:	ld	$0,(ix-&H02)
9599:	ld	$1,(ix+$sy)
959B:	ad	$1,$sy
959D:	sb	$1,$sz
959F:	jr	z,&H95F7
95A1:	cal	&H971D
95A4:	jp	&H9611

; print control code &H02, line top
95A7:	ldw	$0,&H1105
95AB:	ld	$0,($sz),jr &H95B1

; print control code &H06, line end
95AE:	cal	&H02E3
95B1:	pre	ix,&H1101
95B5:	jr	&H958D
95B7:	pre	ix,&H1101
95BB:	std	$0,(ix+$sx)
95BD:	jr	&H956A

; print control code &H0D, cr/lf
95BF:	cal	&H01ED
95C2:	jp	nz,&H9676
95C5:	pre	ix,&H1101
95C9:	ldd	$0,(ix+$sx)
95CB:	an	$0,&HE0
95CE:	ad	$0,&H20
95D1:	jr	nc,&H95B7
95D3:	cal	&H02E3
95D6:	an	$0,&HE0
95D9:	ad	$0,&H20
95DC:	jr	nc,&H95B7
95DE:	cal	&H96A4
95E1:	jr	&H95D3

; print control code &H0B, home
95E3:	cal	&H01ED
95E6:	jr	nz,&H95A7
95E8:	pre	ix,&H1101
95EC:	std	$31,(ix+$sx)
95EE:	jp	&H956A

; print control code &H0C, cls
95F1:	cal	&H01ED
95F4:	jp	nz,&H9573
95F7:	cal	&H9338
95FA:	jr	&H9611

; print control code &H08, backspace
95FC:	pre	ix,&H1102
9600:	ld	$0,(ix+$sy)
9602:	sbc	(ix-$sy),$0
9604:	jr	z,&H9676
9606:	sb	(ix-$sy),$30
9608:	cal	&H02FE
960B:	cal	&H96D0
960E:	cal	&H0393		;conditionally set the key repeat flag
9611:	cal	&H9351		;modify SCTOP when necessary
9614:	cal	&H92F5
9617:	jp	&H9482

; print control code &H11, del
961A:	cal	&H02E3
961D:	sbc	(ix-&H03),$0
9620:	jr	c,&H9608
9622:	cal	&H01FF
9625:	jr	z,&H9676
9627:	ld	$1,$sy
9629:	pre	ix,&H1103
962D:	cal	&H971D
9630:	jr	&H960E

; print control code &H12, ins
9632:	cal	&H2937
9635:	jr	nz,&H963F
9637:	cal	&H294F
963A:	sbc	$1,&H40
963D:	jr	nz,&H9645
963F:	cal	&H01ED
9642:	jp	nz,&H94BC
9645:	cal	&H02FE
9648:	cal	&H02E3
964B:	sbc	(ix-&H03),$0
964E:	jr	nc,&H9676
9650:	ldd	$1,(ix+$sx)
9652:	sbc	$0,$1
9655:	jr	c,&H9667
9657:	cal	&H9679
965A:	jr	nc,&H9667
965C:	pre	ix,&H1107
9660:	ldd	$0,(ix+$sx)
9662:	cal	&H01FF
9665:	jr	nz,&H9676
9667:	cal	&H96C5
966A:	phs	$16
966C:	ld	$16,&H20
966F:	cal	&H937B		;put character $16 to buffers EDTOP and LEDTP
9672:	pps	$16
9674:	jr	&H960E
9676:	sbc	$31,$sy
9678:	rtn
9679:	pre	ix,&H1100
967D:	ldm	$0,(ix+$sx),8
9680:	sbc	$4,$7
9683:	jr	z,&H9698
9685:	ad	$4,&H20
9688:	ld	$0,$4
968B:	cal	&H02F2
968E:	sb	$4,&H20
9691:	sbc	$4,$sz
9693:	cal	c,&H9706
9696:	jr	&H96C2
9698:	anc	$0,&H08
969B:	jp	nz,&H9676
969E:	sbc	$3,$6
96A1:	jp	z,&H9676
96A4:	cal	&H96F8
96A7:	ld	$1,&H20
96AA:	pre	ix,&H1101
96AE:	sb	(ix+$sx),$1
96B0:	jr	nc,&H96B4
96B2:	ad	(ix+$sx),$1
96B4:	sb	(ix+$sy),$1
96B6:	jr	nc,&H96BA
96B8:	ad	(ix+$sy),$1
96BA:	sb	(ix+&H04),$1
96BD:	jr	nc,&H96C2
96BF:	ad	(ix+&H04),$1
96C2:	jp	&H9482

96C5:	pre	ix,&H1101
96C9:	ldi	$0,(ix+$sx)
96CB:	ld	$2,$sy
96CD:	ad	$2,$sz,jr &H96DB
96D0:	pre	ix,&H1101
96D4:	ldi	$2,(ix+$sx)
96D6:	ld	$0,$sy
96D8:	ad	$0,$2
96DB:	std	$0,(ix+$sy)
96DD:	ld	$1,(ix+$sy)
96DF:	st	$2,(ix+$sy)
96E1:	ld	$0,(ix-&H02)
96E4:	sb	$1,$sz
96E6:	st	$1,(ix+&H05)	;EDCNT
; move $1 character positions from the position TOEDB to the position $0 in
; the LEDTP buffer
96E9:	cal	&H972B		;destination address $2,$3 = LEDTP+6*BOEDB
96EC:	pre	iy,$2
96EE:	ld	$0,(ix-$sy)	;character position <- TOEDB
96F0:	cal	&H01FF		;source address $2,$3 <- LEDTP+6*$0
96F3:	gre	iy,$0
96F5:	jp	&H0155		;SHFTM, move memory block

96F8:	pre	ix,&H1103
96FC:	ldw	$0,&H0020
9700:	stw	$0,(ix+$sx)
9702:	ld	$1,&HE0,jr &H96E6
9706:	pre	ix,&H1103
970A:	ld	$0,(ix+$sy)
970C:	ad	$0,$sy
970E:	ld	$1,$sz
9710:	ad	$1,&H20
9713:	jr	c,&H971A
9715:	stw	$0,(ix+$sx)
9717:	cmp	$1,jr &H96E6
971A:	ld	$1,&H20
971D:	st	$1,(ix+&H05)
9720:	st	$0,(ix+$sy)
9722:	cal	&H972B
9725:	ldm	$0,$2,4
9728:	jp	&H0157		;CLRME, clear memory block
972B:	ld	$0,(ix+$sy)
972D:	cal	&H01FF
9730:	pre	ix,&H1104
9734:	ld	$4,(ix+&H04)
9737:	ld	$5,$sx
9739:	rtn
973A:	sbc	(ix+$sz),$1
973C:	jr	z,&H9741
973E:	jr	c,&H9741
9740:	rtn
9741:	st	$31,(ix+$sz)
9743:	sbc	$3,$sz
9745:	rtn	z
9746:	sb	$0,$sy
9748:	sbc	(ix+$sz),$1
974A:	jr	z,&H9741
974C:	rtn

974D:	cal	&H02FE		;process the logical line: EDCNT, fill the gaps
9750:	cal	&H973A		;append zero to the string in the logical line
; INCLR:
; clear the INTOP input buffer (&H1000-&H10FF)
9753:	ldw	$0,&H1000	;address
9757:	ldw	$2,&H0100	;number of bytes
975B:	jp	&H0157		;CLRME, clear memory block

; clears the INTOP buffer
; returns in IZ the address of the top logical line in the EDTOP buffer
975E:	cal	&H974D
9761:	pre	iz,&H1105	;MOEDB, logical line top at the time of INPUT
9765:	ldd	$0,(iz+$sx)
9767:	pre	iz,&H113B	;EDTOP buffer
976B:	ldd	$1,(iz+$sz)	;IZ <- EDTOP + (MOEDB)
976D:	rtn

; PF display, 3-line scroll
976E:	ldw	$0,&H6001
9772:	jr	&H9778
; Normal display, 4-line scroll
9774:	ldw	$0,&H8000
9778:	pre	ix,&H1109	;DSPMD, SCROL
977C:	stw	$0,(ix+$sx)
977E:	rtn

; DOTMK:
977F:	ldw	$2,&H123C
9783:	phsm	$14,4
9786:	sb	$11,$10
9789:	gst	ua,$12
978B:	gre	iz,$13
978D:	pst	ua,&H54
9790:	pre	iz,&H113B
9794:	ldd	$16,(iz+$10)
9797:	ldi	$16,(iz+$sx)
9799:	cal	&H033A
979C:	ldm	$4,(ix+$sx),6
979F:	pst	ua,$0
97A1:	pre	ix,$2
97A3:	stim	$4,(ix+$sx),6
97A6:	gre	ix,$2
97A8:	sb	$11,$sy
97AA:	jr	nc,&H9797
97AC:	pre	iz,$13
97AE:	pst	ua,$12
97B0:	ppsm	$11,4
97B3:	rtn

; display a string prefixed with a length byte, contained in the ROM, pointed
; to by $15,$16
97B4:	gst	ua,$14
97B6:	pst	ua,&H44
97B9:	ld	$17,($15)	;length
97BC:	adw	$15,$sy
; the string is copied to RAM then displayed
97BE:	ld	$4,$17		;number of bytes
97C1:	ld	$5,$sx
97C3:	ldw	$2,$15		;source pointer
97C6:	ldw	$0,&H165E	;destination pointer = WORK1
97CA:	cal	&H00F9		;block transfer
97CD:	pst	ua,$14
97CF:	pre	ix,&H165E	;WORK1
97D3:	jr	&H97D7

; PRLB1:
; display a string of length $17 pointed to by $15,$16
97D5:	pre	ix,$15
97D7:	sb	$17,$sy
97D9:	rtn	c
97DA:	ldi	$16,(ix+$sx)
97DC:	gre	ix,$14
97DE:	cal	&H2AF1		;display character $16
97E1:	pre	ix,$14,jr &H97D7

97E4:	pre	us,&H1CC1
97E8:	ppum	$15,7
97EB:	ppum	$22,8
97EE:	pre	iz,$15
97F0:	ldw	$2,&H9F5C
97F4:	cal	&H297A		;BRSTR, set ACJMP
97F7:	cal	&H031B		;cursor display enable
97FA:	an	$23,&HF9,jr &H980E
97FE:	pre	ss,&H1BD7
9802:	cal	&H988C
9805:	pre	ix,&H168E
9809:	ldw	$4,(ix+$sx)
980B:	jp	&H9DE4
980E:	cal	&H996C
9811:	cal	&H99DB
;
9814:	pre	ss,&H1BD7
9818:	an	$24,&H7F
981B:	pre	us,&H1CD0
981F:	gre	iz,$15
9821:	phum	$29,8
9824:	phum	$21,7
9827:	cal	&H23C8
982A:	sbc	$0,&HFD
982D:	jr	nz,&H9832
982F:	ld	$0,&H0D
9832:	ld	$16,$sz
9834:	sbc	$0,&H80
9837:	jr	c,&H9859
9839:	sbc	$0,&HA6
983C:	jr	c,&H9871
983E:	sbc	$0,&HE0
9841:	jr	c,&H984E
9843:	sbc	$0,&HF0
9846:	jr	c,&H987C
9848:	an	$16,&H0F
984B:	or	$16,&H30
984E:	anc	$23,&H06
9851:	jp	z,&H9AED
9854:	cal	&H2AE3		;display character $16
9857:	jr	&H9814
9859:	sbc	$0,&H20
985C:	jr	nc,&H984E
985E:	anc	$23,&H06
9861:	jr	nz,&H9869
9863:	pre	ix,&H47CF
9867:	jr	&H9889
9869:	sbc	$0,&H0D
986C:	jr	nz,&H9854
986E:	jp	&H9DC8
9871:	anc	$23,&H06
9874:	jp	z,&H9A84
9877:	cal	&H2143
987A:	jr	&H9814
987C:	pre	ix,&H4820
9880:	anc	$23,&H06
9883:	jr	nz,&H9889
9885:	pre	ix,&H4802
9889:	jp	&H9F62		;execute a procedure from the table in bank 2

988C:	ld	$0,$sx
988E:	pre	ix,&H16D1	;size of the free space at the end of the file
9892:	stw	$31,(ix+$sx)	;set to 0
9894:	cal	&H33E8		;get starting/ending address of the text file
9897:	cal	&H98FD		;increase the file size by 256 bytes
989A:	pre	iz,$25		;current pointer <- starting address
989C:	gre	iz,$19		;pointer to the current text line
989E:	ldw	$17,$sy		;current text line number
98A0:	ldw	$23,&H0100
98A4:	ld	$29,$sy
98A6:	pre	ix,&H1BEF
98AA:	std	$31,(ix+$sx)
98AC:	ldw	$0,&H16C4
98B0:	st	&H86,($sz)
98B3:	ldw	$2,&H9F5C	;jump address
98B7:	cal	&H297A		;BRSTR, set ACJMP
98BA:	cal	&H031B		;cursor display enable
98BD:	cal	&H9343
98C0:	jp	&H976E		;PF display, 3-line scroll

; insert $0,$1 bytes in the edited file at address $2,$3
98C3:	pre	ix,&H16D1	;size of the free space at the end of the file
98C7:	sbcw	(ix+$sx),$0	;is there enough free space?
98C9:	jr	nc,&H98DC	;skip if so
; the free space at the end of the file needs to be increased
98CB:	phsm	$3,4
98CE:	cal	&H98FD		;increase the file size by 256 bytes
98D1:	ppsm	$0,4
98D4:	pre	ix,&H16D1	;size of the free space at the end of the file
98D8:	sbcw	(ix+$sx),$0	;is there enough free space?
98DA:	jr	c,&H98F4	;error if not
98DC:	ldw	$6,(ix+$sx)
98DE:	sbw	(ix+$sx),$0	;decrease the free space at the end of the file
98E0:	phsw	$1
98E2:	adw	$0,$2
98E5:	ldw	$4,$27		;ending address of the file
98E8:	sbw	$4,$2
98EB:	sbw	$4,$6
98EE:	cal	&H014C		;block transfer within the RAM
98F1:	ppsw	$0
98F3:	rtn
98F4:	pre	us,&H1CCF
98F8:	phuw	$28
98FA:	jp	&H2B6D		;OM Error, insufficient memory

; increase the file size by 256 bytes (or less if out of memory)
98FD:	pre	ix,&H18CF
9901:	ldm	$0,(ix+$sx),4	;$0,$1 <- MEMEN, $2,$3 <- top of the RAM
9904:	sbw	$2,$sz		;$2,$3  <- free memory area size
9906:	rtn	z
9907:	ldw	$0,&H0100	;256 bytes
990B:	sbcw	$2,$sz
990D:	jr	nc,&H9912	;skip if there's enough free memory
990F:	ldw	$0,$2
9912:	ldw	$2,$27
9915:	sbw	$2,$sy
9917:	cal	&H34B1		;expand a memory block in a RAM file
991A:	pre	ix,&H16D1	;size of the free space at the end of the file
991E:	adw	(ix+$sx),$0
9920:	rtn

; delete $2,$3 bytes in the edited file at address $0,$1
9921:	pre	ix,&H16D1	;size of the free space at the end of the file
9925:	ldw	$6,(ix+$sx)
9927:	adw	(ix+$sx),$2	;increase the free space
9929:	adw	$2,$sz		;$2,$3 = source block lower address
992B:	ldw	$4,$27		;ending address of the file
992E:	sbw	$4,$2
9931:	sbw	$4,$6		;$4,$5 = number of transferred bytes
9934:	jp	&H014C		;block transfer within the RAM

9937:	pre	ix,&H16C4
993B:	ld	$0,(ix+$sy)
993D:	anc	$0,&H0E
9940:	rtn	z
9941:	ldd	$0,(ix+$sx)
9943:	anc	$0,&H80
9946:	rtn	z
9947:	anc	$0,&H04
994A:	rtn	z
994B:	anc	$0,&H02
994E:	rtn
994F:	cal	&H9937
9952:	rtn	z
9953:	an	$0,&H7F
9956:	std	$0,(ix+$sx)
9958:	cal	&H33E8		;get starting/ending address of the text file
995B:	pre	ix,&H16D1
995F:	ldw	$2,(ix+$sx)
9961:	ldw	$0,$27
9964:	sbw	$0,$sy
9966:	sbw	$0,$2
9969:	jp	&H34EA		;shrink a memory block in a RAM file
996C:	gre	iz,$21
996E:	pre	iz,$19
9970:	ldw	$2,&H6060
9974:	ldw	$4,$17
9977:	ldw	$6,&H0A00
997B:	ldw	$8,&H1A0D
997F:	pre	ix,&H113B
9983:	gre	iz,$0
9985:	sbcw	$21,$sz
9987:	jr	nz,&H9994
9989:	sb	$2,$3
998C:	ldw	$0,&H1101
9990:	st	$2,($sz)
9992:	ld	$6,$sy
9994:	ldi	$0,(iz+$sx)
9996:	sbc	$8,$sz
9998:	jr	z,&H99BA
999A:	sbc	$9,$sz
999C:	jr	z,&H99D3
999E:	sti	$0,(ix+$sx)
99A0:	sb	$3,$sy
99A2:	jr	nz,&H9983
99A4:	pre	iz,$21
99A6:	pre	ix,&H16D3
99AA:	stw	$4,(ix+$sx)
99AC:	anc	$24,&H80
99AF:	rtn	nz
99B0:	ldw	$10,&H5F00
99B4:	cal	&H977F
99B7:	jp	&H930F
99BA:	sbc	(iz+$sx),$7
99BC:	jr	nz,&H99C0
99BE:	ldd	$0,(iz+$sy)
99C0:	sbc	$6,$sx
99C2:	jr	nz,&H99C6
99C4:	adw	$4,$sy
99C6:	sti	$31,(ix+$sx)
99C8:	sb	$3,$sy
99CA:	jr	z,&H99A4
99CC:	anc	$3,&H1F
99CF:	jr	nz,&H99C6
99D1:	jr	&H9983
99D3:	sti	$31,(ix+$sx)
99D5:	sb	$3,$sy
99D7:	jr	nz,&H99D3
99D9:	jr	&H99A4
99DB:	gre	iz,$21
99DD:	cal	&H5D57
99E0:	phsw	$18
99E2:	pre	ix,&H16D3
99E6:	ldw	$17,(ix+$sx)
99E8:	cal	&H5CE3
99EB:	ppsw	$17
99ED:	pre	iz,$21
99EF:	jp	&H5D1E
99F2:	cal	&H7BDD
99F5:	jr	&H9A0C
99F7:	cal	&H21A7
99FA:	jr	&H9A0C
99FC:	cal	&H21AA
99FF:	jr	&H9A0C
9A01:	cal	&H2354
9A04:	jr	&H9A0C
9A06:	cal	&H22F2
9A09:	cal	&H2ADB
9A0C:	jp	&H9814
9A0F:	gre	iz,$21
9A11:	cal	&H0B4A
9A14:	pre	ix,&H18D3
9A18:	ld	$0,&HFF
9A1B:	ldi	$1,(iz+$sx)
9A1D:	sbc	$1,&H0D
9A20:	jr	z,&H9A31
9A22:	sbc	$1,&H1A
9A25:	jr	z,&H9A31
9A27:	sti	$1,(ix+$sx)
9A29:	sb	$0,$sy
9A2B:	jr	nz,&H9A1B
9A2D:	std	$31,(ix+$sx)
9A2F:	jr	&H9A35
9A31:	ldd	$1,(iz-$sy)
9A33:	std	$31,(ix+$sx)
9A35:	gre	iz,$0
9A37:	sbcw	$21,$sz
9A39:	jp	nc,&H9C11
9A3C:	jp	&H9B6E
9A3F:	rtn
9A40:	ldw	$0,&H18D3
9A44:	pre	ix,$0
9A46:	pre	iy,&H19D4
9A4A:	sup	$31
9A4C:	gre	ix,$13
9A4E:	sbw	$13,$sz
9A50:	jr	z,&H9A0C
9A52:	jr	&H9AB5
9A54:	cal	&H9A61
9A57:	jr	&H9AB5
9A59:	cal	&H9A5E
9A5C:	jr	&H9AB5
9A5E:	ld	$0,$sx,jr &H9A63
9A61:	ld	$0,$sy
9A63:	phs	$27
9A65:	phsm	$22,6
9A68:	cal	&H21CC
9A6B:	cal	&H13A7
9A6E:	ldw	$0,$15
9A71:	ld	$13,$17
9A74:	ld	$14,$sx
9A76:	ppsm	$17,6
9A79:	pps	$27
9A7B:	rtn
9A7C:	biu	$14
9A7E:	rtn	nc
9A7F:	sti	$0,(ix+$sx)
9A81:	ad	$13,$sy
9A83:	rtn
9A84:	cal	&H217F
9A87:	pre	ix,&H165E
9A8B:	ld	$13,$sx
9A8D:	ldi	$0,(iz+$sx)
9A8F:	anc	$0,&H80
9A92:	jr	nz,&H9A99
9A94:	sti	$0,(ix+$sx)
9A96:	ad	$13,$sy,jr &H9A8D
9A99:	an	$0,&H7F
9A9C:	cal	&H9A7F
9A9F:	ld	$0,&H28
9AA2:	cal	&H9A7C
9AA5:	ld	$0,&H20
9AA8:	cal	&H9A7C
9AAB:	pre	iz,$11
9AAD:	pst	ua,$10
9AAF:	ldw	$0,&H165E
9AB3:	ld	$14,$sx
9AB5:	anc	$24,$sy
9AB7:	jr	nz,&H9AD1
9AB9:	ldw	$2,&H0D1A
9ABD:	sbc	(iz+$sx),$2
9ABF:	jr	z,&H9AD1
9AC1:	sbc	(iz+$sx),$3
9AC3:	jr	z,&H9AD1
9AC5:	ld	$4,($sz)
9AC7:	adw	$0,$sy
9AC9:	sti	$4,(iz+$sx)
9ACB:	sbw	$13,$sy
9ACD:	jr	nz,&H9ABD
9ACF:	jr	&H9AEA
9AD1:	phsw	$1
9AD3:	ldw	$0,$13
9AD6:	gre	iz,$2		;address where to insert
9AD8:	cal	&H98C3		;insert $0,$1 bytes in the edited file
9ADB:	ppsw	$2
9ADD:	ldw	$4,$sz
9ADF:	ldw	$6,$sz
9AE1:	gre	iz,$0
9AE3:	adw	$6,$sz
9AE5:	pre	iz,$6
9AE7:	cal	&H00F9		;block transfer
9AEA:	jp	&H9B6E

; text editor, key code &H0D (EXE)
9AED:	anc	$24,$sy
9AEF:	jr	z,&H9B0D
9AF1:	ldw	$0,$sy
9AF3:	sbc	$16,&H0D
9AF6:	jr	nz,&H9AFA
9AF8:	ad	$0,$sy
9AFA:	gre	iz,$2		;address where to insert
9AFC:	cal	&H98C3		;insert $0,$1 bytes in the edited file
9AFF:	sti	$16,(iz+$sx)
9B01:	sbc	$16,&H0D
9B04:	jr	nz,&H9B6E
9B06:	ld	$16,&H0A
9B09:	sti	$16,(iz+$sx)
9B0B:	jr	&H9B6E
9B0D:	sbc	$16,&H0D
9B10:	jr	z,&H9AF1
9B12:	ldw	$0,&H1A0D
9B16:	sbc	(iz+$sx),$0
9B18:	jr	z,&H9AF1
9B1A:	sbc	(iz+$sx),$1
9B1C:	jr	z,&H9AF1
9B1E:	jr	&H9AFF

; text editor, key code &H1C (right)
9B20:	or	$24,&H80
9B23:	ld	$0,&H1A
9B26:	sbc	(iz+$sx),$0
9B28:	jp	z,&H9814
9B2B:	ldd	$0,(iz+$sy)
9B2D:	ldw	$1,&H0A0D	;CR LF
9B31:	sbcw	(iz-$sy),$1
9B33:	jr	nz,&H9B6B
9B35:	ldd	$0,(iz+$sy)
9B37:	jr	&H9B6B

; text editor, key code &H06 (line end)
9B39:	cal	&H0B56		;increment pointer IZ by 32 characters
9B3C:	sbc	$2,$sx		;was pointer IZ moved by 32 characters?
9B3E:	jr	z,&H9B39	;branch if so
9B40:	jr	&H9B6E
9B42:	ld	$0,&H20
9B45:	sb	$0,$2
9B48:	pre	ix,&H1101
9B4C:	ldd	$2,(ix+$sx)
9B4E:	an	$2,&H1F
9B51:	rtn

; text editor, key code &H1F (down)
9B52:	gre	iz,$21
9B54:	or	$24,&H80
9B57:	cal	&H0B56		;increment pointer IZ by 32 characters
9B5A:	jr	c,&H9BB9	;branch if the end of the line was reached
9B5C:	sbc	$2,$sx		;was pointer IZ moved by 32 characters?
9B5E:	jr	z,&H9B6B	;branch if so
9B60:	cal	&H9B42
9B63:	ad	$0,$2
9B66:	sbc	$0,&H20
9B69:	jr	c,&H9BDF
9B6B:	cal	&H0397		;conditionally set the key repeat flag
9B6E:	gre	iz,$21
9B70:	pre	iz,$19
9B72:	ld	$1,&H5F
9B75:	ldi	$0,(iz+$sx)
9B77:	sbc	$0,&H1A
9B7A:	jr	z,&H9BB4
9B7C:	sbc	$0,&H0D
9B7F:	jr	nz,&H9B8D
9B81:	an	$1,&HE0
9B84:	ld	$0,&H0A
9B87:	sbc	(iz+$sx),$0
9B89:	jr	nz,&H9B8D
9B8B:	ldd	$0,(iz+$sy)
9B8D:	sb	$1,$sy
9B8F:	jr	nc,&H9B75
9B91:	gre	iz,$0
9B93:	sbcw	$21,$sz
9B95:	jr	c,&H9BB4
9B97:	an	$24,&H7F
9B9A:	pre	iz,$19
9B9C:	cal	&H0B56		;increment pointer IZ by 32 characters
9B9F:	gre	iz,$19
9BA1:	pre	iz,$21
9BA3:	jr	nc,&H9B6E
9BA5:	adw	$17,$sy
9BA7:	adw	$19,$sy
9BA9:	ld	$1,($19)
9BAC:	sbc	$1,&H0A
9BAF:	jr	nz,&H9B6E
9BB1:	adw	$19,$sy,jr &H9B6E
9BB4:	pre	iz,$21
9BB6:	jp	&H980E
9BB9:	ldd	$0,(iz+$sy)
9BBB:	sbc	$0,&H0A
9BBE:	jr	nz,&H9BC2
9BC0:	ldd	$0,(iz+$sy)
9BC2:	cal	&H9B42
9BC5:	jr	z,&H9B6B
9BC7:	ad	$0,$2
9BCA:	sbc	$0,&H20
9BCD:	jr	nc,&H9BD4
9BCF:	cal	&H0B58		;increment pointer IZ by 32 characters
9BD2:	jr	&H9B6B
9BD4:	ldd	$0,(iz-$sy)
9BD6:	sbc	$0,&H0A
9BD9:	jr	nz,&H9B6B
9BDB:	ldd	$0,(iz-$sy)
9BDD:	jr	&H9BD2
9BDF:	pre	iz,$21
9BE1:	jp	&H9814

; text editor, key code &H1D (left)
9BE4:	or	$24,&H80
9BE7:	gre	iz,$0
9BE9:	sbcw	$25,$sz
9BEB:	jr	z,&H9BE1
9BED:	ldd	$0,(iz-$sy)
9BEF:	ldw	$0,&H0A0D	;CR LF
9BF3:	sbcw	(iz-$sy),$0
9BF5:	jr	nz,&H9C0E
9BF7:	ldd	$0,(iz-$sy)
9BF9:	jr	&H9C0E

; text editor, key code &H02 (line top)
9BFB:	cal	&H0B4A
9BFE:	jr	&H9C11

; text editor, key code &H1E (up)
9C00:	or	$24,&H80
9C03:	gre	iz,$21
9C05:	cal	&H0B64		;decrement pointer IZ by 32 characters
9C08:	jr	c,&H9C3C	;branch if the end of the previous line reached
9C0A:	sbc	$2,$sx		;was pointer IZ moved by 32 characters?
9C0C:	jr	nz,&H9BDF	;branch if not
9C0E:	cal	&H0397		;conditionally set the key repeat flag
9C11:	gre	iz,$21
9C13:	sbcw	$21,$19
9C16:	jr	nc,&H9BB6
9C18:	an	$24,&H7F
9C1B:	pre	iz,$19
9C1D:	cal	&H0B64		;decrement pointer IZ by 32 characters
9C20:	jr	nc,&H9C37	;branch if the end of previous line not reached
9C22:	sbw	$17,$sy
9C24:	gre	iz,$10
9C26:	cal	&H0B64		;decrement pointer IZ by 32 characters
9C29:	sbc	$2,$sx		;was pointer IZ moved by 32 characters?
9C2B:	jr	z,&H9C26	;branch if so
9C2D:	ld	$0,&H20
9C30:	sb	$0,$2
9C33:	pre	iz,$10
9C35:	ldd	$0,(iz-$sz)
9C37:	gre	iz,$19
9C39:	pre	iz,$21,jr &H9C11
9C3C:	gre	iz,$10
9C3E:	cal	&H0B64		;decrement pointer IZ by 32 characters
9C41:	sbc	$2,$sx		;was pointer IZ moved by 32 characters?
9C43:	jr	z,&H9C3E	;branch if so
9C45:	ld	$0,&H20
9C48:	sb	$0,$2
9C4B:	pre	ix,&H1101
9C4F:	ldd	$2,(ix+$sx)
9C51:	an	$2,&H1F
9C54:	sb	$0,$2
9C57:	pre	iz,$10
9C59:	jr	c,&H9C0E
9C5B:	ldd	$0,(iz-$sz)
9C5D:	jr	&H9C0E

; text editor, key code &H11 (del)
9C5F:	ld	$0,&H1A
9C62:	sbc	(iz+$sx),$0
9C64:	jr	z,&H9C7B
9C66:	ldw	$0,&H0A0D	;CR LF
9C6A:	sbcw	(iz+$sx),$0
9C6C:	jr	z,&H9C74
9C6E:	cal	&H9CC3		;delete 1 byte
9C71:	jp	&H980E
9C74:	cal	&H9CC6		;delete 2 bytes
9C77:	jr	&H9C71

; text editor, key code &H12 (ins)
9C79:	xr	$24,$sy
9C7B:	jp	&H9814

; text editor, key code &H08 (backspace)
9C7E:	gre	iz,$0
9C80:	sbcw	$25,$sz
9C82:	jr	z,&H9C7B
9C84:	ldd	$0,(iz-$sy)
9C86:	ldw	$1,&H0A0D	;CR LF
9C8A:	sbcw	(iz-$sy),$1
9C8C:	jr	nz,&H9CBC
9C8E:	ldd	$0,(iz-$sy)
9C90:	phs	$0
9C92:	cal	&H9CC6		;delete 2 bytes
9C95:	pps	$0
9C97:	gre	iz,$21
9C99:	sbcw	$21,$19
9C9C:	jp	nc,&H9C11
9C9F:	sbc	$0,&H0D
9CA2:	jr	nz,&H9CA6
9CA4:	sbw	$17,$sy
9CA6:	cal	&H0B64		;decrement pointer IZ by 32 characters
9CA9:	sbc	$2,$sx		;was pointer IZ moved by 32 characters?
9CAB:	jr	z,&H9CA6	;branch if so
9CAD:	ld	$0,&H20
9CB0:	sb	$0,$2
9CB3:	pre	iz,$21
9CB5:	ldd	$0,(iz-$sz)
9CB7:	gre	iz,$19
9CB9:	pre	iz,$21,jr &H9C71
9CBC:	phs	$0
9CBE:	cal	&H9CC3		;delete 1 byte
9CC1:	jr	&H9C95

9CC3:	ldw	$2,$sy,jr &H9CCA
9CC6:	ldw	$2,&H0002
9CCA:	gre	iz,$0		;address where to delete
9CCC:	cal	&H9921		;delete $2,$3 bytes in the edited file
9CCF:	jp	&H0397		;conditionally set the key repeat flag

; text editor, key codes &H0B (home), &H10 ([S]+up)
9CD2:	ldw	$17,$sy
9CD4:	ldw	$19,$25
9CD7:	pre	iz,$25
9CD9:	jp	&H980E

; text editor, key code &H09 (tab)
9CDC:	cal	&H293B
9CDF:	ldw	$0,&H1101
9CE3:	ld	$1,($sz)
9CE5:	ld	$0,&H07
9CE8:	jr	z,&H9CED
9CEA:	ld	$0,&H03
9CED:	an	$1,$sz
9CEF:	sb	$0,$1
9CF2:	ad	$0,$sy
9CF4:	sbc	$0,$sx
9CF6:	jr	z,&H9C7B
9CF8:	pre	ix,&H165E
9CFC:	ldw	$13,&H2000
9D00:	sti	$14,(ix+$sx)
9D02:	ad	$13,$sy
9D04:	sb	$0,$sy
9D06:	jr	nz,&H9D00
9D08:	jp	&H9AAF

; text editor, key codes &H05 (line del), &H0C (CLS)
9D0B:	cal	&H0B4A
9D0E:	gre	iz,$0
9D10:	ldw	$21,$sz
9D12:	sbcw	$19,$sz
9D14:	jr	c,&H9D18
9D16:	ldw	$19,$sz
9D18:	cal	&H0B44		;move pointer IZ to the next text line
9D1B:	ldw	$0,$21
9D1E:	gre	iz,$2
9D20:	sbw	$2,$sz
9D22:	cal	&H9921		;delete $2,$3 bytes in the edited file
9D25:	pre	iz,$21
9D27:	jp	&H980E

; text editor, key code &H01 ([S]+down)
9D2A:	cal	&H976E
9D2D:	an	$23,&HF9
9D30:	pre	iz,$19
9D32:	cal	&H0B56
9D35:	jr	nc,&H9D45
9D37:	ldd	$0,(iz+$sy)
9D39:	sbc	$0,&H0A
9D3C:	jr	nz,&H9D40
9D3E:	ldd	$0,(iz+$sy)
9D40:	adw	$17,$sy
9D42:	gre	iz,$19,jr &H9D32
9D45:	sbc	$2,$sx
9D47:	jr	z,&H9D42
9D49:	jp	&H980E
9D4C:	an	$23,&HF9
9D4F:	or	$23,&H04,jr &H9D59
9D53:	an	$23,&HF9
9D56:	or	$23,&H02
9D59:	cal	&H9D5F
9D5C:	jp	&H9814
9D5F:	cal	&H5D57
9D62:	phsw	$18
9D64:	pre	ix,&H16D3
9D68:	ldw	$17,(ix+$sx)
9D6A:	cal	&H5CE3
9D6D:	pre	ix,&H3852
9D71:	ldw	$4,&H0008
9D75:	ldw	$6,&H7767
9D79:	anc	$23,&H02
9D7C:	jr	nz,&H9D88
9D7E:	ldd	$8,(ix+&H08)
9D81:	ldw	$4,&H0005	;number of transferred bytes
9D85:	ld	$6,&H65
9D88:	gre	ix,$2		;source address
9D8A:	ldw	$0,&H151C	;destination address
9D8E:	phsw	$7
9D90:	cal	&H0EBB		;block transfer from bank 2 to bank 1
9D93:	ppsw	$6
9D95:	ppsw	$17
9D97:	pre	ix,&H1100
9D9B:	ldm	$0,(ix+$sx),6
9D9E:	or	$0,&H0A
9DA1:	ld	$1,$6
9DA4:	ld	$2,$sx
9DA6:	stim	$0,(ix+$sx),8
9DA9:	cal	&H029C
9DAC:	cal	&H9774
9DAF:	ldw	$0,&H119B	;destination address
9DB3:	ldw	$2,&H151C	;source address
9DB7:	ldw	$4,&H0020	;number of bytes
9DBB:	cal	&H014C		;block transfer within the RAM
9DBE:	ldw	$10,&H7F00
9DC2:	cal	&H977F
9DC5:	jp	&H930F
9DC8:	cal	&H0323
9DCB:	cal	&H976E
9DCE:	gre	iz,$21
9DD0:	cal	&H975E
9DD3:	cal	&H003C		;ENDSC, test for an end of a BASIC line
9DD6:	jr	c,&H9DFB
9DD8:	anc	$23,&H02
9DDB:	jp	nz,&H9E60
9DDE:	an	$23,&HFB
9DE1:	cal	&H9E1D
9DE4:	pre	iz,$25
9DE6:	ldw	$8,$sy
9DE8:	cal	&H9E0C
9DEB:	ld	$0,&H1A
9DEE:	sbc	(iz+$sx),$0
9DF0:	jp	z,&H9B6E
9DF3:	ldw	$17,$8
9DF6:	gre	iz,$19
9DF8:	jp	&H980E
9DFB:	anc	$23,&H02
9DFE:	jr	z,&H9E06
9E00:	pre	ix,&H1BEF
9E04:	std	$31,(ix+$sx)
9E06:	an	$23,&HF9
9E09:	pre	iz,$21,jr &H9DF8
9E0C:	sbcw	$4,$sy
9E0E:	jr	nc,&H9E12
9E10:	ldw	$4,$sy
9E12:	sbcw	$4,$8
9E15:	rtn	z
9E16:	cal	&H0B44
9E19:	rtn	nc
9E1A:	adw	$8,$sy,jr &H9E12
9E1D:	sbw	$4,$4
9E20:	phsw	$18
9E22:	cal	&H0029
9E25:	jr	nc,&H9E2D
9E27:	cal	&H1F11
9E2A:	ldw	$4,$17
9E2D:	ppsw	$17
9E2F:	jp	&H0093		;SN Error if not an end of a BASIC line

9E32:	pre	ix,&H1BDF
9E36:	ldim	$0,(iz+$sx),8
9E39:	stim	$0,(ix+$sx),8
9E3C:	phsm	$7,8
9E3F:	ldm	$0,(iz+$sx),8
9E42:	stim	$0,(ix+$sx),8
9E45:	ppsm	$0,8
9E48:	ldd	$8,(iz-&H08)
9E4B:	ldw	$8,&H1000
9E4F:	ldi	$10,(iz+$sx)
9E51:	sbc	$10,$sx
9E53:	jr	z,&H9E5B
9E55:	ad	$8,$sy
9E57:	sb	$9,$sy
9E59:	jr	nz,&H9E4F
9E5B:	std	$8,(ix+$sx)
9E5D:	rtn
9E5E:	gre	iz,$21
9E60:	pre	ix,&H16D3
9E64:	ldw	$0,(ix+$sx)
9E66:	pre	ix,&H1BF0
9E6A:	ld	$8,(ix-$sy)
9E6C:	stiw	$0,(ix+$sx)
9E6E:	stw	$21,(ix+$sx)
9E70:	pre	ix,&H1BDF
9E74:	ldm	$0,(ix+$sx),8
9E77:	anc	$23,&H02
9E7A:	cal	nz,&H9E32
9E7D:	pre	iz,$21
9E7F:	an	$23,&HFD
9E82:	sbc	$8,$sx
9E84:	jr	z,&H9EBD
9E86:	ld	$9,&H1A
9E89:	sbc	(iz+$sx),$9
9E8B:	jr	z,&H9EBD
9E8D:	ldd	$9,(iz+$sy)
9E8F:	ld	$9,&H0D
9E92:	sbc	(iz-$sy),$9
9E94:	jr	nz,&H9EA5
9E96:	ld	$9,&H0A
9E99:	sbc	(iz+$sx),$9
9E9B:	jr	nz,&H9E9F
9E9D:	ldd	$9,(iz+$sy)
9E9F:	pre	ix,&H1BF0
9EA3:	adw	(ix+$sx),$30
9EA5:	ldi	$9,(iz+$sx)
9EA7:	sbc	$9,$sz
9EA9:	jr	z,&H9ECB
9EAB:	sbc	$9,&H0D
9EAE:	jr	z,&H9EC0
9EB0:	sbc	$9,&H1A
9EB3:	jr	nz,&H9EA5
9EB5:	pre	ix,&H1BF2
9EB9:	ldw	$21,(ix+$sx)
9EBB:	pre	iz,$21
9EBD:	jp	&H980E
9EC0:	phsm	$3,4
9EC3:	cal	&H29C5		;test the power switch and BRK key
9EC6:	ppsm	$0,4
9EC9:	jr	&H9E96
9ECB:	phs	$8
9ECD:	ldm	$10,(iz+$sx),7
9ED0:	cal	&H9F25
9ED3:	pps	$8
9ED5:	jr	nz,&H9EA5
9ED7:	sbc	$8,&H09
9EDA:	jr	c,&H9F03
9EDC:	gre	iz,$21
9EDE:	phsw	$22
9EE0:	ldi	$9,(iz+&H07)
9EE3:	phs	$8
9EE5:	sb	$8,&H08
9EE8:	phsm	$7,8
9EEB:	pre	ix,&H1BE7
9EEF:	ldm	$0,(ix+$sx),8
9EF2:	ldm	$10,(iz+$sx),7
9EF5:	cal	&H9F25
9EF8:	ppsm	$0,8
9EFB:	pps	$8
9EFD:	ppsw	$21
9EFF:	pre	iz,$21
9F01:	jr	nz,&H9EA5
9F03:	ldd	$9,(iz-$sy)
9F05:	pre	ix,&H1BF0
9F09:	ldw	$21,(ix+$sx)
9F0B:	pre	ix,&H16D3
9F0F:	stw	$21,(ix+$sx)
9F11:	sbcw	$21,$17
9F14:	jr	z,&H9F22
9F16:	ldw	$17,$21
9F19:	gre	iz,$21
9F1B:	cal	&H0B4A
9F1E:	gre	iz,$19
9F20:	pre	iz,$21
9F22:	jp	&H9B6E
9F25:	sb	$8,&H02
9F28:	jr	c,&H9F42
9F2A:	jr	z,&H9F45
9F2C:	sb	$8,&H02
9F2F:	jr	c,&H9F48
9F31:	jr	z,&H9F4C
9F33:	sb	$8,&H02
9F36:	jr	c,&H9F50
9F38:	jr	z,&H9F54
9F3A:	sb	$8,$sy
9F3C:	jr	z,&H9F58
9F3E:	xrcm	$9,$sz,8
9F41:	rtn
9F42:	sbc	$9,$sz,jr &H9F41
9F45:	sbcw	$9,$sz,jr &H9F41
9F48:	xrcm	$9,$sz,3,jr &H9F41
9F4C:	xrcm	$9,$sz,4,jr &H9F41
9F50:	xrcm	$9,$sz,5,jr &H9F41
9F54:	xrcm	$9,$sz,6,jr &H9F41
9F58:	xrcm	$9,$sz,7,jr &H9F41
9F5C:	cal	&H2991		;select the LCD as the output device
9F5F:	jp	&H2446		;mode CAL

; execute a procedure from the table in bank 2 pointed to by IX
9F62:	gst	ua,$3
9F64:	pst	ua,&H24
9F67:	jp	&H0169

9F6A:	cal	&H8588
9F6D:	pst	ua,&H14
9F70:	rtn
9F71:	cal	&H8588
9F74:	pst	ua,&H94
9F77:	rtn
9F78:	gst	ua,$14
9F7A:	pst	ua,&H64
9F7D:	jp	&H97B9
9F80:	pre	ix,&H1100
9F84:	phs	$16
9F86:	ld	$16,(ix+&H04)
9F89:	st	$16,(ix+$sy)
9F8B:	ld	$16,&H0D
9F8E:	cal	&H93E2
9F91:	pps	$16
9F93:	rtn
9F94:	pre	ix,&H16C4
9F98:	ld	$0,&H40
9F9B:	st	$0,(ix+$sx)
9F9D:	ldw	$2,&HA6F4
9FA1:	cal	&H297A		;BRSTR, set ACJMP
9FA4:	pre	ix,&H203E
9FA8:	st	$31,(ix+$sx)
9FAA:	rtn
9FAB:	pre	ix,&H1CF3
9FAF:	st	$31,(ix+$sx)
9FB1:	pre	ix,&H1CF0
9FB5:	st	$31,(ix+$sx)
9FB7:	pre	ix,&H1CF1
9FBB:	st	$31,(ix+$sx)
9FBD:	pre	ix,&H1CF2
9FC1:	st	$31,(ix+$sx)
9FC3:	rtn
9FC4:	pre	ix,&H1CE8
9FC8:	st	$31,(ix+$sx)
9FCA:	pre	ix,&H18CF
9FCE:	ldw	$0,(ix+$sx)
9FD0:	pre	ix,&H1CD0
9FD4:	stiw	$0,(ix+$sx)
9FD6:	stiw	$0,(ix+$sx)
9FD8:	pre	ix,&H18D1
9FDC:	ldw	$2,(ix+$sx)
9FDE:	pre	ix,&H1CE4
9FE2:	stiw	$2,(ix+$sx)
9FE4:	stw	$2,(ix+$sx)
9FE6:	sbw	$2,$sz
9FE8:	bidw	$3
9FEA:	ldw	$4,&H0400
9FEE:	sbcw	$2,$4
9FF1:	jr	c,&HA01C
9FF3:	phsw	$1
9FF5:	adw	$0,$2
9FF8:	pre	ix,&H1CDC
9FFC:	cal	&HA013
9FFF:	ppsw	$0
A001:	bidw	$3
A003:	ldw	$4,&H0200
A007:	sbcw	$2,$4
A00A:	jr	c,&HA01C
A00C:	adw	$0,$2
A00F:	pre	ix,&H1CD4
A013:	stiw	$0,(ix+$sx)
A015:	stiw	$0,(ix+$sx)
A017:	stiw	$0,(ix+$sx)
A019:	stw	$0,(ix+$sx)
A01B:	rtn
A01C:	pre	ix,&H1CE8
A020:	st	$30,(ix+$sx)
A022:	pre	ix,&H1D12
A026:	ld	$0,$sx
A028:	stw	$31,(ix+$sx)
A02A:	jp	&HFCE5
A02D:	cal	&H9FAB
A030:	pre	ix,&H168C
A034:	ld	$1,(ix+$sx)
A036:	an	$1,&H0F
A039:	or	$1,&H30
A03C:	ld	$0,&H46
A03F:	ld	$2,$sx
A041:	pre	ix,&H1CF9
A045:	stm	$0,(ix+$sx),3
A048:	ldw	$15,&H3891
A04C:	cal	&H9F78
A04F:	ldw	$15,&H1CF9
A053:	ld	$17,&H02
A056:	cal	&H97D5
A059:	cal	&H2AE8		;OUTCR, display CR-LF
A05C:	cal	&HA0A9
A05F:	cal	&H9FC4
A062:	cal	&HA90C
A065:	cal	&HA921
A068:	cal	&HA936
A06B:	cal	&HA87B
A06E:	rtn
A06F:	cal	&H9FAB
A072:	pre	ix,&H1CF7
A076:	ld	$0,$sx
A078:	stw	$31,(ix+$sx)
A07A:	pre	ix,&H1CF5
A07E:	stw	$31,(ix+$sx)
A080:	rtn
A081:	ldw	$0,&H0100
A085:	ldw	$2,&H0080
A089:	pre	ix,&H2042
A08D:	stim	$0,(ix+$sx),4
A090:	ld	$1,&H02
A093:	sbc	$18,$sx
A095:	jr	z,&HA09A
A097:	ld	$3,&H02
A09A:	stim	$0,(ix+$sx),4
A09D:	ld	$3,$sx
A09F:	stim	$0,(ix+$sx),4
A0A2:	ld	$3,&H02
A0A5:	stim	$0,(ix+$sx),4
A0A8:	rtn
A0A9:	pre	ix,&H168C
A0AD:	ld	$0,(ix+$sx)
A0AF:	biu	$0
A0B1:	pre	ix,&H18BB
A0B5:	ldw	$2,(ix+$sz)
A0B7:	pre	ix,&H18BD
A0BB:	ldw	$4,(ix+$sz)
A0BD:	ldw	$6,$2
A0C0:	pre	ix,&H1CE9
A0C4:	stm	$2,(ix+$sx),6
A0C7:	rtn
A0C8:	cal	&H5229
A0CB:	ldw	$0,&H0500
A0CF:	sbcw	$15,$sz
A0D1:	rtn	nc
A0D2:	cal	&H246E
A0D5:	cal	&H2465
A0D8:	jp	&H2B6D		;OM Error, insufficient memory
A0DB:	cal	&HA0C8
A0DE:	cal	&H5416
A0E1:	ldw	$0,&H1BD7
A0E5:	pre	ss,$0
A0E7:	pre	ix,&H202A
A0EB:	stw	$0,(ix+$sx)
A0ED:	gre	us,$0
A0EF:	pre	ix,&H202C
A0F3:	stw	$0,(ix+$sx)
A0F5:	cal	&H2771
A0F8:	cal	&H9F94
A0FB:	cal	&HA152
A0FE:	jr	&HA129
A100:	cal	&HA0C8
A103:	cal	&H5416
A106:	ldw	$0,&H1BD7
A10A:	pre	ss,$0
A10C:	pre	ix,&H202A
A110:	stw	$0,(ix+$sx)
A112:	gre	us,$0
A114:	pre	ix,&H202C
A118:	stw	$0,(ix+$sx)
A11A:	cal	&H2771
A11D:	cal	&H9F94
A120:	cal	&HA152
A123:	cal	&HA06F
A126:	cal	&HA181
A129:	cal	&HA12E
A12C:	jr	&HA129
A12E:	pre	ix,&H1134	;ERRN
A132:	st	$31,(ix+$sx)
A134:	cal	&HA295
A137:	cal	&HA2CD
A13A:	pre	ix,&H1CF5
A13E:	ld	$0,$sx
A140:	stw	$31,(ix+$sx)
A142:	cal	&HA2EC
A145:	rtn	c
A146:	sbc	$16,$sx
A148:	jp	z,&HFD64
A14B:	pre	ix,&H483B
A14F:	jp	&H9F62		;execute a procedure from the table in bank 2

A152:	cal	&HA02D
A155:	cal	&HA962
A158:	cal	&HA29E
A15B:	pre	ix,&H1D12
A15F:	stw	$30,(ix+$sx)
A161:	pre	ix,&H1CF3
A165:	st	$30,(ix+$sx)
A167:	ld	$0,$sx
A169:	pre	ix,&H1F68
A16D:	stw	$31,(ix+$sx)
A16F:	cal	&HB4D0
A172:	pre	ix,&H1D12
A176:	ld	$0,$sx
A178:	stw	$31,(ix+$sx)
A17A:	pre	ix,&H1CF3
A17E:	st	$31,(ix+$sx)
A180:	rtn
A181:	pre	ix,&H1CE8
A185:	ld	$0,(ix+$sx)
A187:	bid	$0
A189:	jp	c,&HFE0C
A18C:	pre	iz,&H1D16
A190:	ld	$18,$sx
A192:	cal	&HA849
A195:	jr	c,&HA1EC
A197:	sbc	$16,&H21
A19A:	jr	c,&HA192
A19C:	sbc	$16,&H3E
A19F:	jr	nz,&HA1CA
A1A1:	cal	&HA849
A1A4:	jr	c,&HA1CD
A1A6:	sbc	$16,&H21
A1A9:	jr	c,&HA1BC
A1AB:	ad	$18,$sy
A1AD:	sbc	$18,&H07
A1B0:	jr	nc,&HA1CA
A1B2:	ld	$0,$16
A1B5:	cal	&H00B6
A1B8:	sti	$0,(iz+$sx)
A1BA:	jr	&HA1A1
A1BC:	sbc	$18,$sy
A1BE:	jr	c,&HA1A1
A1C0:	cal	&HA849
A1C3:	jr	c,&HA1CD
A1C5:	sbc	$16,&H21
A1C8:	jr	c,&HA1C0
A1CA:	jp	&HFD64
A1CD:	sbc	$18,&H06
A1D0:	jr	nz,&HA1CA
A1D2:	pre	ix,&H1D16
A1D6:	ldm	$2,(ix+$sx),6
A1D9:	ld	$9,&H22
A1DC:	ldw	$10,&H5250
A1E0:	ldw	$12,&H3A4E
A1E4:	ld	$14,&H22
A1E7:	xrcm	$2,$9,6
A1EA:	jr	nz,&HA1CA
A1EC:	gre	us,$0
A1EE:	pre	ix,&H202E
A1F2:	stw	$0,(ix+$sx)
A1F4:	pre	ix,&H1CE6
A1F8:	ldw	$0,(ix+$sx)
A1FA:	pre	us,$0
A1FC:	cal	&HEF1B
A1FF:	cal	&HA936
A202:	pre	ix,&H1CDA
A206:	ldw	$0,(ix+$sx)
A208:	pre	ix,&H203F
A20C:	stw	$0,(ix+$sx)
A20E:	cal	&HA081
A211:	ld	$0,$sx
A213:	pre	ix,&H1D12
A217:	stw	$31,(ix+$sx)
A219:	pre	ix,&H1CF3
A21D:	ld	$0,&H02
A220:	st	$0,(ix+$sx)
A222:	cal	&HC986
A225:	ld	$0,$sx
A227:	pre	ix,&H1D12
A22B:	stw	$31,(ix+$sx)
A22D:	pre	ix,&H1CF3
A231:	st	$31,(ix+$sx)
A233:	pre	ix,&H202E
A237:	ldw	$0,(ix+$sx)
A239:	pre	us,$0
A23B:	rtn
A23C:	cal	&HA849
A23F:	jr	c,&HA249
A241:	sbc	$16,&H21
A244:	jr	c,&HA23C
A246:	jp	&HFD64
A249:	pre	ix,&H1CF0
A24D:	ld	$0,(ix+$sx)
A24F:	or	$0,&H80
A252:	st	$0,(ix+$sx)
A254:	rtn
A255:	cal	&HA849
A258:	jr	c,&HA261
A25A:	sbc	$16,&H21
A25D:	jr	c,&HA255
A25F:	jr	&HA246
A261:	pre	ix,&H1CF0
A265:	ld	$0,(ix+$sx)
A267:	an	$0,&H7F
A26A:	st	$0,(ix+$sx)
A26C:	rtn
A26D:	pre	ss,&H1BD7
A271:	pre	us,&H1CD0
A275:	pre	ix,&H16C4
A279:	st	$31,(ix+$sx)
A27B:	ld	$14,&H08
A27E:	st	$14,(ix+$sy)
A280:	pre	ix,&H168C
A284:	ld	$14,(ix+$sx)
A286:	pre	ix,&H1D12
A28A:	ldw	$19,(ix+$sx)
A28C:	sbcw	$19,$sy
A28E:	jr	nc,&HA292
A290:	adw	$19,$sy
A292:	jp	&H6CA6
A295:	cal	&H9F80
A298:	ld	$16,&H3E
A29B:	jp	&H93E2
A29E:	pre	ix,&H1CD4
A2A2:	ldw	$0,(ix+$sx)
A2A4:	ldw	$2,&H0010
A2A8:	sbw	$0,$2
A2AB:	stw	$0,(ix+$sx)
A2AD:	pre	ix,$0
A2AF:	sti	$30,(ix+$sx)
A2B1:	pre	iz,&H1CF9
A2B5:	ld	$0,&H0F
A2B8:	ldi	$1,(iz+$sx)
A2BA:	sti	$1,(ix+$sx)
A2BC:	sb	$0,$sy
A2BE:	jr	z,&HA2C6
A2C0:	sbc	$1,$sx
A2C2:	jr	z,&HA2BA
A2C4:	jr	&HA2B8
A2C6:	pre	ix,&H1CF4
A2CA:	st	$31,(ix+$sx)
A2CC:	rtn
A2CD:	cal	&HA39D
A2D0:	sbw	$2,$2
A2D3:	pre	ix,&H1000
A2D7:	ldi	$0,(iz+$sx)
A2D9:	sbc	$0,$sx
A2DB:	jr	z,&HA2E3
A2DD:	sti	$0,(ix+$sx)
A2DF:	adw	$2,$sy
A2E1:	jr	&HA2D7
A2E3:	pre	ix,&H1CF7
A2E7:	stw	$2,(ix+$sx)
A2E9:	jp	&H9F80
A2EC:	pre	iz,&H1D16
A2F0:	sbw	$18,$18
A2F3:	cal	&HA849
A2F6:	jr	c,&HA329
A2F8:	sbc	$16,&H21
A2FB:	jr	c,&HA313
A2FD:	adw	$18,$sy
A2FF:	ld	$0,$16
A302:	cal	&H00B6
A305:	sbc	$0,&H41
A308:	jr	c,&HA319
A30A:	sbc	$0,&H5B
A30D:	jr	nc,&HA319
A30F:	sti	$0,(iz+$sx)
A311:	jr	&HA2F3
A313:	sbcw	$18,$sy
A315:	jr	nc,&HA32C
A317:	jr	&HA2F3
A319:	sbc	$16,&H3E
A31C:	jp	nz,&HFD64
A31F:	cal	&HA870
A322:	sbw	$18,$sy
A324:	jp	z,&HFD64
A327:	jr	&HA32C
A329:	sbcw	$18,$sy
A32B:	rtn	c
A32C:	pre	ix,&H1D16
A330:	ldw	$2,&H0003
A334:	sbcw	$18,$2
A337:	jr	z,&HA366
A339:	ldw	$9,&H5254
A33D:	ld	$11,&H4F
A340:	ldw	$2,&H0004
A344:	sbcw	$18,$2
A347:	jr	z,&HA37A
A349:	ldw	$2,&H0005
A34D:	sbcw	$18,$2
A350:	jp	nz,&HFD64
A353:	ldw	$12,&H4646
A357:	ldm	$2,(ix+$sx),5
A35A:	xrcm	$2,$9,5
A35D:	jp	nz,&HFD64
A360:	ld	$16,&H03
A363:	sbc	$30,$sx
A365:	rtn
A366:	ldm	$2,(ix+$sx),3
A369:	ldw	$9,&H5552
A36D:	ld	$11,&H4E
A370:	xrcm	$2,$9,3
A373:	jp	nz,&HFD64
A376:	ld	$16,$sy
A378:	jr	&HA363
A37A:	ldm	$2,(ix+$sx),4
A37D:	ld	$12,&H4E
A380:	xrcm	$2,$9,4
A383:	jr	nz,&HA38A
A385:	ld	$16,&H02
A388:	jr	&HA363
A38A:	ldw	$9,&H4445
A38E:	ldw	$11,&H5449
A392:	xrcm	$2,$9,4
A395:	jp	nz,&HFD64
A398:	ld	$16,&H04
A39B:	jr	&HA363
A39D:	cal	&H2991		;select the LCD as the output device
A3A0:	cal	&H0317		;respect the cursor movement range setting
A3A3:	ld	$0,(ix+$sy)
A3A5:	sti	$0,(ix+&H05)
A3A8:	sti	$0,(ix+$sx)
A3AA:	st	$0,(ix+$sx)
A3AC:	cal	&H29B4		;clear the ANSFG variable
A3AF:	cal	&H29BB
A3B2:	cal	&HA3D6
A3B5:	phs	$0
A3B7:	cal	&H02FE
A3BA:	pre	iz,&H1105
A3BE:	ldd	$0,(iz+$sx)
A3C0:	pre	iz,&H113B
A3C4:	ldd	$1,(iz+$sz)
A3C6:	cal	&H0323
A3C9:	pps	$0
A3CB:	sbc	$0,&H1A
A3CE:	jr	z,&HA3D3
A3D0:	sbc	$30,$sx
A3D2:	rtn
A3D3:	sbc	$31,$sy
A3D5:	rtn
A3D6:	cal	&H23C8
A3D9:	sbc	$0,&HFD
A3DC:	jr	z,&HA3FE
A3DE:	sbc	$0,&H80
A3E1:	jr	c,&HA3E8
A3E3:	sbc	$0,&HA6
A3E6:	jr	c,&HA404
A3E8:	sbc	$0,&H0D
A3EB:	rtn	z
A3EC:	sbc	$0,&HE0
A3EF:	jr	nc,&HA409
A3F1:	sbc	$0,&H0B
A3F4:	jr	nz,&HA3F9
A3F6:	ld	$0,&H02
A3F9:	cal	&H2038
A3FC:	jr	&HA3D6
A3FE:	ld	$0,&H1A
A401:	sbc	$31,$sy
A403:	rtn
A404:	cal	&H2143
A407:	jr	&HA3D6
A409:	sbc	$0,&HE2
A40C:	jr	z,&HA42F
A40E:	sbc	$0,&HE6
A411:	jr	z,&HA437
A413:	sbc	$0,&HE7
A416:	jr	z,&HA43F
A418:	sbc	$0,&HE9
A41B:	jr	z,&HA444
A41D:	sbc	$0,&HF0
A420:	jr	c,&HA3D6
A422:	sbc	$0,&HFA
A425:	jr	nc,&HA3D6
A427:	an	$0,&H0F
A42A:	or	$0,&H30
A42D:	jr	&HA3F9
A42F:	cal	&H29AA
A432:	cal	&H21A7
A435:	jr	&HA3D6
A437:	cal	&H22F2
A43A:	cal	&H2ADB
A43D:	jr	&HA3D6
A43F:	cal	&H2354
A442:	jr	&HA3D6
A444:	cal	&H29AA
A447:	cal	&H21AA
A44A:	jr	&HA3D6
A44C:	pre	ix,&H1D0F
A450:	ld	$16,(ix-$sy)
A452:	sbc	$16,$sx
A454:	jr	nz,&HA486
A456:	pre	ix,&H1CED
A45A:	ldw	$2,&H1CEB
A45E:	ldw	$2,($2)
A461:	sbcw	(ix+$sx),$2
A463:	jr	nc,&HA497
A465:	ldw	$0,(ix+$sx)
A467:	ld	$16,($sz)
A469:	adw	$0,$sy
A46B:	stw	$0,(ix+$sx)
A46D:	sbc	$16,&H0D
A470:	jr	nz,&HA48F
A472:	ld	$16,&H0A
A475:	ld	$2,($sz)
A477:	sbc	$2,&H0A
A47A:	jr	nz,&HA483
A47C:	ld	$16,$2
A47F:	adw	$0,$sy
A481:	stw	$0,(ix+$sx)
A483:	sbc	$30,$sx
A485:	rtn
A486:	ld	$13,(ix+$sx)
A488:	ld	$14,(ix+$sy)
A48A:	ld	$15,$sx
A48C:	stm	$13,(ix-$sy),3
A48F:	sbc	$16,&H1A
A492:	jr	nz,&HA483
A494:	sbc	$31,$sy
A496:	rtn
A497:	ld	$16,&H1A
A49A:	jr	&HA494
A49C:	cal	&H023D
A49F:	cal	&H03A4
A4A2:	phs	$0
A4A4:	cal	&H0241
A4A7:	pps	$0
A4A9:	cal	&H198F
A4AC:	jr	c,&HA49C
A4AE:	sbc	$0,&HFD
A4B1:	jr	nz,&HA4B6
A4B3:	ld	$0,&H1A
A4B6:	pre	ix,&H1F81
A4BA:	ld	$1,$sx
A4BC:	stw	$0,(ix+$sx)
A4BE:	rtn
A4BF:	phsm	$3,4
A4C2:	pre	iz,$17
A4C4:	ld	$0,(iz+$sy)
A4C6:	anc	$0,$sy
A4C8:	jp	z,&HFE6E
A4CB:	anc	$0,&H10
A4CE:	jr	nz,&HA4F4
A4D0:	ld	$19,(iz+$sx)
A4D2:	cal	&HA5AD
A4D5:	jr	c,&HA4F4
A4D7:	pre	iz,$17
A4D9:	ld	$0,(iz+&H02)
A4DC:	anc	$0,&H80
A4DF:	jr	z,&HA4EE
A4E1:	sbc	$16,&H1A
A4E4:	jr	z,&HA4F4
A4E6:	sbc	$16,&H0D
A4E9:	jr	nz,&HA4EE
A4EB:	ld	$16,&H0A
A4EE:	sbc	$30,$sx
A4F0:	ppsm	$0,4
A4F3:	rtn
A4F4:	pre	iz,$17
A4F6:	ld	$0,(iz+$sy)
A4F8:	or	$0,&H10
A4FB:	st	$0,(iz+$sy)
A4FD:	sbc	$31,$sy
A4FF:	jr	&HA4F0
A501:	phsm	$3,4
A504:	pre	iz,$17
A506:	ld	$19,(iz+$sx)
A508:	sbc	$19,$sx
A50A:	jp	nz,&HFE62
A50D:	ld	$29,(iz+&H03)
A510:	ldw	$0,&H1739
A514:	st	$29,($sz)
A516:	ld	$0,(iz+&H02)
A519:	anc	$0,&H80
A51C:	phs	$16
A51E:	jr	nz,&HA542
A520:	sbc	$29,$sx
A522:	jr	nz,&HA52C
A524:	sbc	$16,&H0A
A527:	jr	nz,&HA52C
A529:	ld	$16,&H0D
A52C:	phs	$16
A52E:	cal	&H29C5		;test the power switch and BRK key
A531:	pps	$16
A533:	cal	&H2AF1		;display character $16
A536:	ldw	$0,&H1739
A53A:	st	$31,($sz)
A53C:	pps	$16
A53E:	ppsm	$0,4
A541:	rtn
A542:	sbc	$29,$sx
A544:	jr	z,&HA524
A546:	sbc	$16,&H0A
A549:	jr	nz,&HA52C
A54B:	cal	&H29C5		;test the power switch and BRK key
A54E:	ld	$16,&H0D
A551:	cal	&H2AF1		;display character $16
A554:	ld	$16,&H0A
A557:	jr	&HA52C
A559:	pre	iz,$17
A55B:	ld	$0,(iz+$sy)
A55D:	anc	$0,$sy
A55F:	jp	z,&HFE6E
A562:	ld	$15,$16
A565:	ld	$0,(iz+&H02)
A568:	anc	$0,&H80
A56B:	jr	z,&HA575
A56D:	sbc	$15,&H0A
A570:	jr	nz,&HA575
A572:	ld	$15,&H0D
A575:	pre	iz,&H2054
A579:	sbw	(iz+$sx),$30
A57B:	ldw	$2,(iz+$sx)
A57D:	ldw	$0,&H2056
A581:	adw	$0,$2
A584:	st	$15,($sz)
A586:	pre	iz,$17
A588:	ld	$0,(iz+$sy)
A58A:	an	$0,&HEF
A58D:	st	$0,(iz+$sy)
A58F:	sbc	$30,$sx
A591:	rtn
A592:	pre	iz,$17
A594:	ld	$19,(iz+$sx)
A596:	sbc	$19,$sx
A598:	jp	nz,&HFE62
A59B:	ld	$4,(iz+&H03)
A59E:	sbc	$4,$sx
A5A0:	rtn	nz
A5A1:	ld	$0,(iz+$sy)
A5A3:	anc	$0,$sy
A5A5:	rtn	z
A5A6:	anc	$0,&H10
A5A9:	rtn	nz
A5AA:	jp	&HEF1B
A5AD:	sbc	$19,$sx
A5AF:	jp	nz,&HFE62
A5B2:	cal	&HA5B6
A5B5:	rtn
A5B6:	phsw	$18
A5B8:	pre	iz,&H2054
A5BC:	ldw	$2,(iz+$sx)
A5BE:	ldw	$0,&H2056
A5C2:	adw	$0,$2
A5C5:	ld	$16,($sz)
A5C7:	sbc	$16,$sx
A5C9:	jr	nz,&HA5F0
A5CB:	cal	&HEF1B
A5CE:	cal	&HA39D
A5D1:	ld	$1,&H0D
A5D4:	jr	nc,&HA5D9
A5D6:	ld	$1,&H1A
A5D9:	pre	ix,&H2056
A5DD:	ldi	$0,(iz+$sx)
A5DF:	sbc	$0,$sx
A5E1:	jr	z,&HA5E7
A5E3:	sti	$0,(ix+$sx)
A5E5:	jr	&HA5DD
A5E7:	sti	$1,(ix+$sx)
A5E9:	st	$31,(ix+$sx)
A5EB:	cal	&H9F80
A5EE:	jr	&HA5B8
A5F0:	adw	(iz+$sx),$30
A5F2:	sbc	$16,&H1A
A5F5:	jr	z,&HA5FC
A5F7:	sbc	$30,$sx
A5F9:	ppsw	$17
A5FB:	rtn
A5FC:	sbc	$31,$sy
A5FE:	ppsw	$17
A600:	rtn
A601:	pre	ix,&H1CF0
A605:	ld	$0,(ix+$sx)
A607:	anc	$0,&H80
A60A:	rtn	z
A60B:	pre	ix,&H1D12
A60F:	ldw	$0,(ix+$sx)
A611:	ancw	$0,$sz
A613:	rtn	z
A614:	cal	&H9F80
A617:	ld	$16,&H28
A61A:	cal	&H93E2
A61D:	cal	&HFF20
A620:	ld	$16,&H29
A623:	cal	&H93E2
A626:	ld	$16,&H20
A629:	cal	&H93E2
A62C:	cal	&HA683
A62F:	ld	$16,&H20
A632:	cal	&H93E2
A635:	ld	$16,&H3F
A638:	cal	&H93E2
A63B:	gre	ss,$0
A63D:	pre	ix,&H2036
A641:	stw	$0,(ix+$sx)
A643:	gre	us,$0
A645:	pre	ix,&H2038
A649:	stw	$0,(ix+$sx)
A64B:	pre	ix,&H203E
A64F:	ld	$0,&H02
A652:	st	$0,(ix+$sx)
A654:	cal	&H23C8
A657:	ld	$16,$sz
A659:	sbc	$0,&H0D
A65C:	jr	z,&HA669
A65E:	cal	&H00B6
A661:	sbc	$0,&H43
A664:	jr	nz,&HA654
A666:	cal	&H93E2
A669:	cal	&H9F80
A66C:	pre	ix,&H2036
A670:	ldw	$0,(ix+$sx)
A672:	pre	ss,$0
A674:	pre	ix,&H2038
A678:	ldw	$0,(ix+$sx)
A67A:	pre	us,$0
A67C:	pre	ix,&H203E
A680:	st	$31,(ix+$sx)
A682:	rtn
A683:	cal	&HA0A9
A686:	ldw	$0,$sy
A688:	pre	ix,&H1D12
A68C:	sbcw	(ix+$sx),$0
A68E:	jr	z,&HA6A8
A690:	phsw	$1
A692:	cal	&H29C5		;test the power switch and BRK key
A695:	cal	&HA456
A698:	jr	c,&HA6A5
A69A:	sbc	$16,&H0A
A69D:	jr	nz,&HA692
A69F:	ppsw	$0
A6A1:	adw	$0,$sy
A6A3:	jr	&HA688
A6A5:	ppsw	$0
A6A7:	rtn
A6A8:	cal	&HA456
A6AB:	rtn	c
A6AC:	sbc	$16,&H0A
A6AF:	rtn	z
A6B0:	cal	&H93E2
A6B3:	jr	&HA6A8
A6B5:	sb	$0,&H05
A6B8:	jp	&HA741
A6BB:	cal	&H93E2
A6BE:	jr	&HA711
A6C0:	cal	&H93E2
A6C3:	jr	&HA6D3
A6C5:	cal	&H93E2
A6C8:	pre	ix,&H1CF0
A6CC:	ld	$0,(ix+$sx)
A6CE:	or	$0,&H80
A6D1:	st	$0,(ix+$sx)
A6D3:	cal	&H9F80
A6D6:	pre	ix,&H203E
A6DA:	ld	$0,(ix+$sx)
A6DC:	sbc	$0,&H06
A6DF:	jp	z,&HEF67
A6E2:	jr	&HA66C
A6E4:	cal	&H93E2
A6E7:	pre	ix,&H1CF0
A6EB:	ld	$0,(ix+$sx)
A6ED:	an	$0,&H7F
A6F0:	st	$0,(ix+$sx)
A6F2:	jr	&HA6D3
A6F4:	pre	ix,&H1739
A6F8:	st	$31,(ix+$sx)
A6FA:	cal	&H0323
A6FD:	cal	&H9F80
A700:	pre	ix,&H203E
A704:	ld	$0,(ix+$sx)
A706:	sbc	$0,$sx
A708:	jr	nz,&HA71A
A70A:	ldw	$15,&H424C
A70E:	cal	&H9F78
A711:	pre	ix,&H203E
A715:	st	$31,(ix+$sx)
A717:	jp	&HFEC5
A71A:	sbc	$0,&H06
A71D:	jr	z,&HA6B5
A71F:	sbc	$0,&H07
A722:	jr	z,&HA6B5
A724:	sbc	$0,&H0B
A727:	jr	z,&HA72E
A729:	sbc	$0,&H0C
A72C:	jr	nz,&HA741
A72E:	pre	ix,&H203A
A732:	ldw	$2,(ix+$sx)
A734:	pre	ss,$2
A736:	pre	ix,&H203C
A73A:	ldw	$2,(ix+$sx)
A73C:	pre	us,$2
A73E:	sb	$0,&H0A
A741:	ad	$0,&H05
A744:	pre	ix,&H203E
A748:	st	$0,(ix+$sx)
A74A:	ldw	$15,&H4252
A74E:	cal	&H9F78
A751:	cal	&H23C8
A754:	ld	$16,$sz
A756:	cal	&H00B6
A759:	sbc	$0,&H41
A75C:	jp	z,&HA6BB
A75F:	sbc	$0,&H43
A762:	jp	z,&HA6C0
A765:	sbc	$0,&H0D
A768:	jp	z,&HA6D3
A76B:	sbc	$0,&H54
A76E:	jp	z,&HA6C5
A771:	sbc	$0,&H4E
A774:	jp	z,&HA6E4
A777:	sbc	$0,&H44
A77A:	jr	nz,&HA751
A77C:	cal	&H93E2
A77F:	gre	ss,$0
A781:	pre	ix,&H203A
A785:	stw	$0,(ix+$sx)
A787:	gre	us,$0
A789:	pre	ix,&H203C
A78D:	stw	$0,(ix+$sx)
A78F:	pre	ix,&H203E
A793:	ld	$0,&H05
A796:	ad	(ix+$sx),$0
A798:	cal	&H9F80
A79B:	ldw	$15,&H47CA
A79F:	cal	&H9F78
A7A2:	pre	ix,&H1D16
A7A6:	st	$31,(ix+$sx)
A7A8:	pre	ix,&H1E18
A7AC:	stw	$30,(ix+$sx)
A7AE:	cal	&HA39D
A7B1:	ldi	$0,(iz+$sx)
A7B3:	sbc	$0,$sx
A7B5:	jp	z,&HA80E
A7B8:	sbc	$0,&H21
A7BB:	jr	c,&HA7B1
A7BD:	cal	&H00AB
A7C0:	jr	c,&HA7C8
A7C2:	sbc	$0,&H5F
A7C5:	jp	nz,&HA80E
A7C8:	ld	$16,$sz
A7CA:	cal	&HB124
A7CD:	ldi	$0,(iz+$sx)
A7CF:	cal	&H00AB
A7D2:	jr	c,&HA7C8
A7D4:	cal	&H002B		;OKNM1, is $0 a digit?
A7D7:	jr	c,&HA7C8
A7D9:	sbc	$0,&H5F
A7DC:	jr	z,&HA7C8
A7DE:	sbc	$0,$sx
A7E0:	jr	z,&HA7EB
A7E2:	sbc	$0,&H21
A7E5:	jr	nc,&HA80E
A7E7:	ldi	$0,(iz+$sx)
A7E9:	jr	&HA7DE
A7EB:	cal	&HB2DC
A7EE:	ancw	$18,$18
A7F1:	jr	z,&HA80E
A7F3:	pre	ix,&H1F70
A7F7:	stw	$18,(ix+$sx)
A7F9:	ld	$16,&H02
A7FC:	ld	$17,&H11
A7FF:	cal	&HC8A6
A802:	jr	nc,&HA80E
A804:	sbc	(ix+&H03),$30
A807:	jr	nz,&HA814
A809:	cal	&HC953
A80C:	jr	c,&HA804
A80E:	cal	&H2ADB
A811:	jp	&HA7A2
A814:	cal	&HDC38
A817:	anc	$19,&HF0
A81A:	jr	nz,&HA825
A81C:	sbc	$19,$sx
A81E:	jr	z,&HA80E
A820:	sbc	$19,&H09
A823:	jr	nc,&HA80E
A825:	phsw	$16
A827:	phs	$19
A829:	cal	&H9F80
A82C:	pps	$19
A82E:	phs	$19
A830:	cal	&HFB88
A833:	ld	$16,&H3A
A836:	cal	&H93E2
A839:	ld	$16,&H20
A83C:	cal	&H93E2
A83F:	pps	$19
A841:	ppsw	$15
A843:	cal	&HFBE0
A846:	jp	&HA798
A849:	pre	ix,&H1CF7
A84D:	ldw	$0,(ix+$sx)
A84F:	pre	ix,&H1CF5
A853:	ldw	$2,(ix+$sx)
A855:	sbcw	$2,$sz
A857:	jr	z,&HA86A
A859:	ldw	$0,&H1000
A85D:	adw	$0,$2
A860:	ld	$16,($sz)
A862:	adw	$2,$sy
A864:	stw	$2,(ix+$sx)
A866:	sb	$0,$sz
A868:	jr	&HA86D
A86A:	ld	$0,&H40
A86D:	pfl	$0
A86F:	rtn
A870:	pre	ix,&H1CF5
A874:	ldw	$0,(ix+$sx)
A876:	sbw	$0,$sy
A878:	stw	$0,(ix+$sx)
A87A:	rtn

A87B:	sbw	$0,$sz
A87D:	pre	ix,&H1E1C
A881:	st	$31,(ix+$sx)
A883:	pre	ix,&H1F6A
A887:	stw	$0,(ix+$sx)
A889:	pre	ix,&H1D14
A88D:	stw	$0,(ix+$sx)
A88F:	pre	ix,&H1E1A
A893:	st	$31,(ix+$sx)
A895:	cal	&HC77A
A898:	cal	&HC7BC
A89B:	pre	ix,&H1F57
A89F:	st	$31,(ix+$sx)
A8A1:	ldw	$16,&H1F57
A8A5:	cal	&HC802
A8A8:	ldw	$2,&H3897
A8AC:	ldw	$4,&H0009
A8B0:	ld	$6,&H11
A8B3:	cal	&HA8E1
A8B6:	ldw	$2,&H38A0
A8BA:	ldw	$4,&H000A
A8BE:	ld	$6,&H11
A8C1:	cal	&HA8E1
A8C4:	ldw	$2,&H38AA
A8C8:	ldw	$4,&H000A
A8CC:	ld	$6,&H11
A8CF:	cal	&HA8E1
A8D2:	ldw	$2,&H38B4
A8D6:	ldw	$4,&H000A
A8DA:	ld	$6,&H11
A8DD:	cal	&HA8E1
A8E0:	rtn

A8E1:	ldw	$0,&H1F57
A8E5:	st	&H11,($sz)
A8E8:	ldw	$0,&H1F5B
A8EC:	st	$6,($sz)
A8EE:	pre	ix,&H1E18
A8F2:	stw	$4,(ix+$sx)
A8F4:	ldw	$0,&H1D16	;destination address
A8F8:	cal	&H0EBB		;block transfer from bank 2 to bank 1
A8FB:	cal	&HB26C
A8FE:	pre	ix,&H1F58
A902:	stw	$18,(ix+$sx)
A904:	ldw	$16,&H1F57
A908:	cal	&HC802
A90B:	rtn
